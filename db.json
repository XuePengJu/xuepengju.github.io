{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"source/img/1638799083784.png","path":"img/1638799083784.png","modified":1,"renderable":0},{"_id":"source/img/apifoxdemo.jpg","path":"img/apifoxdemo.jpg","modified":1,"renderable":0},{"_id":"source/img/charles_20220101225450.png","path":"img/charles_20220101225450.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"source/img/banner.png","path":"img/banner.png","modified":1,"renderable":0},{"_id":"source/img/ddsnto_step.png","path":"img/ddsnto_step.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"source/img/environment/1895590-20200229210636360-1610818154.png","path":"img/environment/1895590-20200229210636360-1610818154.png","modified":1,"renderable":0},{"_id":"source/img/environment/1895590-20200229211014622-396878393.png","path":"img/environment/1895590-20200229211014622-396878393.png","modified":1,"renderable":0},{"_id":"source/img/environment/1895590-20200229211000223-187798199.png","path":"img/environment/1895590-20200229211000223-187798199.png","modified":1,"renderable":0},{"_id":"source/img/environment/1895590-20200229211032271-1280305583.png","path":"img/environment/1895590-20200229211032271-1280305583.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"source/img/1EE1E433-AB1C-436F-95B0-EFDA18C2BE82.png","path":"img/1EE1E433-AB1C-436F-95B0-EFDA18C2BE82.png","modified":1,"renderable":0},{"_id":"source/img/NFC/OpenWrt_Wifi.jpg","path":"img/NFC/OpenWrt_Wifi.jpg","modified":1,"renderable":0},{"_id":"source/img/NFC/WeChat.jpg","path":"img/NFC/WeChat.jpg","modified":1,"renderable":0},{"_id":"source/img/environment/1895590-20200229210909009-805568491.png","path":"img/environment/1895590-20200229210909009-805568491.png","modified":1,"renderable":0},{"_id":"source/img/environment/1895590-20200229210835166-2050290710.png","path":"img/environment/1895590-20200229210835166-2050290710.png","modified":1,"renderable":0},{"_id":"source/img/blog/Python接口自动化测试/1651595166002.png","path":"img/blog/Python接口自动化测试/1651595166002.png","modified":1,"renderable":0},{"_id":"source/img/blog/Python接口自动化测试/1651595044388.png","path":"img/blog/Python接口自动化测试/1651595044388.png","modified":1,"renderable":0},{"_id":"source/img/blog/Python接口自动化测试/1651732273876.png","path":"img/blog/Python接口自动化测试/1651732273876.png","modified":1,"renderable":0},{"_id":"source/img/environment/1895590-20200229210702614-864284209.png","path":"img/environment/1895590-20200229210702614-864284209.png","modified":1,"renderable":0},{"_id":"source/img/environment/1895590-20200229210742813-1698355068.png","path":"img/environment/1895590-20200229210742813-1698355068.png","modified":1,"renderable":0},{"_id":"source/img/8B2FEFE6-9051-432B-BAED-7B76EFA85FE1.png","path":"img/8B2FEFE6-9051-432B-BAED-7B76EFA85FE1.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/05/05-02.png","path":"img/blog/postman/05/05-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/06/06-01.png","path":"img/blog/postman/06/06-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/06/06-02.png","path":"img/blog/postman/06/06-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/06/06-03.png","path":"img/blog/postman/06/06-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/06/06-04.png","path":"img/blog/postman/06/06-04.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/10/010-01.png","path":"img/blog/postman/10/010-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/10/010-02.png","path":"img/blog/postman/10/010-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/10/010-04.png","path":"img/blog/postman/10/010-04.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/10/010-05.png","path":"img/blog/postman/10/010-05.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/10/010-06.png","path":"img/blog/postman/10/010-06.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/09/09-01.png","path":"img/blog/postman/09/09-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/12/012-01.png","path":"img/blog/postman/12/012-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/13/013-01.png","path":"img/blog/postman/13/013-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/13/013-02.png","path":"img/blog/postman/13/013-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-02.png","path":"img/blog/postman/14/014-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-08.png","path":"img/blog/postman/14/014-08.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-10.png","path":"img/blog/postman/14/014-10.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-14.png","path":"img/blog/postman/14/014-14.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-13.png","path":"img/blog/postman/14/014-13.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/16/016-01.png","path":"img/blog/postman/16/016-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/15/015-02.png","path":"img/blog/postman/15/015-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/19/019-01.png","path":"img/blog/postman/19/019-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/20/020-01.png","path":"img/blog/postman/20/020-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/21/021-01.png","path":"img/blog/postman/21/021-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/21/021-02.png","path":"img/blog/postman/21/021-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/21/021-03.png","path":"img/blog/postman/21/021-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/21/021-04.png","path":"img/blog/postman/21/021-04.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/21/021-05.png","path":"img/blog/postman/21/021-05.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/02/02-02.png","path":"img/blog/postman/02/02-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/05/05-01.png","path":"img/blog/postman/05/05-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/05/05-03.png","path":"img/blog/postman/05/05-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/03/03-01.png","path":"img/blog/postman/03/03-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/03/03-02.png","path":"img/blog/postman/03/03-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/04/04-01.png","path":"img/blog/postman/04/04-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/04/04-02.png","path":"img/blog/postman/04/04-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/04/04-03.png","path":"img/blog/postman/04/04-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/07/07-01.png","path":"img/blog/postman/07/07-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/07/07-02.png","path":"img/blog/postman/07/07-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/08/08-01.png","path":"img/blog/postman/08/08-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/08/08-02.png","path":"img/blog/postman/08/08-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/10/010-03.png","path":"img/blog/postman/10/010-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/09/09-02.png","path":"img/blog/postman/09/09-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/09/09-03.png","path":"img/blog/postman/09/09-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/11/011-01.png","path":"img/blog/postman/11/011-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/11/011-02.png","path":"img/blog/postman/11/011-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/12/012-02.png","path":"img/blog/postman/12/012-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/13/013-03.png","path":"img/blog/postman/13/013-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/13/013-04.png","path":"img/blog/postman/13/013-04.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/13/013-05.png","path":"img/blog/postman/13/013-05.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/13/013-06.png","path":"img/blog/postman/13/013-06.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-01.png","path":"img/blog/postman/14/014-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-03.png","path":"img/blog/postman/14/014-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-04.png","path":"img/blog/postman/14/014-04.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-06.png","path":"img/blog/postman/14/014-06.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-07.png","path":"img/blog/postman/14/014-07.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-09.png","path":"img/blog/postman/14/014-09.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/15/015-01.png","path":"img/blog/postman/15/015-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/15/015-03.png","path":"img/blog/postman/15/015-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/15/015-04.png","path":"img/blog/postman/15/015-04.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/18/018-01.png","path":"img/blog/postman/18/018-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/19/019-02.png","path":"img/blog/postman/19/019-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/20/020-02.png","path":"img/blog/postman/20/020-02.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/20/020-03.png","path":"img/blog/postman/20/020-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/21/021-06.png","path":"img/blog/postman/21/021-06.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/01/01.png","path":"img/blog/postman/01/01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/02/02-01.png","path":"img/blog/postman/02/02-01.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/07/07-03.png","path":"img/blog/postman/07/07-03.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-05.png","path":"img/blog/postman/14/014-05.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-11.png","path":"img/blog/postman/14/014-11.png","modified":1,"renderable":0},{"_id":"source/img/blog/postman/14/014-12.png","path":"img/blog/postman/14/014-12.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1645540572000},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1645540572000},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1645540572000},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1645540572000},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1645540572000},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1645540572000},{"_id":"themes/yilia/_config.yml","hash":"8a905483aaee49162017848a6a7dd78fa979a9d5","modified":1651764603776},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1645540572000},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1645540572000},{"_id":"source/tags/index.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1651763333708},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1651766657695},{"_id":"source/_posts/.DS_Store","hash":"a388db313f3b8114602875b664afa924fe194d2a","modified":1651763333597},{"_id":"source/_posts/【公开api接口】字符串加密-解密API接口.md","hash":"3344b5c2810b92917ee5d043ff28bc2925541ed2","modified":1651763333622},{"_id":"source/about/index.md","hash":"05e46d99794833ebd6482159d6219be84d31b1e0","modified":1651763333623},{"_id":"source/img/1638799083784.png","hash":"58e494cf6b136a040002f9f69c27ecaff6a402b7","modified":1651763333624},{"_id":"source/img/apifoxdemo.jpg","hash":"22c91395c01c2add0399a91cee14c66e2c513ccc","modified":1651763333629},{"_id":"source/img/charles_20220101225450.png","hash":"e5c0ae2e6cd411d2c9d403f08f2b55efa96a6d1b","modified":1651763333700},{"_id":"source/categories/index.md","hash":"e3074428f9a8284f49d8076f702a8c36e7e1b004","modified":1651763333623},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1645540572000},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1645540572000},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1645540572000},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1645540572000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1645540572000},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1645540572000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1645540572000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1645540572000},{"_id":"themes/yilia/layout/categories.ejs","hash":"a034a31c2f28d35bddffa130600a552b7a16dcb3","modified":1650768974000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1645540572000},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1645540572000},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1645540572000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1645540572000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1645540572000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1645540572000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"60dab5d624eec22529ebf8a2798c36f047d50687","modified":1646495188000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"747f4261475ffd0c5f7376f7ac4e2959d1814f42","modified":1651766508441},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1645540572000},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1645540572000},{"_id":"source/img/banner.png","hash":"17bb52e38b8972233ec7026fa46dc6d2f115735c","modified":1651763333630},{"_id":"source/img/ddsnto_step.png","hash":"b9d9752a6d330af56548dc0f29101086a3398b04","modified":1651763333701},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1645540572000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"1801ef448909ea23c0a48e9d63b80d0cfd5534ce","modified":1645540572000},{"_id":"themes/yilia/source-src/js/report.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1650774166000},{"_id":"source/_posts/2021.02/技术路线专家域.md","hash":"eddad611d322aaef40bd169dd95771ad6f78a7c1","modified":1651763333598},{"_id":"source/_posts/2021.02/开篇.md","hash":"164ec9faa759411ea35d1ad685ba62f4a72590c0","modified":1651763333597},{"_id":"source/_posts/2021.02/技术路线中级域.md","hash":"34f74a635305a4eb84013d71892fe86d8f6c6196","modified":1651763333598},{"_id":"source/_posts/2021.02/技术路线高级域.md","hash":"e35a54099d833bd1e22d764ff632644823b7ee6e","modified":1651763333599},{"_id":"source/_posts/2021.02/管理-技术路线.md","hash":"68bd7ef5b8e97a21565ac3d44425795c2a8f2c6b","modified":1651763333599},{"_id":"source/_posts/2021.02/软件测试攻城狮的成长之路.md","hash":"dcc5f366ab002f88f74fc7a99037677e4bde40b4","modified":1651763333599},{"_id":"source/_posts/2021.11/常用ADB命令及其用法大全.md","hash":"f5bc03a69853ef1f499304ef41865d1ed04df278","modified":1651763333600},{"_id":"source/_posts/2021.12/【DDSNTO教程】-利用软路由插件DDNSTO实现内网穿透.md","hash":"52e75905c2eec2f1f69212cea9571c251ea18fae","modified":1651763333601},{"_id":"source/_posts/2021.12/【工具分享】DDNSTO 简单、快速的内网穿透工具.md","hash":"3ae912ee46748c8baa8d44a72562e0ab5d19bba8","modified":1651763333601},{"_id":"source/_posts/2021.12/【博客搭建】HEXO踩坑指南.md","hash":"ca43714e079b8ed77c1173ae42ebafa202eebb9d","modified":1651763333601},{"_id":"source/_posts/2021.12/【测试工具】Android Input命令.md","hash":"26edccabb9cccd3d67397031840e5a753cd75df3","modified":1651763333602},{"_id":"source/_posts/2021.12/【测试工具】是时候扔掉 Postman 了，Apifox 真香！.md","hash":"a78d310504c4cec6ace3ddf53277aca76b781c3b","modified":1651763333602},{"_id":"source/_posts/2021.12/【测试工具】浅度测评：requests、aiohttp、httpx 我应该用哪一个？.md","hash":"89cfe4549f54f568c74a91c14e2ba0eff1c8416d","modified":1651763333603},{"_id":"source/_posts/2021.12/【测试理论】什么是Topic.md","hash":"85437d5e557facb02f432ad75affa749ad41a01d","modified":1651763333603},{"_id":"source/_posts/2021.12/【测试理论】做自动化遇到的测试环境差异问题.md","hash":"7d54a5d0c0adf64dc358853af612c106f659df36","modified":1651763333603},{"_id":"source/_posts/2021.12/【自动化库】异步http接口调用库：httpx.md","hash":"76a78b2424ac6b01b8d135d339322e078b95311a","modified":1651763333604},{"_id":"source/_posts/2021.12/【自动化测试】WEB自动化测试环境搭建.md","hash":"cd983342adc9422c77b0aefdb9388423a57aa44e","modified":1651763333604},{"_id":"source/_posts/2021.12/【自动化测试】python自动化测试环境搭建.md","hash":"beb807216479652b2c9fb952ad6ea8e92bed7687","modified":1651763333605},{"_id":"source/_posts/Appium/App自动化测试（一）之环境搭建.md","hash":"684f8ae8a631326880c64a4cefc6c8f7a32802a2","modified":1651763333606},{"_id":"source/_posts/Charles/【测试工具】Charles破解.md","hash":"1bf793320d3620b58328b5142ef3afe40975ddf6","modified":1651763333606},{"_id":"source/_posts/Hexo/Hexo博客备份—妈妈再也不用担心你使用hexo写博客.md","hash":"5ab272b540ff843ca51e717e9832e4e288a7594a","modified":1651763333607},{"_id":"source/_posts/Hexo/博客美化——Silence主题皮肤.md","hash":"d4baded3dd400e3d54fd05059aed0f230791afcd","modified":1651763333607},{"_id":"source/_posts/Mysql/超实用的SQL语句之嵌套查询.md","hash":"ce0144b718837d1833995b18bdb71e9d08873cf8","modified":1651763333609},{"_id":"source/_posts/Java/jdk安装和配置环境变量.md","hash":"3c7d0471ccaf9023afe8dbe9667a9df2662ab565","modified":1651763333608},{"_id":"source/_posts/Postman/〖postman〗接口测试01-基本介绍与安装.md","hash":"027fa3409d2c48f4370d4e5c45698e2e7326c588","modified":1651763333609},{"_id":"source/_posts/Postman/〖postman〗接口测试02-发送第一个请求.md","hash":"3ae441b85dda082b171ee465a11b781ffd6ecf65","modified":1651763333610},{"_id":"source/_posts/Postman/〖postman〗接口测试04-常见类型接口请求.md","hash":"4f201ac15fbf780dcf163dd08f7830951cd5acbd","modified":1651763333611},{"_id":"source/_posts/Postman/〖postman〗接口测试03-常见类型接口请求.md","hash":"42785d789e7c45da9aa4dcd98a4e70cf30a91cfc","modified":1651763333610},{"_id":"source/_posts/Postman/〖postman〗接口测试05-响应数据解析.md","hash":"317530dbda7bec90f98b99b389964ccc2d0627e5","modified":1651763333611},{"_id":"source/_posts/Postman/〖postman〗接口测试06-用例管理（Collection）.md","hash":"bc247959ce61198b9cd5cab8b1bfc1b0cff36766","modified":1651763333611},{"_id":"source/_posts/Postman/〖postman〗接口测试07-批量执行用例.md","hash":"f06a5e098eb5fd107e118c3b9243c0d5dd639dc9","modified":1651763333612},{"_id":"source/_posts/Postman/〖postman〗接口测试08-测试断言.md","hash":"862a645afabd184d5e2d8161187cce3cfc4e9402","modified":1651763333612},{"_id":"source/_posts/Postman/〖postman〗接口测试09-日志调试.md","hash":"c3db81694418cacff9bcfaefbbc87287b1eb9ebe","modified":1651763333613},{"_id":"source/_posts/Postman/〖postman〗接口测试10-全局变量-集合变量-环境变量.md","hash":"a0d03256438bd691a57487c88fbca6436e704d64","modified":1651763333613},{"_id":"source/_posts/Postman/〖postman〗接口测试11-接口关联.md","hash":"06736940e1e02a2d1977babfb64b48ac143c807e","modified":1651763333613},{"_id":"source/_posts/Postman/〖postman〗接口测试12-请求前置脚本.md","hash":"149523c42367ac348069abdbfa25aaac5e3088c8","modified":1651763333614},{"_id":"source/_posts/Postman/〖postman〗接口测试13-认证-Authorization.md","hash":"699d061169765d2d2b3efd499feae11486a656d7","modified":1651763333615},{"_id":"source/_posts/Postman/〖postman〗接口测试15-快速查询与替换.md","hash":"7d30e2f6b4ee342f7857ac5ce38e7ca45410213c","modified":1651763333616},{"_id":"source/_posts/Postman/〖postman〗接口测试16-生成测试报告.md","hash":"f9e07097799c6b8af3ca4a233a17e63ae2100db8","modified":1651763333617},{"_id":"source/_posts/Postman/〖postman〗接口测试14-导入导出.md","hash":"ad3f92259592c291e7abf90d4c4b45ebcba82408","modified":1651763333616},{"_id":"source/_posts/Postman/〖postman〗接口测试17-pm对象解析.md","hash":"4963b114dc82a678be97bfb319c2996dc4830e18","modified":1651763333617},{"_id":"source/_posts/Postman/〖postman〗接口测试18-动态变量.md","hash":"9a47f54eeb0e49b86c25dd01e278b3c15c533af3","modified":1651763333617},{"_id":"source/_posts/Postman/〖postman〗接口测试19-Collection-Runner.md","hash":"38f592ca1ae901eb718f6f142da82001f164e401","modified":1651763333618},{"_id":"source/_posts/Postman/〖postman〗接口测试21-读取外部文件进行数据参数化.md","hash":"40663045030de5af48c3a55ac9b9a526a58ba16c","modified":1651763333619},{"_id":"source/_posts/Postman/〖postman〗接口测试20-建立工作流.md","hash":"b064d0eaea1c779363d92a45b3fa5d20db653f42","modified":1651763333618},{"_id":"source/_posts/Python接口自动化测试/01环境搭建-使用Python+request做接口测试.md","hash":"88f575ad8f2f831e656478426610451ceccd5d97","modified":1651763333619},{"_id":"source/_posts/Python接口自动化测试/02 requests初体验，学习get、post怎么发送请求-使用Python+requests做接口测试.md","hash":"abbd45d3ff5e66debe55195760dc5f04d1a48348","modified":1651763333620},{"_id":"source/_posts/Python自动化/Python基础篇02-list和tuple常用操作.md","hash":"eef26f355ef8bf72d46d905f3e62b4d5bd2d0a58","modified":1651763333620},{"_id":"source/_posts/Python自动化/学习笔记-Python之生成器和列表推导式的区别.md","hash":"948328c45dafe1376fd9b506d97bf98b8f8d2983","modified":1651763333621},{"_id":"source/_posts/Shell/【01】Shell特殊位置变量.md","hash":"2c6bd7a783cd241dca519b3b83f158e607f251f2","modified":1651763333622},{"_id":"source/img/environment/1895590-20200229210636360-1610818154.png","hash":"1683ba3d58af27d1bbf9c7425b657911ff2b3b84","modified":1651763333702},{"_id":"source/img/environment/1895590-20200229211014622-396878393.png","hash":"94f02532665c5efdd9d5d4f94deb03b0dab9035e","modified":1651763333707},{"_id":"source/img/environment/1895590-20200229211000223-187798199.png","hash":"780751ba90c128dcbf9729cfa6524286b5928462","modified":1651763333707},{"_id":"source/img/environment/1895590-20200229211032271-1280305583.png","hash":"884a146f3ca0a727870d13606406b17079474785","modified":1651763333708},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"c70f367f54064a441e574c913f5e0ea121d0f899","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"751e5deab5365348be5243688b419c82d337ab9a","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"cb4ade93613911843eb4bf3bd30c8baef0cca314","modified":1646495108000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"155327c23607f69989b58845f24d842a54e504b8","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"c4a1338d2c791b04a69b99547e5486c23f1cfb89","modified":1651766599677},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"fb1b8457b9eb15b55da1bf7b133e12c375dd26f8","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1645540572000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1645540572000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1645540572000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1645540572000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1645540572000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1645540572000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1645540572000},{"_id":"themes/yilia/source/img/avatar.png","hash":"d04ac8014ea550aa905ce7cead87d3595ce88d1c","modified":1645536322000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1645540572000},{"_id":"themes/yilia/source/img/favicon.png","hash":"d04ac8014ea550aa905ce7cead87d3595ce88d1c","modified":1645536322000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1645540572000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1645540572000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1645540572000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1645540572000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1645540572000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1645540572000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1645540572000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1645540572000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1645540572000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"07244c188f58ecfb90bb7c047b8cde977f1dc4b4","modified":1645540572000},{"_id":"themes/yilia/source-src/css/category.scss","hash":"4988f89ef6580cd74ebc97d22a6ea1f082000858","modified":1650768822000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"b85f344f2c66d43d7094746e0a9ccb21d0534201","modified":1645540572000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"96d7eb1d42c06fdcccb8ef969f6ecd30c3194903","modified":1645540572000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1645540572000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1645540572000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1645540572000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1645540572000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1645540572000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"0e4ea61c15285dc0afcd4e97f44af8434d0cf421","modified":1650768768000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1645540572000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"d995dcd483a250fe61b426158afb61bf8923a927","modified":1645540572000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1645540572000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1645540572000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1645540572000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1645540572000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"a10a038a1dac8953cb4ffc7e04272eff9fac54e4","modified":1645540572000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1645540572000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1645540572000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"2924fb6f77c4a9973cd928c2c7db0acb848ed483","modified":1645540572000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1645540572000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1645540572000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"5e4c3c3d61f1e1ce2f09688d3aff25fadc851fff","modified":1645540572000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1645540572000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1645540572000},{"_id":"themes/yilia/source-src/js/main.js","hash":"fe98bf90ce61658fe16ae057f8b6a512a845af3b","modified":1645540572000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"67b8819abb886c9d066fb3b0624ca15e06f63fe0","modified":1645540572000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1645540572000},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1645540572000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"0beaa112657ad57c723d9e773d5b79de60c1dd74","modified":1651766145733},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1645540572000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"c699cf3c89409ec8f044258e0715a470861b5d5d","modified":1645540572000},{"_id":"source/img/1EE1E433-AB1C-436F-95B0-EFDA18C2BE82.png","hash":"a60b2e427446c3aacb3e4e6cc911f71ef73087ad","modified":1651763333626},{"_id":"source/img/NFC/OpenWrt_Wifi.jpg","hash":"701bc20bf8b4a5558a4d0e6fe96c8f011d2abed9","modified":1652064541932},{"_id":"source/img/NFC/WeChat.jpg","hash":"b49de22216c8013b53a7fe373d663dd92dc373bb","modified":1652017640139},{"_id":"source/img/environment/1895590-20200229210909009-805568491.png","hash":"110bcb1ba83388f34262b3eadf4e5e2998da2fac","modified":1651763333706},{"_id":"source/img/environment/1895590-20200229210835166-2050290710.png","hash":"24ee9541bb367b25624d0d0a4cca2d4aa79cbbb6","modified":1651763333705},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"e98ec0b3b56f14d1d79af99ceb42727719a584f3","modified":1645540572000},{"_id":"source/img/blog/Python接口自动化测试/1651595166002.png","hash":"c6c9bcbcf5b2cacf4111de3265734e83c3e3bd72","modified":1651763333631},{"_id":"source/img/blog/Python接口自动化测试/1651595044388.png","hash":"a6a49b223eb6240dee798174b0ba722aef4fbe42","modified":1651763333631},{"_id":"source/img/blog/Python接口自动化测试/1651732273876.png","hash":"bc4d68c72434ae2fea1ce4abc055e869ba272321","modified":1651763333631},{"_id":"source/img/environment/1895590-20200229210702614-864284209.png","hash":"29d35fdb746ad4bccf4b3b8960d78006231f5107","modified":1651763333703},{"_id":"source/img/environment/1895590-20200229210742813-1698355068.png","hash":"287f14f0c31d8abe98cc8193bf98e84eaee7e590","modified":1651763333704},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"e777cbf959b11c4dfda649c562799899b90ab4a3","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"086c8a88fd3bcae7ec13258df58e25d6354af2fa","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/post/declare.ejs","hash":"070049f04ca36b9f2b31e7809e05ebb230372f0b","modified":1646495726000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"25655016773aa5d0774c56115ae1736a9fc9ea1f","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"345b262e3c3b75c0cd9a93d9ecabcf06e33e54ff","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1645540572000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"fb022502c741b4a26bad6b2ad37245c10ede3f1a","modified":1645540572000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1645540572000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1645540572000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1645540572000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1645540572000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1645540572000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1645540572000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1645540572000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1645540572000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1645540572000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1645540572000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1645540572000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1645540572000},{"_id":"source/img/8B2FEFE6-9051-432B-BAED-7B76EFA85FE1.png","hash":"5549af2880d6cc4e6f07d89776c25fdccc296345","modified":1651763333628},{"_id":"source/img/blog/postman/05/05-02.png","hash":"cc40012450bd5ba16ce6d28d136fc4b4cf3557d8","modified":1651763333643},{"_id":"source/img/blog/postman/06/06-01.png","hash":"fbc3b4cf41add1c1f3fbe82c4fe8b6bb9ffc20eb","modified":1651763333644},{"_id":"source/img/blog/postman/06/06-02.png","hash":"4bb9b45a2cc2082c2220c310c824090d0eecdc99","modified":1651763333645},{"_id":"source/img/blog/postman/06/06-03.png","hash":"e19e99c2c11cb2a9eb43571705edb3f55e987254","modified":1651763333646},{"_id":"source/img/blog/postman/06/06-04.png","hash":"eafebdecbf04399c538dc66421e9de95068b439d","modified":1651763333646},{"_id":"source/img/blog/postman/10/010-01.png","hash":"16633c6176677fc54db3bf7f91aed8fface46baf","modified":1651763333656},{"_id":"source/img/blog/postman/10/010-02.png","hash":"e8cfc40faafca8c1ca9d797030bdcb162819f8be","modified":1651763333657},{"_id":"source/img/blog/postman/10/010-04.png","hash":"d892c4a3078de9e4f70483547b91fabd62fc0722","modified":1651763333659},{"_id":"source/img/blog/postman/10/010-05.png","hash":"256dea122250514a68cc9489d7f24eca78662c15","modified":1651763333659},{"_id":"source/img/blog/postman/10/010-06.png","hash":"45fe6804bd6854403d3dd4b25c3a4332e4d47635","modified":1651763333660},{"_id":"source/img/blog/postman/09/09-01.png","hash":"9f9ad23937efc702140472ddac29f6f85844b2a3","modified":1651763333653},{"_id":"source/img/blog/postman/12/012-01.png","hash":"14ef0ea974c1f85ad60fb804bdb92b4e7fb85fc9","modified":1651763333663},{"_id":"source/img/blog/postman/13/013-01.png","hash":"f723099f158c051979f37d29a47f1e048a29a7e9","modified":1651763333665},{"_id":"source/img/blog/postman/13/013-02.png","hash":"0ee6df1ae4f8dd964de5f9824dafa842a2d7b3f8","modified":1651763333666},{"_id":"source/img/blog/postman/14/014-02.png","hash":"06773569a4676e0acca8d2f5145d4ca36660da13","modified":1651763333671},{"_id":"source/img/blog/postman/14/014-08.png","hash":"7be8fb8d50ffb00fcaeaec2b59060d6185395753","modified":1651763333678},{"_id":"source/img/blog/postman/14/014-10.png","hash":"7af3458a8c7414b60484f41bc467fea54c8a3012","modified":1651763333680},{"_id":"source/img/blog/postman/14/014-14.png","hash":"d3dc9244150861fd987ff5bb2931ee71cb6be0d1","modified":1651763333684},{"_id":"source/img/blog/postman/14/014-13.png","hash":"6c35c5cfad3d993c55cd05d2728fe5fb586f9b4e","modified":1651763333684},{"_id":"source/img/blog/postman/16/016-01.png","hash":"86a3e7bb125f4e49d0f13c373662de741e6dbf8f","modified":1651763333689},{"_id":"source/img/blog/postman/15/015-02.png","hash":"10ddf794f417770e8d670001546018dd5f0ef86d","modified":1651763333686},{"_id":"source/img/blog/postman/19/019-01.png","hash":"d84e82a1c2c97d43323719351c7c98a993b18d8d","modified":1651763333691},{"_id":"source/img/blog/postman/20/020-01.png","hash":"27cc72338079e26466948660f389d44dd57bdd15","modified":1651763333693},{"_id":"source/img/blog/postman/21/021-01.png","hash":"6c4470ce3be2f8e0bbd2bf47d82cb0f152b85335","modified":1651763333696},{"_id":"source/img/blog/postman/21/021-02.png","hash":"a1a2a96e919b6da41f1e4eee6076cfa83775138d","modified":1651763333697},{"_id":"source/img/blog/postman/21/021-03.png","hash":"25db3d5d959d9fa376e1a13a6a3107b0f53b6f3d","modified":1651763333697},{"_id":"source/img/blog/postman/21/021-04.png","hash":"b208bf0f5dd9d28e5d5010aed8be0615937eb270","modified":1651763333698},{"_id":"source/img/blog/postman/21/021-05.png","hash":"127ee380802d24fecc6616a65652440764a43aff","modified":1651763333699},{"_id":"source/img/blog/postman/02/02-02.png","hash":"06a287b507505ddd260b76768dadd5547de7fa4e","modified":1651763333636},{"_id":"source/img/blog/postman/05/05-01.png","hash":"fa79a691b21d9558e1ccf896fb52d580d442f216","modified":1651763333642},{"_id":"source/img/blog/postman/05/05-03.png","hash":"e2f7faa049e54a864351365bd7fa34d2d200dd06","modified":1651763333644},{"_id":"source/img/blog/postman/03/03-01.png","hash":"89144a5f56e3d23cafdbf164491fac11ee58bd3b","modified":1651763333637},{"_id":"source/img/blog/postman/03/03-02.png","hash":"85059a58a66931eb7d901b27d2b009cfd22873f0","modified":1651763333638},{"_id":"source/img/blog/postman/04/04-01.png","hash":"0341508bb068838dc4d583d63ba985898269341f","modified":1651763333639},{"_id":"source/img/blog/postman/04/04-02.png","hash":"106463c9147bb6b3907f46efad83543681329aee","modified":1651763333640},{"_id":"source/img/blog/postman/04/04-03.png","hash":"6e5894989f35dac56e1a9fe7b622555188979781","modified":1651763333641},{"_id":"source/img/blog/postman/07/07-01.png","hash":"53151a2bc7d244d16a6ed9a873a7393e5f79c9d1","modified":1651763333647},{"_id":"source/img/blog/postman/07/07-02.png","hash":"dec6c107866170594d602a5a46fa523d7a4e9983","modified":1651763333649},{"_id":"source/img/blog/postman/08/08-01.png","hash":"72d4a37dc6d15671b0b6418db6c0f5021541791e","modified":1651763333651},{"_id":"source/img/blog/postman/08/08-02.png","hash":"c0d809fc5f6d05a85388cc0556dba8068446813f","modified":1651763333652},{"_id":"source/img/blog/postman/10/010-03.png","hash":"e1987bd4fbc78039a8997594c1f4daaf73e920d4","modified":1651763333658},{"_id":"source/img/blog/postman/09/09-02.png","hash":"02feff9cb3511373cfe39148fcd518193716d2c6","modified":1651763333654},{"_id":"source/img/blog/postman/09/09-03.png","hash":"733c3c12558085593a8e82cad861cdb4f64dfc1a","modified":1651763333655},{"_id":"source/img/blog/postman/11/011-01.png","hash":"0965d9b200eb49c289b8069061164d1c4e1a15d2","modified":1651763333661},{"_id":"source/img/blog/postman/11/011-02.png","hash":"2fbe80078c4ff8ccfa7507d9ea03814e821e7963","modified":1651763333662},{"_id":"source/img/blog/postman/12/012-02.png","hash":"d60482f53eca2f7b1133410e227d396629735985","modified":1651763333664},{"_id":"source/img/blog/postman/13/013-03.png","hash":"974803a1df24440f3267658fd5d19a812f1747fc","modified":1651763333667},{"_id":"source/img/blog/postman/13/013-04.png","hash":"53f4d15c6f4faf2c4a123516b63fd0e601f53a48","modified":1651763333668},{"_id":"source/img/blog/postman/13/013-05.png","hash":"fa37dad3d8d104c1284e56c5d8d1d7b16b78f8be","modified":1651763333669},{"_id":"source/img/blog/postman/13/013-06.png","hash":"f56ddb26dfb52d5dc911dca98ac7a93db666b5da","modified":1651763333669},{"_id":"source/img/blog/postman/14/014-01.png","hash":"777620ccdd98610608a4a239af26f93f6c7091f2","modified":1651763333671},{"_id":"source/img/blog/postman/14/014-03.png","hash":"57082e7ed1fd0977ba27e104fc376ef671b844f1","modified":1651763333672},{"_id":"source/img/blog/postman/14/014-04.png","hash":"44d4b6dd6045ebd0dacb3899d6f6def351fed042","modified":1651763333673},{"_id":"source/img/blog/postman/14/014-06.png","hash":"8670dd119a433b1353a3d5da9567c970df8ae94b","modified":1651763333676},{"_id":"source/img/blog/postman/14/014-07.png","hash":"d1bba0a5acc6a83b79ae7133a9166877dc877990","modified":1651763333677},{"_id":"source/img/blog/postman/14/014-09.png","hash":"ae80a47e5cb0760afac88e52a631d37f022d6ecd","modified":1651763333679},{"_id":"source/img/blog/postman/15/015-01.png","hash":"0cb8d42545cb39a4ddbef81265048563a3e279f3","modified":1651763333685},{"_id":"source/img/blog/postman/15/015-03.png","hash":"360e8041e714385dcd7c82483d06772f7748464c","modified":1651763333687},{"_id":"source/img/blog/postman/15/015-04.png","hash":"50cdac09395370ec6000bca1e156f44e37ae3fce","modified":1651763333689},{"_id":"source/img/blog/postman/18/018-01.png","hash":"a517ae45c97272af7c2b56979ec2128c03f3a0a9","modified":1651763333691},{"_id":"source/img/blog/postman/19/019-02.png","hash":"5176043bbe3b6688980657080a04c4be6a8a2866","modified":1651763333692},{"_id":"source/img/blog/postman/20/020-02.png","hash":"59dba2e644bed9bdc732759db66f78ff68bf52e6","modified":1651763333694},{"_id":"source/img/blog/postman/20/020-03.png","hash":"d306b4197ddb28be6ed5eecea62aee63a8902d35","modified":1651763333695},{"_id":"source/img/blog/postman/21/021-06.png","hash":"98253aecb0ddd1fe9e2761c63819b9eead5585c7","modified":1651763333700},{"_id":"source/img/blog/postman/01/01.png","hash":"97624d458a39e758543e8c45fd96b369e565069c","modified":1651763333633},{"_id":"source/img/blog/postman/02/02-01.png","hash":"b19bae001f893a6fbbdc187388bc7d0404698617","modified":1651763333635},{"_id":"source/img/blog/postman/07/07-03.png","hash":"1ead08a6d47fd9fc8bd6f586a85dbb2aa799dc6f","modified":1651763333650},{"_id":"source/img/blog/postman/14/014-05.png","hash":"55251b1e6f084990a7a0562ef28f0657aea13f76","modified":1651763333675},{"_id":"source/img/blog/postman/14/014-11.png","hash":"aee9ec42a05c1360eee548a684e2e7eb50dcfb3d","modified":1651763333682},{"_id":"source/img/blog/postman/14/014-12.png","hash":"5be4527d0a7b5e92f812d62407db3cd2dbf9e741","modified":1651763333683},{"_id":"public/calendar.json","hash":"6f1e87edd31ff55c0b1575fb134a6a2be9e1cec2","modified":1652064561644},{"_id":"public/baidusitemap.xml","hash":"cb3672e649373253ed911d4c17b62da20a51bc4a","modified":1652064561644},{"_id":"public/atom.xml","hash":"2dd596bff19a38267e5752f85d4f8c6d4edeefde","modified":1652064561644},{"_id":"public/content.json","hash":"faaf6f085e2d283e53a30090d1c85d28269576d1","modified":1652064561644},{"_id":"public/search.xml","hash":"07024b60d1ce1bda2e6c742520f194fae928085d","modified":1652064561644},{"_id":"public/sitemap.xml","hash":"0e2bdfc1d14ce474bdee4d63ace28f73cefd6de7","modified":1652064561644},{"_id":"public/tags/index.html","hash":"a5b4d9e64df979b97457097540126b30427491b9","modified":1652064561644},{"_id":"public/about/index.html","hash":"a31c870f86c8ada835e90d62d1ba869559c53172","modified":1652064561644},{"_id":"public/categories/index.html","hash":"97d3aa396e0bccb2738642fcc89815e36fca1186","modified":1652064561644},{"_id":"public/posts/69423a58/index.html","hash":"6a05573bc43e1dd50390947c95270942a9dc8432","modified":1652064561644},{"_id":"public/posts/9d1414ba/index.html","hash":"7104ef4a842096134e4d842e3b179f7ba0e4c4ca","modified":1652064561644},{"_id":"public/posts/f46b70d8/index.html","hash":"01d148b559f33b612f2ea90be12530ed5b64ff16","modified":1652064561644},{"_id":"public/posts/ab3b7c7/index.html","hash":"61d136f55b5071b3fea930fde7ab52216bcd2da5","modified":1652064561644},{"_id":"public/posts/6556c33b/index.html","hash":"02dc3a0dbc0caeeae85acb96279317d5a5d8acd6","modified":1652064561644},{"_id":"public/posts/69ae7450/index.html","hash":"46698bcc656250c15ccb10d32953a976cbed7c5f","modified":1652064561644},{"_id":"public/posts/43b8c324/index.html","hash":"deb7df53d3f02a70da37814b9f8d1baf9a2128e9","modified":1652064561644},{"_id":"public/posts/22131793/index.html","hash":"ca5daff49d36ead6f4bd587e87dcd057d5e1ed8e","modified":1652064561644},{"_id":"public/posts/6172e27e/index.html","hash":"1ffad607aeaa74c39180a94249739fb44cb76c30","modified":1652064561644},{"_id":"public/posts/f5e730b6/index.html","hash":"0a99de38557191d13767237f948e1daff55a494b","modified":1652064561644},{"_id":"public/posts/dcc42dc3/index.html","hash":"b6f9f29d2f804ba0289b4f2f39d4fedf519ddfb6","modified":1652064561644},{"_id":"public/posts/99817e93/index.html","hash":"ef2a8ae3d7a7e230466d0d5076ef1fa08c135560","modified":1652064561644},{"_id":"public/posts/adb093cd/index.html","hash":"fc45589f34261c47aeba071d5e9a5e02017d514b","modified":1652064561644},{"_id":"public/posts/c98d9940/index.html","hash":"4b0acecf3990414464a4e4112938ea0193bfe490","modified":1652064561644},{"_id":"public/posts/30fa304c/index.html","hash":"0868a6f5c06100ec4b597b65834ae78394345737","modified":1652064561644},{"_id":"public/posts/d2331223/index.html","hash":"d8628ef7da323e694393215bcc27a987fb1dd511","modified":1652064561644},{"_id":"public/posts/344e3c5b/index.html","hash":"1193f131a6dcd5408fd478a52068608f45c9638a","modified":1652064561644},{"_id":"public/posts/689fc75c/index.html","hash":"a3fdb7a6a42dba3d1905706e7e3198f971666f60","modified":1652064561644},{"_id":"public/posts/2ab40ef8/index.html","hash":"219641f943578210dad8eced21a6a4191e56c9d7","modified":1652064561644},{"_id":"public/posts/c4b6dbb9/index.html","hash":"00b3dd521ad917a3814d7ffdcb13fed7502478ea","modified":1652064561644},{"_id":"public/posts/b8685e49/index.html","hash":"39bd0e87d23a0e30712d69bb2ad74b466ec24de0","modified":1652064561644},{"_id":"public/posts/3bd3916a/index.html","hash":"667239ea428295d738177bd16a105c91f9a6ecad","modified":1652064561644},{"_id":"public/posts/9656df9f/index.html","hash":"f84577d316635a9612271d43ca49a67320c39a5b","modified":1652064561644},{"_id":"public/posts/a3886b70/index.html","hash":"10b0d35ce058343fe8aa1bba9c83c288698f0c03","modified":1652064561644},{"_id":"public/posts/ea42950b/index.html","hash":"6dbc5a031c34825e7634916e54368a679af6ebd7","modified":1652064561644},{"_id":"public/posts/baaef441/index.html","hash":"36d4f08a56363805cac32aa91ea421f466f1bd67","modified":1652064561644},{"_id":"public/posts/f6c5d65f/index.html","hash":"b39626bb98930fe22656dc79bd7b729d9dba5f64","modified":1652064561644},{"_id":"public/posts/7de15477/index.html","hash":"bcc6dcbfd7e5e89fc44d78240e9ff244d63b5638","modified":1652064561644},{"_id":"public/posts/96032b58/index.html","hash":"e491e2a5dffcd28f303d1c5fede52e5664e1de86","modified":1652064561644},{"_id":"public/posts/2173e2a4/index.html","hash":"200c1541bfe737005a6a83ba465f73699c23b9a0","modified":1652064561644},{"_id":"public/posts/de4de369/index.html","hash":"04be2c80f095f8b2cba3b43d83955f908afca0ea","modified":1652064561644},{"_id":"public/posts/b4b3bf4e/index.html","hash":"de54b86707910a5f87be193275dae8244c50e42c","modified":1652064561644},{"_id":"public/posts/a42e3f6d/index.html","hash":"27970f2f32684bac64bf8b7b463de18b3a0142df","modified":1652064561644},{"_id":"public/posts/undefined/index.html","hash":"1c28c1cfbfbee53d2ecb8bef5f1b76938b091faf","modified":1652064561644},{"_id":"public/posts/3e4105ad/index.html","hash":"232106e8cfb728cf8d67fac91694daa12c581954","modified":1652064561644},{"_id":"public/posts/3457ed69/index.html","hash":"0ea9c0da150b8afbe20393d441082cfd487a9bdb","modified":1652064561644},{"_id":"public/posts/3447554d/index.html","hash":"1be25120a949c4327dd6de33f950aa00d7476c47","modified":1652064561644},{"_id":"public/posts/3447541d/index.html","hash":"a6d235ced6c7f184a4f88e97f31700cca94dd165","modified":1652064561644},{"_id":"public/posts/54eecc7d/index.html","hash":"64607866f3fb17e4090e362877066f1e135e29af","modified":1652064561644},{"_id":"public/posts/be476180/index.html","hash":"3617718c7a40bf8707b412e7682c0eef32ae02c5","modified":1652064561644},{"_id":"public/posts/66841aa6/index.html","hash":"8eb53e36866564a873d9c43d12a06b1d0095228e","modified":1652064561644},{"_id":"public/posts/8a00d2ea/index.html","hash":"9e265f920fbb4fa233e29886ae5c697af8b66a1c","modified":1652064561644},{"_id":"public/posts/d7719dab/index.html","hash":"75b76b06cdc2cc1d4c75a0be140f399deb5a8f94","modified":1652064561644},{"_id":"public/posts/8aa14a73/index.html","hash":"b6b7a18acfd67d5455f0135272854a5af498984d","modified":1652064561644},{"_id":"public/posts/bbd06fa5/index.html","hash":"cff38ef595bd0ddae6c31c722bf6e5b8d789c58d","modified":1652064561644},{"_id":"public/posts/42f034cf/index.html","hash":"58865dda96afaf0f729f5a702139509a09ca2e47","modified":1652064561644},{"_id":"public/posts/d5268b29/index.html","hash":"1929df94539d55c75edcbc69a7a65c468555d9d6","modified":1652064561644},{"_id":"public/posts/a9438874/index.html","hash":"c9b1336788c2b7cd0f433d917e999446c7444c74","modified":1652064561644},{"_id":"public/posts/39cb083c/index.html","hash":"27a8e0b472024b5468e9c275dd94e22f8c56fa43","modified":1652064561644},{"_id":"public/posts/f3908263/index.html","hash":"db6aae6a59551c672891dfce55d708be43e7b836","modified":1652064561644},{"_id":"public/posts/3ba53770/index.html","hash":"4952d92482dbead2b87566b2a6ece426831053f6","modified":1652064561644},{"_id":"public/archives/index.html","hash":"a6077b45aa600fb2a6c81b83736b535f13181a40","modified":1652064561644},{"_id":"public/archives/page/2/index.html","hash":"bfdcb4bd3a36bf14f0dc264d5f6000c275315454","modified":1652064561644},{"_id":"public/archives/page/3/index.html","hash":"7ef5202b0a00491750170fe69afbd8bbaa7fc23b","modified":1652064561644},{"_id":"public/archives/page/4/index.html","hash":"4c557728a7ae9379952578f1d6f9e6cc29332e83","modified":1652064561644},{"_id":"public/archives/page/5/index.html","hash":"cddfa1c13326a699ab970c748fdaa79c817b2fa4","modified":1652064561644},{"_id":"public/archives/page/6/index.html","hash":"80261a7d0c49db9304a9660e7c303dff1be18642","modified":1652064561644},{"_id":"public/archives/2020/index.html","hash":"61f57e04ee5b3eb481ff38379bea1c7c651326f0","modified":1652064561644},{"_id":"public/archives/2020/08/index.html","hash":"691a50e7f8f502c8aa6b24ea534c23fa774e9e97","modified":1652064561644},{"_id":"public/archives/2021/index.html","hash":"b283880a90066eb8b6f09abcf15df1c90c17b3ac","modified":1652064561644},{"_id":"public/archives/2021/page/2/index.html","hash":"1a0c1a7d68248fc80f310fe7284b75301e21d6fb","modified":1652064561644},{"_id":"public/archives/2021/page/3/index.html","hash":"01f0c814d968a35d7c77fd2df3371ca03e5582ee","modified":1652064561644},{"_id":"public/archives/2021/02/index.html","hash":"9be3bb9d6c3a8445cb434c9c883e52a8b7cc7d21","modified":1652064561644},{"_id":"public/archives/2021/03/index.html","hash":"61edbe656847196c506fc2e91ea7395413dd8c11","modified":1652064561644},{"_id":"public/archives/2021/05/index.html","hash":"50978cb465d818424c31d83bacede23d4a78b08b","modified":1652064561644},{"_id":"public/archives/2021/11/index.html","hash":"b1d69f61a4fd2f15f81a1794e0408d5a03466c44","modified":1652064561644},{"_id":"public/archives/2021/12/index.html","hash":"ae213db36ed7d664c64055807b95d35578a5de19","modified":1652064561644},{"_id":"public/archives/2021/12/page/2/index.html","hash":"e924777f6297581d24cfa487e2f90cfabd70448a","modified":1652064561644},{"_id":"public/archives/2022/index.html","hash":"fa6473fe6b8818d2cd1c3727d2bd2fbbb152c3f7","modified":1652064561644},{"_id":"public/archives/2022/page/2/index.html","hash":"1afb2ecc9e6e4df5887e454eb7649710a37ec730","modified":1652064561644},{"_id":"public/archives/2022/page/3/index.html","hash":"3e754a393b239e6baaa7f8226b14f4c8edce29cd","modified":1652064561644},{"_id":"public/archives/2022/01/index.html","hash":"1d9503c4c4e5b349cc32d0e6a7556b232e821370","modified":1652064561644},{"_id":"public/archives/2022/01/page/2/index.html","hash":"e737e227861112d18cde36ecbcf5f07b6576698c","modified":1652064561644},{"_id":"public/archives/2022/02/index.html","hash":"7c38d282970373225c3c0ae932508a04f75d8fe6","modified":1652064561644},{"_id":"public/archives/2022/02/page/2/index.html","hash":"be4d4f041cb375b57f8f7433fcd7bae98075bc43","modified":1652064561644},{"_id":"public/archives/2022/05/index.html","hash":"f1f26410697d0e0d64d945ba289e9cbd0c60c228","modified":1652064561644},{"_id":"public/categories/技术积累/index.html","hash":"db1dd1164aff70378605cbf82a29a4964a1eb3ed","modified":1652064561644},{"_id":"public/categories/Appium/index.html","hash":"0f8be38667320803c14c59a4e748cc292a88a6f1","modified":1652064561644},{"_id":"public/categories/Charles/index.html","hash":"7db82e70abc4157373a8af750d0facfad1b4844c","modified":1652064561644},{"_id":"public/categories/Hexo/index.html","hash":"8f391de781ce0c574d96bfe117ba947404ed3853","modified":1652064561644},{"_id":"public/categories/MySQL/index.html","hash":"f1c387ef896d9465b19aa2c92aa4b9e2c825d518","modified":1652064561644},{"_id":"public/categories/postman/index.html","hash":"bcab37cbbb2031a09e32a23ba8c6e20044083f16","modified":1652064561644},{"_id":"public/categories/postman/page/2/index.html","hash":"ea8f62e5a502ba249751480d0172aa57b85a6732","modified":1652064561644},{"_id":"public/categories/postman/page/3/index.html","hash":"b8ff55a959cb09a4a21805582bf05f325df4fc1e","modified":1652064561644},{"_id":"public/categories/Python接口自动化测试/index.html","hash":"b318fe36cdb9f04bd28998df2131511e79f2a765","modified":1652064561644},{"_id":"public/categories/Python自动化/index.html","hash":"f827b10df2401b611ca56315a68fb34233a4c353","modified":1652064561644},{"_id":"public/categories/Shell脚本/index.html","hash":"646194ea54817f17cf852d75206945e9e7b22e46","modified":1652064561644},{"_id":"public/index.html","hash":"e60d0ca73af938c2bf490ab433d6f2fab7a476e5","modified":1652064561644},{"_id":"public/page/2/index.html","hash":"832bf755d35ed6b31f6fc9dd0a9ac0f94293723b","modified":1652064561644},{"_id":"public/page/3/index.html","hash":"fb921d45582978e94fd5c4af8763efbb492a3821","modified":1652064561644},{"_id":"public/page/4/index.html","hash":"927356b1b87965a60c8ac6d0efd22f25c9bff3f4","modified":1652064561644},{"_id":"public/page/5/index.html","hash":"4ee96811d81269a275aaa6cb1d3dad1a4f1d3c70","modified":1652064561644},{"_id":"public/page/6/index.html","hash":"ca4da067e5a6ea565ec7ffec7d03295b6ce69ab4","modified":1652064561644},{"_id":"public/tags/API/index.html","hash":"5c4e3bf49c40da97b22e78c20e84674c102e78f7","modified":1652064561644},{"_id":"public/tags/博客/index.html","hash":"f2e06c1a34d6b89c59ad438619c5dcb2221799d7","modified":1652064561644},{"_id":"public/tags/MQ/index.html","hash":"1e3ea296828886a015f5a048e94f90309a6eaf51","modified":1652064561644},{"_id":"public/tags/自动化测试/index.html","hash":"d43840d5ece68cf5c631afca49a42732a1ab7657","modified":1652064561644},{"_id":"public/tags/Appium/index.html","hash":"948b5591ef3e61f6c8fd1daa7a82228f4ebc8369","modified":1652064561644},{"_id":"public/tags/Charles/index.html","hash":"2b8b58b291b1725c58ad879c45e601bd9be247cb","modified":1652064561644},{"_id":"public/tags/Hexo/index.html","hash":"a87258bad579b80fd9018fad6523526c145ecbbd","modified":1652064561644},{"_id":"public/tags/MySQL/index.html","hash":"42ae884129707f81faebb5fcbb3c91da7e194f57","modified":1652064561644},{"_id":"public/tags/postman/index.html","hash":"302fbd82ca4b3065419e73008b661701f5b4ff48","modified":1652064561644},{"_id":"public/tags/postman/page/2/index.html","hash":"dbd81f84216ebd8e05ae786757bc55f371878043","modified":1652064561644},{"_id":"public/tags/postman/page/3/index.html","hash":"968f42a4a2ea03f3a4fa45b6588eeade669c1ce5","modified":1652064561644},{"_id":"public/tags/Python接口自动化测试/index.html","hash":"3450afad07439be2c2d0546e5ad4c2e06d2a9c7b","modified":1652064561644},{"_id":"public/tags/Python自动化/index.html","hash":"1683a4238ef9ae31c2393c2f46b458d5641fc64e","modified":1652064561644},{"_id":"public/tags/Shell脚本/index.html","hash":"c1d737314b12fe15eafc45a90bbe972a4c6111ed","modified":1652064561644},{"_id":"public/img/1638799083784.png","hash":"58e494cf6b136a040002f9f69c27ecaff6a402b7","modified":1652064561644},{"_id":"public/img/apifoxdemo.jpg","hash":"22c91395c01c2add0399a91cee14c66e2c513ccc","modified":1652064561644},{"_id":"public/img/charles_20220101225450.png","hash":"e5c0ae2e6cd411d2c9d403f08f2b55efa96a6d1b","modified":1652064561644},{"_id":"public/img/environment/1895590-20200229210636360-1610818154.png","hash":"1683ba3d58af27d1bbf9c7425b657911ff2b3b84","modified":1652064561644},{"_id":"public/img/environment/1895590-20200229211000223-187798199.png","hash":"780751ba90c128dcbf9729cfa6524286b5928462","modified":1652064561644},{"_id":"public/img/environment/1895590-20200229211014622-396878393.png","hash":"94f02532665c5efdd9d5d4f94deb03b0dab9035e","modified":1652064561644},{"_id":"public/img/environment/1895590-20200229211032271-1280305583.png","hash":"884a146f3ca0a727870d13606406b17079474785","modified":1652064561644},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1652064561644},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1652064561644},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"75767c904d483d9b93469afb6b92bb6bdface639","modified":1652064561644},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1652064561644},{"_id":"public/img/avatar.png","hash":"d04ac8014ea550aa905ce7cead87d3595ce88d1c","modified":1652064561644},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1652064561644},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1652064561644},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1652064561644},{"_id":"public/img/favicon.png","hash":"d04ac8014ea550aa905ce7cead87d3595ce88d1c","modified":1652064561644},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1652064561644},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1652064561644},{"_id":"public/img/blog/Python接口自动化测试/1651595044388.png","hash":"a6a49b223eb6240dee798174b0ba722aef4fbe42","modified":1652064561644},{"_id":"public/img/blog/Python接口自动化测试/1651595166002.png","hash":"c6c9bcbcf5b2cacf4111de3265734e83c3e3bd72","modified":1652064561644},{"_id":"public/img/blog/Python接口自动化测试/1651732273876.png","hash":"bc4d68c72434ae2fea1ce4abc055e869ba272321","modified":1652064561644},{"_id":"public/img/blog/postman/05/05-02.png","hash":"cc40012450bd5ba16ce6d28d136fc4b4cf3557d8","modified":1652064561644},{"_id":"public/img/blog/postman/06/06-02.png","hash":"4bb9b45a2cc2082c2220c310c824090d0eecdc99","modified":1652064561644},{"_id":"public/img/blog/postman/06/06-01.png","hash":"fbc3b4cf41add1c1f3fbe82c4fe8b6bb9ffc20eb","modified":1652064561644},{"_id":"public/img/blog/postman/06/06-04.png","hash":"eafebdecbf04399c538dc66421e9de95068b439d","modified":1652064561644},{"_id":"public/img/blog/postman/06/06-03.png","hash":"e19e99c2c11cb2a9eb43571705edb3f55e987254","modified":1652064561644},{"_id":"public/img/blog/postman/10/010-01.png","hash":"16633c6176677fc54db3bf7f91aed8fface46baf","modified":1652064561644},{"_id":"public/img/blog/postman/10/010-02.png","hash":"e8cfc40faafca8c1ca9d797030bdcb162819f8be","modified":1652064561644},{"_id":"public/img/blog/postman/10/010-04.png","hash":"d892c4a3078de9e4f70483547b91fabd62fc0722","modified":1652064561644},{"_id":"public/img/blog/postman/10/010-05.png","hash":"256dea122250514a68cc9489d7f24eca78662c15","modified":1652064561644},{"_id":"public/img/blog/postman/10/010-06.png","hash":"45fe6804bd6854403d3dd4b25c3a4332e4d47635","modified":1652064561644},{"_id":"public/img/blog/postman/12/012-01.png","hash":"14ef0ea974c1f85ad60fb804bdb92b4e7fb85fc9","modified":1652064561644},{"_id":"public/img/blog/postman/09/09-01.png","hash":"9f9ad23937efc702140472ddac29f6f85844b2a3","modified":1652064561644},{"_id":"public/img/blog/postman/13/013-02.png","hash":"0ee6df1ae4f8dd964de5f9824dafa842a2d7b3f8","modified":1652064561644},{"_id":"public/img/blog/postman/13/013-01.png","hash":"f723099f158c051979f37d29a47f1e048a29a7e9","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-02.png","hash":"06773569a4676e0acca8d2f5145d4ca36660da13","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-10.png","hash":"7af3458a8c7414b60484f41bc467fea54c8a3012","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-08.png","hash":"7be8fb8d50ffb00fcaeaec2b59060d6185395753","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-13.png","hash":"6c35c5cfad3d993c55cd05d2728fe5fb586f9b4e","modified":1652064561644},{"_id":"public/img/blog/postman/16/016-01.png","hash":"86a3e7bb125f4e49d0f13c373662de741e6dbf8f","modified":1652064561644},{"_id":"public/img/blog/postman/19/019-01.png","hash":"d84e82a1c2c97d43323719351c7c98a993b18d8d","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-14.png","hash":"d3dc9244150861fd987ff5bb2931ee71cb6be0d1","modified":1652064561644},{"_id":"public/img/blog/postman/15/015-02.png","hash":"10ddf794f417770e8d670001546018dd5f0ef86d","modified":1652064561644},{"_id":"public/img/blog/postman/20/020-01.png","hash":"27cc72338079e26466948660f389d44dd57bdd15","modified":1652064561644},{"_id":"public/img/blog/postman/21/021-01.png","hash":"6c4470ce3be2f8e0bbd2bf47d82cb0f152b85335","modified":1652064561644},{"_id":"public/img/blog/postman/21/021-02.png","hash":"a1a2a96e919b6da41f1e4eee6076cfa83775138d","modified":1652064561644},{"_id":"public/img/blog/postman/21/021-03.png","hash":"25db3d5d959d9fa376e1a13a6a3107b0f53b6f3d","modified":1652064561644},{"_id":"public/img/blog/postman/21/021-04.png","hash":"b208bf0f5dd9d28e5d5010aed8be0615937eb270","modified":1652064561644},{"_id":"public/img/blog/postman/21/021-05.png","hash":"127ee380802d24fecc6616a65652440764a43aff","modified":1652064561644},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1652064561644},{"_id":"public/assets/js/Meting.min.js","hash":"a0585220b918d78649a7893279e1ec4fb5abe835","modified":1652064561644},{"_id":"public/assets/css/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1652064561644},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1652064561644},{"_id":"public/img/banner.png","hash":"17bb52e38b8972233ec7026fa46dc6d2f115735c","modified":1652064561644},{"_id":"public/img/ddsnto_step.png","hash":"b9d9752a6d330af56548dc0f29101086a3398b04","modified":1652064561644},{"_id":"public/img/NFC/OpenWrt_Wifi.jpg","hash":"701bc20bf8b4a5558a4d0e6fe96c8f011d2abed9","modified":1652064561644},{"_id":"public/img/NFC/WeChat.jpg","hash":"b49de22216c8013b53a7fe373d663dd92dc373bb","modified":1652064561644},{"_id":"public/img/environment/1895590-20200229210909009-805568491.png","hash":"110bcb1ba83388f34262b3eadf4e5e2998da2fac","modified":1652064561644},{"_id":"public/img/environment/1895590-20200229210835166-2050290710.png","hash":"24ee9541bb367b25624d0d0a4cca2d4aa79cbbb6","modified":1652064561644},{"_id":"public/img/blog/postman/02/02-02.png","hash":"06a287b507505ddd260b76768dadd5547de7fa4e","modified":1652064561644},{"_id":"public/img/blog/postman/05/05-03.png","hash":"e2f7faa049e54a864351365bd7fa34d2d200dd06","modified":1652064561644},{"_id":"public/img/blog/postman/05/05-01.png","hash":"fa79a691b21d9558e1ccf896fb52d580d442f216","modified":1652064561644},{"_id":"public/img/blog/postman/03/03-02.png","hash":"85059a58a66931eb7d901b27d2b009cfd22873f0","modified":1652064561644},{"_id":"public/img/blog/postman/03/03-01.png","hash":"89144a5f56e3d23cafdbf164491fac11ee58bd3b","modified":1652064561644},{"_id":"public/img/blog/postman/04/04-01.png","hash":"0341508bb068838dc4d583d63ba985898269341f","modified":1652064561644},{"_id":"public/img/blog/postman/04/04-02.png","hash":"106463c9147bb6b3907f46efad83543681329aee","modified":1652064561644},{"_id":"public/img/blog/postman/04/04-03.png","hash":"6e5894989f35dac56e1a9fe7b622555188979781","modified":1652064561644},{"_id":"public/img/blog/postman/07/07-01.png","hash":"53151a2bc7d244d16a6ed9a873a7393e5f79c9d1","modified":1652064561644},{"_id":"public/img/blog/postman/07/07-02.png","hash":"dec6c107866170594d602a5a46fa523d7a4e9983","modified":1652064561644},{"_id":"public/img/blog/postman/08/08-02.png","hash":"c0d809fc5f6d05a85388cc0556dba8068446813f","modified":1652064561644},{"_id":"public/img/blog/postman/08/08-01.png","hash":"72d4a37dc6d15671b0b6418db6c0f5021541791e","modified":1652064561644},{"_id":"public/img/blog/postman/09/09-02.png","hash":"02feff9cb3511373cfe39148fcd518193716d2c6","modified":1652064561644},{"_id":"public/img/blog/postman/10/010-03.png","hash":"e1987bd4fbc78039a8997594c1f4daaf73e920d4","modified":1652064561644},{"_id":"public/img/blog/postman/09/09-03.png","hash":"733c3c12558085593a8e82cad861cdb4f64dfc1a","modified":1652064561644},{"_id":"public/img/blog/postman/11/011-01.png","hash":"0965d9b200eb49c289b8069061164d1c4e1a15d2","modified":1652064561644},{"_id":"public/img/blog/postman/11/011-02.png","hash":"2fbe80078c4ff8ccfa7507d9ea03814e821e7963","modified":1652064561644},{"_id":"public/img/blog/postman/12/012-02.png","hash":"d60482f53eca2f7b1133410e227d396629735985","modified":1652064561644},{"_id":"public/img/blog/postman/13/013-05.png","hash":"fa37dad3d8d104c1284e56c5d8d1d7b16b78f8be","modified":1652064561644},{"_id":"public/img/blog/postman/13/013-04.png","hash":"53f4d15c6f4faf2c4a123516b63fd0e601f53a48","modified":1652064561644},{"_id":"public/img/blog/postman/13/013-03.png","hash":"974803a1df24440f3267658fd5d19a812f1747fc","modified":1652064561644},{"_id":"public/img/blog/postman/13/013-06.png","hash":"f56ddb26dfb52d5dc911dca98ac7a93db666b5da","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-01.png","hash":"777620ccdd98610608a4a239af26f93f6c7091f2","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-03.png","hash":"57082e7ed1fd0977ba27e104fc376ef671b844f1","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-04.png","hash":"44d4b6dd6045ebd0dacb3899d6f6def351fed042","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-06.png","hash":"8670dd119a433b1353a3d5da9567c970df8ae94b","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-07.png","hash":"d1bba0a5acc6a83b79ae7133a9166877dc877990","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-09.png","hash":"ae80a47e5cb0760afac88e52a631d37f022d6ecd","modified":1652064561644},{"_id":"public/img/blog/postman/15/015-01.png","hash":"0cb8d42545cb39a4ddbef81265048563a3e279f3","modified":1652064561644},{"_id":"public/img/blog/postman/15/015-03.png","hash":"360e8041e714385dcd7c82483d06772f7748464c","modified":1652064561644},{"_id":"public/img/blog/postman/15/015-04.png","hash":"50cdac09395370ec6000bca1e156f44e37ae3fce","modified":1652064561644},{"_id":"public/img/blog/postman/18/018-01.png","hash":"a517ae45c97272af7c2b56979ec2128c03f3a0a9","modified":1652064561644},{"_id":"public/img/blog/postman/19/019-02.png","hash":"5176043bbe3b6688980657080a04c4be6a8a2866","modified":1652064561644},{"_id":"public/img/blog/postman/20/020-02.png","hash":"59dba2e644bed9bdc732759db66f78ff68bf52e6","modified":1652064561644},{"_id":"public/img/blog/postman/20/020-03.png","hash":"d306b4197ddb28be6ed5eecea62aee63a8902d35","modified":1652064561644},{"_id":"public/img/blog/postman/21/021-06.png","hash":"98253aecb0ddd1fe9e2761c63819b9eead5585c7","modified":1652064561644},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1652064561644},{"_id":"public/main.0cf68a.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1652064561644},{"_id":"public/slider.e37972.js","hash":"bdd99517c19ec1d054a4ddc4f985e5c4fa5e0913","modified":1652064561644},{"_id":"public/main.0cf68a.css","hash":"60dab5d624eec22529ebf8a2798c36f047d50687","modified":1652064561644},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1652064561644},{"_id":"public/img/environment/1895590-20200229210702614-864284209.png","hash":"29d35fdb746ad4bccf4b3b8960d78006231f5107","modified":1652064561644},{"_id":"public/img/environment/1895590-20200229210742813-1698355068.png","hash":"287f14f0c31d8abe98cc8193bf98e84eaee7e590","modified":1652064561644},{"_id":"public/img/blog/postman/01/01.png","hash":"97624d458a39e758543e8c45fd96b369e565069c","modified":1652064561644},{"_id":"public/img/blog/postman/02/02-01.png","hash":"b19bae001f893a6fbbdc187388bc7d0404698617","modified":1652064561644},{"_id":"public/img/blog/postman/07/07-03.png","hash":"1ead08a6d47fd9fc8bd6f586a85dbb2aa799dc6f","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-11.png","hash":"aee9ec42a05c1360eee548a684e2e7eb50dcfb3d","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-05.png","hash":"55251b1e6f084990a7a0562ef28f0657aea13f76","modified":1652064561644},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1652064561644},{"_id":"public/img/blog/postman/14/014-12.png","hash":"5be4527d0a7b5e92f812d62407db3cd2dbf9e741","modified":1652064561644},{"_id":"public/img/1EE1E433-AB1C-436F-95B0-EFDA18C2BE82.png","hash":"a60b2e427446c3aacb3e4e6cc911f71ef73087ad","modified":1652064561644},{"_id":"public/img/8B2FEFE6-9051-432B-BAED-7B76EFA85FE1.png","hash":"5549af2880d6cc4e6f07d89776c25fdccc296345","modified":1652064561644},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1652064561644}],"Category":[{"name":"技术积累","_id":"cl2y4l3v10004n4ep182sgcnb"},{"name":"Appium","_id":"cl2y4l3wv0018n4ep8yq8674x"},{"name":"Charles","_id":"cl2y4l3x0001dn4ep2wgv8njp"},{"name":"Hexo","_id":"cl2y4l3x2001jn4ep083zh10n"},{"name":"MySQL","_id":"cl2y4l3x7001un4ep8cypdwjr"},{"name":"postman","_id":"cl2y4l3xa0021n4ep4joz2ips"},{"name":"Python接口自动化测试","_id":"cl2y4l3xs003rn4ephck22ud5"},{"name":"Python自动化","_id":"cl2y4l3xv0045n4epcw9oft97"},{"name":"Shell脚本","_id":"cl2y4l3xw004bn4ep4xk7f9ff"}],"Data":[],"Page":[{"_content":"","source":"tags/index.md","raw":"","date":"2022-05-05T15:08:53.708Z","updated":"2022-05-05T15:08:53.708Z","path":"tags/index.html","title":"","comments":1,"layout":"page","_id":"cl2y4l3uf0000n4epb12q0mfh","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我的","date":"2020-07-25T12:34:27.000Z","_content":"\n## 关于博主\n\n### \n    1、系统学习过Python&Java自动化，包含UI自动话&接口自动化\n    2、主要负责后端测试，参与代码CR评审。\n    3、负责接口测试+端上H5测试+小程序测试+工作台测试wb+设计&维护接口自动化代码\n```\n常用的DB，熟悉常见命令\nmysql、redis \n```\n\n```\n常用抓包工具\ncharles\n```\n\n```\n常用的接口测试工具：\nPostman、jmeter\n```","source":"about/index.md","raw":"---\ntitle: 关于我的\ndate: 2020-07-25 20:34:27\n---\n\n## 关于博主\n\n### \n    1、系统学习过Python&Java自动化，包含UI自动话&接口自动化\n    2、主要负责后端测试，参与代码CR评审。\n    3、负责接口测试+端上H5测试+小程序测试+工作台测试wb+设计&维护接口自动化代码\n```\n常用的DB，熟悉常见命令\nmysql、redis \n```\n\n```\n常用抓包工具\ncharles\n```\n\n```\n常用的接口测试工具：\nPostman、jmeter\n```","updated":"2020-07-25T12:34:27.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl2y4l3uz0002n4epc02va3mm","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"关于博主\"><a href=\"#关于博主\" class=\"headerlink\" title=\"关于博主\"></a>关于博主</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><pre><code>1、系统学习过Python&amp;Java自动化，包含UI自动话&amp;接口自动化\n2、主要负责后端测试，参与代码CR评审。\n3、负责接口测试+端上H5测试+小程序测试+工作台测试wb+设计&amp;维护接口自动化代码</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常用的DB，熟悉常见命令</span><br><span class=\"line\">mysql、redis</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常用抓包工具</span><br><span class=\"line\">charles</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常用的接口测试工具：</span><br><span class=\"line\">Postman、jmeter</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关于博主\"><a href=\"#关于博主\" class=\"headerlink\" title=\"关于博主\"></a>关于博主</h2><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><pre><code>1、系统学习过Python&amp;Java自动化，包含UI自动话&amp;接口自动化\n2、主要负责后端测试，参与代码CR评审。\n3、负责接口测试+端上H5测试+小程序测试+工作台测试wb+设计&amp;维护接口自动化代码</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常用的DB，熟悉常见命令</span><br><span class=\"line\">mysql、redis</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常用抓包工具</span><br><span class=\"line\">charles</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常用的接口测试工具：</span><br><span class=\"line\">Postman、jmeter</span><br></pre></td></tr></table></figure>"},{"title":"文章分类","date":"2018-06-11T02:13:21.000Z","type":"categories","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2018-06-11 10:13:21\ntype: \"categories\"\nlayout: \"categories\"\ncomments: false\n---","updated":"2018-06-11T02:13:21.000Z","path":"categories/index.html","_id":"cl2y4l3v10003n4eph4mm4pww","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"【公开api接口】字符串加密/解密API接口","abbrlink":"689fc75c","date":"2022-01-13T15:48:20.000Z","toc":true,"_content":"> 一个公开的加解密接口记录学习<!-- more -->\n\n - 接口地址：https://api.vvhan.com/api/jm\n - 返回格式： JSON\n - 请求方式：GET\n\n#### 请求示例(加密)：\n\n> https://api.vvhan.com/api/jm?key=自定义密码&string=需要加密的内容&type=en\n\n#### 请求示例(解密)：\n\n> https://api.vvhan.com/api/jm?key=自定义密码&string=需要解密的内容&type=de\n\n#### 参数说明\n\n| 名称   | 必填 | 类型   | 说明                        |\n| :----- | :--- | :----- | :-------------------------- |\n| key    | 否   | string | 自定义密匙                  |\n| string | 是   | string | 加/解密内容                 |\n| type   | 否   | string | en表示加密,de表示解密(默认) |\n\n#### 返回数据\n\n```\n加密：{\"enmissString\":\"InFYZ0VPKzVzTkdxUWlxV1VXVnA5cmtCenRxYkNTY3JUeVwvVWtxTm16VHNjPSI=\"}\n解密：{\"demissString\":小韩网络}\n```\n\n\n## 示例代码\n\n```\n<?phpheader('Content-type:text/json;charset=utf-8;');\n$key=$_GET['key'];\n$string=$_GET['string'];\n$type=$_GET['type'];\n$result = file_get_contents('https://api.vvhan.com/api/jm?key='.$key.'&string='.$string.'&type='.$type);\necho $result;?>\n```","source":"_posts/【公开api接口】字符串加密-解密API接口.md","raw":"---\ntitle: 【公开api接口】字符串加密/解密API接口\nabbrlink: 689fc75c\ndate: 2022-01-13 23:48:20\ntags: API\ncategories: [技术积累]\ntoc: true\n---\n> 一个公开的加解密接口记录学习<!-- more -->\n\n - 接口地址：https://api.vvhan.com/api/jm\n - 返回格式： JSON\n - 请求方式：GET\n\n#### 请求示例(加密)：\n\n> https://api.vvhan.com/api/jm?key=自定义密码&string=需要加密的内容&type=en\n\n#### 请求示例(解密)：\n\n> https://api.vvhan.com/api/jm?key=自定义密码&string=需要解密的内容&type=de\n\n#### 参数说明\n\n| 名称   | 必填 | 类型   | 说明                        |\n| :----- | :--- | :----- | :-------------------------- |\n| key    | 否   | string | 自定义密匙                  |\n| string | 是   | string | 加/解密内容                 |\n| type   | 否   | string | en表示加密,de表示解密(默认) |\n\n#### 返回数据\n\n```\n加密：{\"enmissString\":\"InFYZ0VPKzVzTkdxUWlxV1VXVnA5cmtCenRxYkNTY3JUeVwvVWtxTm16VHNjPSI=\"}\n解密：{\"demissString\":小韩网络}\n```\n\n\n## 示例代码\n\n```\n<?phpheader('Content-type:text/json;charset=utf-8;');\n$key=$_GET['key'];\n$string=$_GET['string'];\n$type=$_GET['type'];\n$result = file_get_contents('https://api.vvhan.com/api/jm?key='.$key.'&string='.$string.'&type='.$type);\necho $result;?>\n```","slug":"【公开api接口】字符串加密-解密API接口","published":1,"updated":"2022-01-13T15:48:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3ux0001n4epc75u32wa","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>一个公开的加解密接口记录学习<a id=\"more\"></a></p>\n</blockquote>\n<ul>\n<li>接口地址：<a href=\"https://api.vvhan.com/api/jm\" target=\"_blank\" rel=\"noopener\">https://api.vvhan.com/api/jm</a></li>\n<li>返回格式： JSON</li>\n<li>请求方式：GET</li>\n</ul>\n<h4 id=\"请求示例-加密-：\"><a href=\"#请求示例-加密-：\" class=\"headerlink\" title=\"请求示例(加密)：\"></a>请求示例(加密)：</h4><blockquote>\n<p><a href=\"https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要加密的内容&amp;type=en\" target=\"_blank\" rel=\"noopener\">https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要加密的内容&amp;type=en</a></p>\n</blockquote>\n<h4 id=\"请求示例-解密-：\"><a href=\"#请求示例-解密-：\" class=\"headerlink\" title=\"请求示例(解密)：\"></a>请求示例(解密)：</h4><blockquote>\n<p><a href=\"https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要解密的内容&amp;type=de\" target=\"_blank\" rel=\"noopener\">https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要解密的内容&amp;type=de</a></p>\n</blockquote>\n<h4 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h4><table>\n<thead>\n<tr>\n<th align=\"left\">名称</th>\n<th align=\"left\">必填</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">key</td>\n<td align=\"left\">否</td>\n<td align=\"left\">string</td>\n<td align=\"left\">自定义密匙</td>\n</tr>\n<tr>\n<td align=\"left\">string</td>\n<td align=\"left\">是</td>\n<td align=\"left\">string</td>\n<td align=\"left\">加/解密内容</td>\n</tr>\n<tr>\n<td align=\"left\">type</td>\n<td align=\"left\">否</td>\n<td align=\"left\">string</td>\n<td align=\"left\">en表示加密,de表示解密(默认)</td>\n</tr>\n</tbody></table>\n<h4 id=\"返回数据\"><a href=\"#返回数据\" class=\"headerlink\" title=\"返回数据\"></a>返回数据</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加密：&#123;&quot;enmissString&quot;:&quot;InFYZ0VPKzVzTkdxUWlxV1VXVnA5cmtCenRxYkNTY3JUeVwvVWtxTm16VHNjPSI&#x3D;&quot;&#125;</span><br><span class=\"line\">解密：&#123;&quot;demissString&quot;:小韩网络&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?phpheader(&#39;Content-type:text&#x2F;json;charset&#x3D;utf-8;&#39;);</span><br><span class=\"line\">$key&#x3D;$_GET[&#39;key&#39;];</span><br><span class=\"line\">$string&#x3D;$_GET[&#39;string&#39;];</span><br><span class=\"line\">$type&#x3D;$_GET[&#39;type&#39;];</span><br><span class=\"line\">$result &#x3D; file_get_contents(&#39;https:&#x2F;&#x2F;api.vvhan.com&#x2F;api&#x2F;jm?key&#x3D;&#39;.$key.&#39;&amp;string&#x3D;&#39;.$string.&#39;&amp;type&#x3D;&#39;.$type);</span><br><span class=\"line\">echo $result;?&gt;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote>\n<p>一个公开的加解密接口记录学习","more":"</p>\n</blockquote>\n<ul>\n<li>接口地址：<a href=\"https://api.vvhan.com/api/jm\" target=\"_blank\" rel=\"noopener\">https://api.vvhan.com/api/jm</a></li>\n<li>返回格式： JSON</li>\n<li>请求方式：GET</li>\n</ul>\n<h4 id=\"请求示例-加密-：\"><a href=\"#请求示例-加密-：\" class=\"headerlink\" title=\"请求示例(加密)：\"></a>请求示例(加密)：</h4><blockquote>\n<p><a href=\"https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要加密的内容&amp;type=en\" target=\"_blank\" rel=\"noopener\">https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要加密的内容&amp;type=en</a></p>\n</blockquote>\n<h4 id=\"请求示例-解密-：\"><a href=\"#请求示例-解密-：\" class=\"headerlink\" title=\"请求示例(解密)：\"></a>请求示例(解密)：</h4><blockquote>\n<p><a href=\"https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要解密的内容&amp;type=de\" target=\"_blank\" rel=\"noopener\">https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要解密的内容&amp;type=de</a></p>\n</blockquote>\n<h4 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h4><table>\n<thead>\n<tr>\n<th align=\"left\">名称</th>\n<th align=\"left\">必填</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">key</td>\n<td align=\"left\">否</td>\n<td align=\"left\">string</td>\n<td align=\"left\">自定义密匙</td>\n</tr>\n<tr>\n<td align=\"left\">string</td>\n<td align=\"left\">是</td>\n<td align=\"left\">string</td>\n<td align=\"left\">加/解密内容</td>\n</tr>\n<tr>\n<td align=\"left\">type</td>\n<td align=\"left\">否</td>\n<td align=\"left\">string</td>\n<td align=\"left\">en表示加密,de表示解密(默认)</td>\n</tr>\n</tbody></table>\n<h4 id=\"返回数据\"><a href=\"#返回数据\" class=\"headerlink\" title=\"返回数据\"></a>返回数据</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">加密：&#123;&quot;enmissString&quot;:&quot;InFYZ0VPKzVzTkdxUWlxV1VXVnA5cmtCenRxYkNTY3JUeVwvVWtxTm16VHNjPSI&#x3D;&quot;&#125;</span><br><span class=\"line\">解密：&#123;&quot;demissString&quot;:小韩网络&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?phpheader(&#39;Content-type:text&#x2F;json;charset&#x3D;utf-8;&#39;);</span><br><span class=\"line\">$key&#x3D;$_GET[&#39;key&#39;];</span><br><span class=\"line\">$string&#x3D;$_GET[&#39;string&#39;];</span><br><span class=\"line\">$type&#x3D;$_GET[&#39;type&#39;];</span><br><span class=\"line\">$result &#x3D; file_get_contents(&#39;https:&#x2F;&#x2F;api.vvhan.com&#x2F;api&#x2F;jm?key&#x3D;&#39;.$key.&#39;&amp;string&#x3D;&#39;.$string.&#39;&amp;type&#x3D;&#39;.$type);</span><br><span class=\"line\">echo $result;?&gt;</span><br></pre></td></tr></table></figure>"},{"title":"技术路线高级域","abbrlink":"bbd06fa5","date":"2021-02-21T12:59:38.000Z","_content":"\n <!-- more --> \n\n技术路线高级域：**\n\n　　进入技术路线的高级域，根据中级域的四个路线，可以细分成五个路线，分别是资深自动化测试工程师、资深白盒测试工程师、资深性能测试工程师、安全性测试工程师、标准化工程师，这些高级技术类人才完全与常规测试经理平齐，属于软件测试职业发展高级域。\n\n　　资深自动化测试工程师由自动化测试工程师晋升而来。如果说常规自动化测试工程师只是负责自动化测试脚本本身的设计与开发，那么资深自动化测试工程师的工作内容就是自动化测试这项工作的实施！也就是说，录制脚本-添加验证点-回放脚本只是最初始的自动化阶段，要在企业实施自动化测试，要有资深自动化测试工程师来设计数据驱动，开发测试框架，甚至一些企业内部自主开发小型测试工具（而非商业工具）的先例，这些也都是建立在资深自动化测试工程师具有深厚的技术底蕴后，主导其他人员协调完成的事情。\n\n　　资深白盒测试工程师，其工作内容包含常规白盒测试工程师的内容，除此之外，要协助测试经理或测试总监攻关测试方法与技术性难题，因此其技术水平更加雄厚。如果常规白盒测试工程师是停留在某种程序设计语言类型的代码级测试，那么资深白盒测试工程师就要脱离程序设计语言本身，结合不同架构、多种开发技术交互的情况下，寻找代码测试方法，并具有对代码优化的能力。\n\n　　资深性能测试工程师，来源于常规性能测试工程师，按照常规性能测试工程师的技术要求，资深性能测试工程师应该具备性能测试整体方案的设计能力，以及软件系统性能问题定位和性能优化的能力！除此之外，也要对主流的软件开发模式下的应用系统具有敏锐的洞察意识和感知意识。\n\n　　安全性测试工程师，其实从性能测试工程师衍生出来，因为只有具备性能测试经验的人，才对软件的开发模式、实现架构和技术本身充分了解，才会感知和预见软件系统存在的安全漏洞，加上其本人是测试出身，才知道如何通过系统漏洞尝试攻击软件系统，达到测试的目的。目前国内软件行业对于安全性测试的认识尚未清晰，该职业也更没有普及，一般只限于军事类、机密类、防病毒类或其他高安全性软件的测试工作中。","source":"_posts/2021.02/技术路线高级域.md","raw":"---\ntitle: 技术路线高级域\ntags:\n  - 博客\nabbrlink: bbd06fa5\ndate: 2021-02-21 20:59:38\n---\n\n <!-- more --> \n\n技术路线高级域：**\n\n　　进入技术路线的高级域，根据中级域的四个路线，可以细分成五个路线，分别是资深自动化测试工程师、资深白盒测试工程师、资深性能测试工程师、安全性测试工程师、标准化工程师，这些高级技术类人才完全与常规测试经理平齐，属于软件测试职业发展高级域。\n\n　　资深自动化测试工程师由自动化测试工程师晋升而来。如果说常规自动化测试工程师只是负责自动化测试脚本本身的设计与开发，那么资深自动化测试工程师的工作内容就是自动化测试这项工作的实施！也就是说，录制脚本-添加验证点-回放脚本只是最初始的自动化阶段，要在企业实施自动化测试，要有资深自动化测试工程师来设计数据驱动，开发测试框架，甚至一些企业内部自主开发小型测试工具（而非商业工具）的先例，这些也都是建立在资深自动化测试工程师具有深厚的技术底蕴后，主导其他人员协调完成的事情。\n\n　　资深白盒测试工程师，其工作内容包含常规白盒测试工程师的内容，除此之外，要协助测试经理或测试总监攻关测试方法与技术性难题，因此其技术水平更加雄厚。如果常规白盒测试工程师是停留在某种程序设计语言类型的代码级测试，那么资深白盒测试工程师就要脱离程序设计语言本身，结合不同架构、多种开发技术交互的情况下，寻找代码测试方法，并具有对代码优化的能力。\n\n　　资深性能测试工程师，来源于常规性能测试工程师，按照常规性能测试工程师的技术要求，资深性能测试工程师应该具备性能测试整体方案的设计能力，以及软件系统性能问题定位和性能优化的能力！除此之外，也要对主流的软件开发模式下的应用系统具有敏锐的洞察意识和感知意识。\n\n　　安全性测试工程师，其实从性能测试工程师衍生出来，因为只有具备性能测试经验的人，才对软件的开发模式、实现架构和技术本身充分了解，才会感知和预见软件系统存在的安全漏洞，加上其本人是测试出身，才知道如何通过系统漏洞尝试攻击软件系统，达到测试的目的。目前国内软件行业对于安全性测试的认识尚未清晰，该职业也更没有普及，一般只限于军事类、机密类、防病毒类或其他高安全性软件的测试工作中。","slug":"2021.02/技术路线高级域","published":1,"updated":"2021-02-21T12:59:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wb0008n4ep29m97tsw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script> <a id=\"more\"></a> \n\n<p>技术路线高级域：**</p>\n<p>　　进入技术路线的高级域，根据中级域的四个路线，可以细分成五个路线，分别是资深自动化测试工程师、资深白盒测试工程师、资深性能测试工程师、安全性测试工程师、标准化工程师，这些高级技术类人才完全与常规测试经理平齐，属于软件测试职业发展高级域。</p>\n<p>　　资深自动化测试工程师由自动化测试工程师晋升而来。如果说常规自动化测试工程师只是负责自动化测试脚本本身的设计与开发，那么资深自动化测试工程师的工作内容就是自动化测试这项工作的实施！也就是说，录制脚本-添加验证点-回放脚本只是最初始的自动化阶段，要在企业实施自动化测试，要有资深自动化测试工程师来设计数据驱动，开发测试框架，甚至一些企业内部自主开发小型测试工具（而非商业工具）的先例，这些也都是建立在资深自动化测试工程师具有深厚的技术底蕴后，主导其他人员协调完成的事情。</p>\n<p>　　资深白盒测试工程师，其工作内容包含常规白盒测试工程师的内容，除此之外，要协助测试经理或测试总监攻关测试方法与技术性难题，因此其技术水平更加雄厚。如果常规白盒测试工程师是停留在某种程序设计语言类型的代码级测试，那么资深白盒测试工程师就要脱离程序设计语言本身，结合不同架构、多种开发技术交互的情况下，寻找代码测试方法，并具有对代码优化的能力。</p>\n<p>　　资深性能测试工程师，来源于常规性能测试工程师，按照常规性能测试工程师的技术要求，资深性能测试工程师应该具备性能测试整体方案的设计能力，以及软件系统性能问题定位和性能优化的能力！除此之外，也要对主流的软件开发模式下的应用系统具有敏锐的洞察意识和感知意识。</p>\n<p>　　安全性测试工程师，其实从性能测试工程师衍生出来，因为只有具备性能测试经验的人，才对软件的开发模式、实现架构和技术本身充分了解，才会感知和预见软件系统存在的安全漏洞，加上其本人是测试出身，才知道如何通过系统漏洞尝试攻击软件系统，达到测试的目的。目前国内软件行业对于安全性测试的认识尚未清晰，该职业也更没有普及，一般只限于军事类、机密类、防病毒类或其他高安全性软件的测试工作中。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>技术路线高级域：**</p>\n<p>　　进入技术路线的高级域，根据中级域的四个路线，可以细分成五个路线，分别是资深自动化测试工程师、资深白盒测试工程师、资深性能测试工程师、安全性测试工程师、标准化工程师，这些高级技术类人才完全与常规测试经理平齐，属于软件测试职业发展高级域。</p>\n<p>　　资深自动化测试工程师由自动化测试工程师晋升而来。如果说常规自动化测试工程师只是负责自动化测试脚本本身的设计与开发，那么资深自动化测试工程师的工作内容就是自动化测试这项工作的实施！也就是说，录制脚本-添加验证点-回放脚本只是最初始的自动化阶段，要在企业实施自动化测试，要有资深自动化测试工程师来设计数据驱动，开发测试框架，甚至一些企业内部自主开发小型测试工具（而非商业工具）的先例，这些也都是建立在资深自动化测试工程师具有深厚的技术底蕴后，主导其他人员协调完成的事情。</p>\n<p>　　资深白盒测试工程师，其工作内容包含常规白盒测试工程师的内容，除此之外，要协助测试经理或测试总监攻关测试方法与技术性难题，因此其技术水平更加雄厚。如果常规白盒测试工程师是停留在某种程序设计语言类型的代码级测试，那么资深白盒测试工程师就要脱离程序设计语言本身，结合不同架构、多种开发技术交互的情况下，寻找代码测试方法，并具有对代码优化的能力。</p>\n<p>　　资深性能测试工程师，来源于常规性能测试工程师，按照常规性能测试工程师的技术要求，资深性能测试工程师应该具备性能测试整体方案的设计能力，以及软件系统性能问题定位和性能优化的能力！除此之外，也要对主流的软件开发模式下的应用系统具有敏锐的洞察意识和感知意识。</p>\n<p>　　安全性测试工程师，其实从性能测试工程师衍生出来，因为只有具备性能测试经验的人，才对软件的开发模式、实现架构和技术本身充分了解，才会感知和预见软件系统存在的安全漏洞，加上其本人是测试出身，才知道如何通过系统漏洞尝试攻击软件系统，达到测试的目的。目前国内软件行业对于安全性测试的认识尚未清晰，该职业也更没有普及，一般只限于军事类、机密类、防病毒类或其他高安全性软件的测试工作中。</p>"},{"title":"技术路线专家域","abbrlink":"8aa14a73","date":"2021-03-02T13:01:30.000Z","_content":"\n <!-- more --> \n\n在技术路线，向上继续提升的方向，我们称之为“技术专家”；如果说前面描述的技术职位的所涉范围都定位在企业内部，即企业级资深性能测试工程师，那么技术专家，我们可以看作是领域级专项人才！随着软件测试行业的职位不断细化，每个人在自己擅长的领域走向深入，都可以成为该领域的技术专家，技术专家在自已经营的领域里，具有个人独到的见解和深厚的技术实力，而这类人才可以不再从事具体的测试工作，而是提供行业性测试技术咨询、培训等，为软件测试整体行业的发展，起到了鲜明的带头作用\n\n","source":"_posts/2021.02/技术路线专家域.md","raw":"---\ntitle: 技术路线专家域\ntags:\n  - 博客\nabbrlink: 8aa14a73\ndate: 2021-03-02 21:01:30\n---\n\n <!-- more --> \n\n在技术路线，向上继续提升的方向，我们称之为“技术专家”；如果说前面描述的技术职位的所涉范围都定位在企业内部，即企业级资深性能测试工程师，那么技术专家，我们可以看作是领域级专项人才！随着软件测试行业的职位不断细化，每个人在自己擅长的领域走向深入，都可以成为该领域的技术专家，技术专家在自已经营的领域里，具有个人独到的见解和深厚的技术实力，而这类人才可以不再从事具体的测试工作，而是提供行业性测试技术咨询、培训等，为软件测试整体行业的发展，起到了鲜明的带头作用\n\n","slug":"2021.02/技术路线专家域","published":1,"updated":"2021-03-02T13:01:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wc0009n4epca48g78a","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script> <a id=\"more\"></a> \n\n<p>在技术路线，向上继续提升的方向，我们称之为“技术专家”；如果说前面描述的技术职位的所涉范围都定位在企业内部，即企业级资深性能测试工程师，那么技术专家，我们可以看作是领域级专项人才！随着软件测试行业的职位不断细化，每个人在自己擅长的领域走向深入，都可以成为该领域的技术专家，技术专家在自已经营的领域里，具有个人独到的见解和深厚的技术实力，而这类人才可以不再从事具体的测试工作，而是提供行业性测试技术咨询、培训等，为软件测试整体行业的发展，起到了鲜明的带头作用</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在技术路线，向上继续提升的方向，我们称之为“技术专家”；如果说前面描述的技术职位的所涉范围都定位在企业内部，即企业级资深性能测试工程师，那么技术专家，我们可以看作是领域级专项人才！随着软件测试行业的职位不断细化，每个人在自己擅长的领域走向深入，都可以成为该领域的技术专家，技术专家在自已经营的领域里，具有个人独到的见解和深厚的技术实力，而这类人才可以不再从事具体的测试工作，而是提供行业性测试技术咨询、培训等，为软件测试整体行业的发展，起到了鲜明的带头作用</p>"},{"title":"软件测试攻城狮的成长之路","abbrlink":"a9438874","date":"2021-02-05T12:52:14.000Z","_content":"\n <!-- more --> \n\n测试初期，我们并不清楚整个的测试职业发展如何，该篇文章详细地描述了各个阶段的职业目标， 希望给予迷茫的从业者启发思考。\n\n**测试初级阶段：**\n\n　　测试工程师，属于软件测试职业生涯的初级域，其适用范围是入行软件测试3年内的常规测试从业者，其主要工作内容是按照测试主管（即直接上司）分配的任务计划，编写测试用例、执行测试用例、提交软件缺陷，包括提交阶段性测试报告、参与阶段性评审等。\n\n \n\n**管理+技术路线：**\n\n　　首先是常规路线，这条发展路线要求管理与技术并重，因为软件测试的行业特点决定了这个因素：测试工程师向上晋升到测试主管、测试经理、测试总监，直至咨询域的更高方向！\n\n**技术路线中级域**：\n\n　　技术路线，划分为三个半方向，分别是自动化测试工程师、白盒测试工程师、性能测试工程师和认证测试工程师；前三者适用于通用软件测试领域，认证测试工程师乃嵌入式测试领域职位，至少目前仅出现在嵌入式领域。\n\n　　自动化测试工程师，定义在功能测试范畴，指通常所说的依靠自动化测试工具进行软件黑盒测试的工程师。从大环境讲，自动化测试是软件测试执行阶段的必然趋势，社会对于软件测试的认可度以及对自动化测试人才的需求必将日益增加。\n\n**技术路线高级域：**\n\n　　进入技术路线的高级域，根据中级域的四个路线，可以细分成五个路线，分别是资深自动化测试工程师、资深白盒测试工程师、资深性能测试工程师、安全性测试工程师、标准化工程师，这些高级技术类人才完全与常规测试经理平齐，属于软件测试职业发展高级域。\n\n　　**技术路线专家域：**\n\n　　在技术路线，向上继续提升的方向，我们称之为“技术专家”；如果说前面描述的技术职位的所涉范围都定位在企业内部，即企业级资深性能测试工程师，那么技术专家，我们可以看作是领域级专项人才！随着软件测试行业的职位不断细化，每个人在自己擅长的领域走向深入，都可以成为该领域的技术专家，技术专家在自已经营的领域里，具有个人独到的见解和深厚的技术实力，而这类人才可以不再从事具体的测试工作，而是提供行业性测试技术咨询、培训等，为软件测试整体行业的发展，起到了鲜明的带头作用\n\n","source":"_posts/2021.02/软件测试攻城狮的成长之路.md","raw":"---\ntitle: 软件测试攻城狮的成长之路\ntags:\n  - 博客\nabbrlink: a9438874\ndate: 2021-02-05 20:52:14\n---\n\n <!-- more --> \n\n测试初期，我们并不清楚整个的测试职业发展如何，该篇文章详细地描述了各个阶段的职业目标， 希望给予迷茫的从业者启发思考。\n\n**测试初级阶段：**\n\n　　测试工程师，属于软件测试职业生涯的初级域，其适用范围是入行软件测试3年内的常规测试从业者，其主要工作内容是按照测试主管（即直接上司）分配的任务计划，编写测试用例、执行测试用例、提交软件缺陷，包括提交阶段性测试报告、参与阶段性评审等。\n\n \n\n**管理+技术路线：**\n\n　　首先是常规路线，这条发展路线要求管理与技术并重，因为软件测试的行业特点决定了这个因素：测试工程师向上晋升到测试主管、测试经理、测试总监，直至咨询域的更高方向！\n\n**技术路线中级域**：\n\n　　技术路线，划分为三个半方向，分别是自动化测试工程师、白盒测试工程师、性能测试工程师和认证测试工程师；前三者适用于通用软件测试领域，认证测试工程师乃嵌入式测试领域职位，至少目前仅出现在嵌入式领域。\n\n　　自动化测试工程师，定义在功能测试范畴，指通常所说的依靠自动化测试工具进行软件黑盒测试的工程师。从大环境讲，自动化测试是软件测试执行阶段的必然趋势，社会对于软件测试的认可度以及对自动化测试人才的需求必将日益增加。\n\n**技术路线高级域：**\n\n　　进入技术路线的高级域，根据中级域的四个路线，可以细分成五个路线，分别是资深自动化测试工程师、资深白盒测试工程师、资深性能测试工程师、安全性测试工程师、标准化工程师，这些高级技术类人才完全与常规测试经理平齐，属于软件测试职业发展高级域。\n\n　　**技术路线专家域：**\n\n　　在技术路线，向上继续提升的方向，我们称之为“技术专家”；如果说前面描述的技术职位的所涉范围都定位在企业内部，即企业级资深性能测试工程师，那么技术专家，我们可以看作是领域级专项人才！随着软件测试行业的职位不断细化，每个人在自己擅长的领域走向深入，都可以成为该领域的技术专家，技术专家在自已经营的领域里，具有个人独到的见解和深厚的技术实力，而这类人才可以不再从事具体的测试工作，而是提供行业性测试技术咨询、培训等，为软件测试整体行业的发展，起到了鲜明的带头作用\n\n","slug":"2021.02/软件测试攻城狮的成长之路","published":1,"updated":"2021-02-05T12:52:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wd000bn4ephlmifu4s","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script> <a id=\"more\"></a> \n\n<p>测试初期，我们并不清楚整个的测试职业发展如何，该篇文章详细地描述了各个阶段的职业目标， 希望给予迷茫的从业者启发思考。</p>\n<p><strong>测试初级阶段：</strong></p>\n<p>　　测试工程师，属于软件测试职业生涯的初级域，其适用范围是入行软件测试3年内的常规测试从业者，其主要工作内容是按照测试主管（即直接上司）分配的任务计划，编写测试用例、执行测试用例、提交软件缺陷，包括提交阶段性测试报告、参与阶段性评审等。</p>\n<p><strong>管理+技术路线：</strong></p>\n<p>　　首先是常规路线，这条发展路线要求管理与技术并重，因为软件测试的行业特点决定了这个因素：测试工程师向上晋升到测试主管、测试经理、测试总监，直至咨询域的更高方向！</p>\n<p><strong>技术路线中级域</strong>：</p>\n<p>　　技术路线，划分为三个半方向，分别是自动化测试工程师、白盒测试工程师、性能测试工程师和认证测试工程师；前三者适用于通用软件测试领域，认证测试工程师乃嵌入式测试领域职位，至少目前仅出现在嵌入式领域。</p>\n<p>　　自动化测试工程师，定义在功能测试范畴，指通常所说的依靠自动化测试工具进行软件黑盒测试的工程师。从大环境讲，自动化测试是软件测试执行阶段的必然趋势，社会对于软件测试的认可度以及对自动化测试人才的需求必将日益增加。</p>\n<p><strong>技术路线高级域：</strong></p>\n<p>　　进入技术路线的高级域，根据中级域的四个路线，可以细分成五个路线，分别是资深自动化测试工程师、资深白盒测试工程师、资深性能测试工程师、安全性测试工程师、标准化工程师，这些高级技术类人才完全与常规测试经理平齐，属于软件测试职业发展高级域。</p>\n<p>　　<strong>技术路线专家域：</strong></p>\n<p>　　在技术路线，向上继续提升的方向，我们称之为“技术专家”；如果说前面描述的技术职位的所涉范围都定位在企业内部，即企业级资深性能测试工程师，那么技术专家，我们可以看作是领域级专项人才！随着软件测试行业的职位不断细化，每个人在自己擅长的领域走向深入，都可以成为该领域的技术专家，技术专家在自已经营的领域里，具有个人独到的见解和深厚的技术实力，而这类人才可以不再从事具体的测试工作，而是提供行业性测试技术咨询、培训等，为软件测试整体行业的发展，起到了鲜明的带头作用</p>\n","site":{"data":{}},"excerpt":"","more":"<p>测试初期，我们并不清楚整个的测试职业发展如何，该篇文章详细地描述了各个阶段的职业目标， 希望给予迷茫的从业者启发思考。</p>\n<p><strong>测试初级阶段：</strong></p>\n<p>　　测试工程师，属于软件测试职业生涯的初级域，其适用范围是入行软件测试3年内的常规测试从业者，其主要工作内容是按照测试主管（即直接上司）分配的任务计划，编写测试用例、执行测试用例、提交软件缺陷，包括提交阶段性测试报告、参与阶段性评审等。</p>\n<p><strong>管理+技术路线：</strong></p>\n<p>　　首先是常规路线，这条发展路线要求管理与技术并重，因为软件测试的行业特点决定了这个因素：测试工程师向上晋升到测试主管、测试经理、测试总监，直至咨询域的更高方向！</p>\n<p><strong>技术路线中级域</strong>：</p>\n<p>　　技术路线，划分为三个半方向，分别是自动化测试工程师、白盒测试工程师、性能测试工程师和认证测试工程师；前三者适用于通用软件测试领域，认证测试工程师乃嵌入式测试领域职位，至少目前仅出现在嵌入式领域。</p>\n<p>　　自动化测试工程师，定义在功能测试范畴，指通常所说的依靠自动化测试工具进行软件黑盒测试的工程师。从大环境讲，自动化测试是软件测试执行阶段的必然趋势，社会对于软件测试的认可度以及对自动化测试人才的需求必将日益增加。</p>\n<p><strong>技术路线高级域：</strong></p>\n<p>　　进入技术路线的高级域，根据中级域的四个路线，可以细分成五个路线，分别是资深自动化测试工程师、资深白盒测试工程师、资深性能测试工程师、安全性测试工程师、标准化工程师，这些高级技术类人才完全与常规测试经理平齐，属于软件测试职业发展高级域。</p>\n<p>　　<strong>技术路线专家域：</strong></p>\n<p>　　在技术路线，向上继续提升的方向，我们称之为“技术专家”；如果说前面描述的技术职位的所涉范围都定位在企业内部，即企业级资深性能测试工程师，那么技术专家，我们可以看作是领域级专项人才！随着软件测试行业的职位不断细化，每个人在自己擅长的领域走向深入，都可以成为该领域的技术专家，技术专家在自已经营的领域里，具有个人独到的见解和深厚的技术实力，而这类人才可以不再从事具体的测试工作，而是提供行业性测试技术咨询、培训等，为软件测试整体行业的发展，起到了鲜明的带头作用</p>"},{"title":"开篇","abbrlink":"39cb083c","date":"2021-02-04T11:19:27.000Z","_content":"\n <!-- more --> \n\n作为软件开发过程中一个非常重要的环节**，软件测试越来越成为软件开发商和用户关注的焦点。完善的测试是软件质量的保证，因此软件测试就成了一项重要而艰巨的工作。要做好这项工作当然也绝非易事。下面我着重谈谈自己在做软件测试工作中总结出来的一些经验和技巧，以供大家参考。  \n\n  **1.功能点的细化**\n  在进行测试前，先将所要测试的功能细分，填写《测试功能细分表》，有针对性的运行功能测试案例，逐个对每个功能细分点进行测试。在每次运行测试案例之前，明确此次运行的目的和预期的输出结果，并要做好记录。\n  **2.注意测试中的错误集中发生现象** \n  有一些错误是和程序开发人员的编程水平和习惯有很大关系的。例如程序中的拼写错误，习惯用法等。注意收集并记录这些现象，有助于更快、更多地发现类似的错误。  \n\n  **3.尽可能多的使用非常规的测试**\n  充分考虑到各种合法的输入和不合法的输入以及各种边界条件。边界值往往是最容易出现异常的情况，特殊的情况下甚至要制造极端的状态和意外状态，比如网络突然中断，和电源突然断电等情况。具体有以下几种情况： \n  （1） 边界测试，测试用户输入框中的数值的最大数和最小数，以及为空时的情况。  \n\n （2） 非法测试，例如在输入数字的地方输入字母。  \n\n （3） 跟踪测试，跟踪一条数据的流程,保证数据的正确性。 \n （4） 在开始测试之前应保证数据的正确性，然后再从系统中找出各种BUG。 \n （5） 接口测试，程序往往在接口的地方很容易发生错误，要在此模块测试勿掉以轻心。 \n （6） 代码重用测试，在开发过程中有些模块功能几乎相同，开发人员在重用代码时可能忘记在原有代码上修改或修改不全面，而造成的错误。 \n （7） 突发事件测试，服务器上可能发生意外情况的测试，如网络中断，电源断电等极端的情况。  \n\n （8） 外界环境测试，有些系统在开发时依赖于另外一个系统,当另外一个系统发生错误时, 这个系统所受到的影响的情况。 \n （9） 系统兼容测试，例如有些程序在IE6能运行正常，到IE5下不能运行。有些程序在WIN2000下能运行，而到WIN98却不能运行。\n （10） 用户的易用性测试，往往用户的需求是不断的变化的，而其中的一部份变化的原因，是由用户操作上不方便引起的。\n  **4.对测试错误结果一定要有一个确认的过程。**  \n\n　一般有A测试出来的错误，一定要有一个B来确认。  \n\n  **5.制定严格的测试计划**\n  测试时间安排的尽量宽松，不要希望在极短的时间内完成一个高水平的测试。  \n\n  **6.回归测试的关联性一定要引起充分的注意**\n  在开发人员刚修复Bug之后的地方,再找一找，往往开发人员只修复报告出来的缺陷而不去考虑别的功能在修改时可能会重新造成错误。修改一个错误而引起更多的错误出现的现象并不少见。   \n\n  **7.测试文档要尽可能详细**\n  《测试功能细分表》中的功能点可尽量的详细，如实、详细地记录每次运行测试案例的输入数据，输出数据，出错提示，进行测试的时间，完成测试的时间等，便于以后对测试工作的回溯。  \n\n  **8.重视交流和沟通**\n  包括和程序开发人员的交流，同是测试人员之间的交流，网上技术论坛和网友的交流,和客户的交流等。多思考，多交流，多提问，通过多种沟通交流的途径，可以少走很多弯路，同时可以学到很多东西。  \n\n  **9.善于总结**\n  在测试过程中发现的所有问题，异常情况，发现程序开发人员易犯，常犯的错误，各种有价值的经验教训，使用系统和操作数据库时发现或者学到的技巧，使用测试工具时的心得等等，都可以随手记录在笔记本或者电脑上。这些都将是今后工作中可以参照的珍贵资料，同时也会成为自己的宝贵经验。  \n\n **10.妥善保存一切测试过程文档** \n  便于测试的重现，事后的跟踪，工作的回溯，总结，报告等都要依赖这些测试文档。 \n  总之，软件测试是整个软件开发过程中交付用户使用前的最后阶段，是软件质量保证的关键，一定要引起足够的重视。","source":"_posts/2021.02/开篇.md","raw":"---\ntitle: 开篇\ntags:\n  - 博客\nabbrlink: 39cb083c\ndate: 2021-02-04 19:19:27\n---\n\n <!-- more --> \n\n作为软件开发过程中一个非常重要的环节**，软件测试越来越成为软件开发商和用户关注的焦点。完善的测试是软件质量的保证，因此软件测试就成了一项重要而艰巨的工作。要做好这项工作当然也绝非易事。下面我着重谈谈自己在做软件测试工作中总结出来的一些经验和技巧，以供大家参考。  \n\n  **1.功能点的细化**\n  在进行测试前，先将所要测试的功能细分，填写《测试功能细分表》，有针对性的运行功能测试案例，逐个对每个功能细分点进行测试。在每次运行测试案例之前，明确此次运行的目的和预期的输出结果，并要做好记录。\n  **2.注意测试中的错误集中发生现象** \n  有一些错误是和程序开发人员的编程水平和习惯有很大关系的。例如程序中的拼写错误，习惯用法等。注意收集并记录这些现象，有助于更快、更多地发现类似的错误。  \n\n  **3.尽可能多的使用非常规的测试**\n  充分考虑到各种合法的输入和不合法的输入以及各种边界条件。边界值往往是最容易出现异常的情况，特殊的情况下甚至要制造极端的状态和意外状态，比如网络突然中断，和电源突然断电等情况。具体有以下几种情况： \n  （1） 边界测试，测试用户输入框中的数值的最大数和最小数，以及为空时的情况。  \n\n （2） 非法测试，例如在输入数字的地方输入字母。  \n\n （3） 跟踪测试，跟踪一条数据的流程,保证数据的正确性。 \n （4） 在开始测试之前应保证数据的正确性，然后再从系统中找出各种BUG。 \n （5） 接口测试，程序往往在接口的地方很容易发生错误，要在此模块测试勿掉以轻心。 \n （6） 代码重用测试，在开发过程中有些模块功能几乎相同，开发人员在重用代码时可能忘记在原有代码上修改或修改不全面，而造成的错误。 \n （7） 突发事件测试，服务器上可能发生意外情况的测试，如网络中断，电源断电等极端的情况。  \n\n （8） 外界环境测试，有些系统在开发时依赖于另外一个系统,当另外一个系统发生错误时, 这个系统所受到的影响的情况。 \n （9） 系统兼容测试，例如有些程序在IE6能运行正常，到IE5下不能运行。有些程序在WIN2000下能运行，而到WIN98却不能运行。\n （10） 用户的易用性测试，往往用户的需求是不断的变化的，而其中的一部份变化的原因，是由用户操作上不方便引起的。\n  **4.对测试错误结果一定要有一个确认的过程。**  \n\n　一般有A测试出来的错误，一定要有一个B来确认。  \n\n  **5.制定严格的测试计划**\n  测试时间安排的尽量宽松，不要希望在极短的时间内完成一个高水平的测试。  \n\n  **6.回归测试的关联性一定要引起充分的注意**\n  在开发人员刚修复Bug之后的地方,再找一找，往往开发人员只修复报告出来的缺陷而不去考虑别的功能在修改时可能会重新造成错误。修改一个错误而引起更多的错误出现的现象并不少见。   \n\n  **7.测试文档要尽可能详细**\n  《测试功能细分表》中的功能点可尽量的详细，如实、详细地记录每次运行测试案例的输入数据，输出数据，出错提示，进行测试的时间，完成测试的时间等，便于以后对测试工作的回溯。  \n\n  **8.重视交流和沟通**\n  包括和程序开发人员的交流，同是测试人员之间的交流，网上技术论坛和网友的交流,和客户的交流等。多思考，多交流，多提问，通过多种沟通交流的途径，可以少走很多弯路，同时可以学到很多东西。  \n\n  **9.善于总结**\n  在测试过程中发现的所有问题，异常情况，发现程序开发人员易犯，常犯的错误，各种有价值的经验教训，使用系统和操作数据库时发现或者学到的技巧，使用测试工具时的心得等等，都可以随手记录在笔记本或者电脑上。这些都将是今后工作中可以参照的珍贵资料，同时也会成为自己的宝贵经验。  \n\n **10.妥善保存一切测试过程文档** \n  便于测试的重现，事后的跟踪，工作的回溯，总结，报告等都要依赖这些测试文档。 \n  总之，软件测试是整个软件开发过程中交付用户使用前的最后阶段，是软件质量保证的关键，一定要引起足够的重视。","slug":"2021.02/开篇","published":1,"updated":"2021-02-04T11:19:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3we000cn4epgilz0rg2","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script> <a id=\"more\"></a> \n\n<p>作为软件开发过程中一个非常重要的环节**，软件测试越来越成为软件开发商和用户关注的焦点。完善的测试是软件质量的保证，因此软件测试就成了一项重要而艰巨的工作。要做好这项工作当然也绝非易事。下面我着重谈谈自己在做软件测试工作中总结出来的一些经验和技巧，以供大家参考。  </p>\n<p>  <strong>1.功能点的细化</strong><br>  在进行测试前，先将所要测试的功能细分，填写《测试功能细分表》，有针对性的运行功能测试案例，逐个对每个功能细分点进行测试。在每次运行测试案例之前，明确此次运行的目的和预期的输出结果，并要做好记录。<br>  <strong>2.注意测试中的错误集中发生现象</strong><br>  有一些错误是和程序开发人员的编程水平和习惯有很大关系的。例如程序中的拼写错误，习惯用法等。注意收集并记录这些现象，有助于更快、更多地发现类似的错误。  </p>\n<p>  <strong>3.尽可能多的使用非常规的测试</strong><br>  充分考虑到各种合法的输入和不合法的输入以及各种边界条件。边界值往往是最容易出现异常的情况，特殊的情况下甚至要制造极端的状态和意外状态，比如网络突然中断，和电源突然断电等情况。具体有以下几种情况：<br>  （1） 边界测试，测试用户输入框中的数值的最大数和最小数，以及为空时的情况。  </p>\n<p> （2） 非法测试，例如在输入数字的地方输入字母。  </p>\n<p> （3） 跟踪测试，跟踪一条数据的流程,保证数据的正确性。<br> （4） 在开始测试之前应保证数据的正确性，然后再从系统中找出各种BUG。<br> （5） 接口测试，程序往往在接口的地方很容易发生错误，要在此模块测试勿掉以轻心。<br> （6） 代码重用测试，在开发过程中有些模块功能几乎相同，开发人员在重用代码时可能忘记在原有代码上修改或修改不全面，而造成的错误。<br> （7） 突发事件测试，服务器上可能发生意外情况的测试，如网络中断，电源断电等极端的情况。  </p>\n<p> （8） 外界环境测试，有些系统在开发时依赖于另外一个系统,当另外一个系统发生错误时, 这个系统所受到的影响的情况。<br> （9） 系统兼容测试，例如有些程序在IE6能运行正常，到IE5下不能运行。有些程序在WIN2000下能运行，而到WIN98却不能运行。<br> （10） 用户的易用性测试，往往用户的需求是不断的变化的，而其中的一部份变化的原因，是由用户操作上不方便引起的。<br>  <strong>4.对测试错误结果一定要有一个确认的过程。</strong>  </p>\n<p>　一般有A测试出来的错误，一定要有一个B来确认。  </p>\n<p>  <strong>5.制定严格的测试计划</strong><br>  测试时间安排的尽量宽松，不要希望在极短的时间内完成一个高水平的测试。  </p>\n<p>  <strong>6.回归测试的关联性一定要引起充分的注意</strong><br>  在开发人员刚修复Bug之后的地方,再找一找，往往开发人员只修复报告出来的缺陷而不去考虑别的功能在修改时可能会重新造成错误。修改一个错误而引起更多的错误出现的现象并不少见。   </p>\n<p>  <strong>7.测试文档要尽可能详细</strong><br>  《测试功能细分表》中的功能点可尽量的详细，如实、详细地记录每次运行测试案例的输入数据，输出数据，出错提示，进行测试的时间，完成测试的时间等，便于以后对测试工作的回溯。  </p>\n<p>  <strong>8.重视交流和沟通</strong><br>  包括和程序开发人员的交流，同是测试人员之间的交流，网上技术论坛和网友的交流,和客户的交流等。多思考，多交流，多提问，通过多种沟通交流的途径，可以少走很多弯路，同时可以学到很多东西。  </p>\n<p>  <strong>9.善于总结</strong><br>  在测试过程中发现的所有问题，异常情况，发现程序开发人员易犯，常犯的错误，各种有价值的经验教训，使用系统和操作数据库时发现或者学到的技巧，使用测试工具时的心得等等，都可以随手记录在笔记本或者电脑上。这些都将是今后工作中可以参照的珍贵资料，同时也会成为自己的宝贵经验。  </p>\n<p> <strong>10.妥善保存一切测试过程文档</strong><br>  便于测试的重现，事后的跟踪，工作的回溯，总结，报告等都要依赖这些测试文档。<br>  总之，软件测试是整个软件开发过程中交付用户使用前的最后阶段，是软件质量保证的关键，一定要引起足够的重视。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>作为软件开发过程中一个非常重要的环节**，软件测试越来越成为软件开发商和用户关注的焦点。完善的测试是软件质量的保证，因此软件测试就成了一项重要而艰巨的工作。要做好这项工作当然也绝非易事。下面我着重谈谈自己在做软件测试工作中总结出来的一些经验和技巧，以供大家参考。  </p>\n<p>  <strong>1.功能点的细化</strong><br>  在进行测试前，先将所要测试的功能细分，填写《测试功能细分表》，有针对性的运行功能测试案例，逐个对每个功能细分点进行测试。在每次运行测试案例之前，明确此次运行的目的和预期的输出结果，并要做好记录。<br>  <strong>2.注意测试中的错误集中发生现象</strong><br>  有一些错误是和程序开发人员的编程水平和习惯有很大关系的。例如程序中的拼写错误，习惯用法等。注意收集并记录这些现象，有助于更快、更多地发现类似的错误。  </p>\n<p>  <strong>3.尽可能多的使用非常规的测试</strong><br>  充分考虑到各种合法的输入和不合法的输入以及各种边界条件。边界值往往是最容易出现异常的情况，特殊的情况下甚至要制造极端的状态和意外状态，比如网络突然中断，和电源突然断电等情况。具体有以下几种情况：<br>  （1） 边界测试，测试用户输入框中的数值的最大数和最小数，以及为空时的情况。  </p>\n<p> （2） 非法测试，例如在输入数字的地方输入字母。  </p>\n<p> （3） 跟踪测试，跟踪一条数据的流程,保证数据的正确性。<br> （4） 在开始测试之前应保证数据的正确性，然后再从系统中找出各种BUG。<br> （5） 接口测试，程序往往在接口的地方很容易发生错误，要在此模块测试勿掉以轻心。<br> （6） 代码重用测试，在开发过程中有些模块功能几乎相同，开发人员在重用代码时可能忘记在原有代码上修改或修改不全面，而造成的错误。<br> （7） 突发事件测试，服务器上可能发生意外情况的测试，如网络中断，电源断电等极端的情况。  </p>\n<p> （8） 外界环境测试，有些系统在开发时依赖于另外一个系统,当另外一个系统发生错误时, 这个系统所受到的影响的情况。<br> （9） 系统兼容测试，例如有些程序在IE6能运行正常，到IE5下不能运行。有些程序在WIN2000下能运行，而到WIN98却不能运行。<br> （10） 用户的易用性测试，往往用户的需求是不断的变化的，而其中的一部份变化的原因，是由用户操作上不方便引起的。<br>  <strong>4.对测试错误结果一定要有一个确认的过程。</strong>  </p>\n<p>　一般有A测试出来的错误，一定要有一个B来确认。  </p>\n<p>  <strong>5.制定严格的测试计划</strong><br>  测试时间安排的尽量宽松，不要希望在极短的时间内完成一个高水平的测试。  </p>\n<p>  <strong>6.回归测试的关联性一定要引起充分的注意</strong><br>  在开发人员刚修复Bug之后的地方,再找一找，往往开发人员只修复报告出来的缺陷而不去考虑别的功能在修改时可能会重新造成错误。修改一个错误而引起更多的错误出现的现象并不少见。   </p>\n<p>  <strong>7.测试文档要尽可能详细</strong><br>  《测试功能细分表》中的功能点可尽量的详细，如实、详细地记录每次运行测试案例的输入数据，输出数据，出错提示，进行测试的时间，完成测试的时间等，便于以后对测试工作的回溯。  </p>\n<p>  <strong>8.重视交流和沟通</strong><br>  包括和程序开发人员的交流，同是测试人员之间的交流，网上技术论坛和网友的交流,和客户的交流等。多思考，多交流，多提问，通过多种沟通交流的途径，可以少走很多弯路，同时可以学到很多东西。  </p>\n<p>  <strong>9.善于总结</strong><br>  在测试过程中发现的所有问题，异常情况，发现程序开发人员易犯，常犯的错误，各种有价值的经验教训，使用系统和操作数据库时发现或者学到的技巧，使用测试工具时的心得等等，都可以随手记录在笔记本或者电脑上。这些都将是今后工作中可以参照的珍贵资料，同时也会成为自己的宝贵经验。  </p>\n<p> <strong>10.妥善保存一切测试过程文档</strong><br>  便于测试的重现，事后的跟踪，工作的回溯，总结，报告等都要依赖这些测试文档。<br>  总之，软件测试是整个软件开发过程中交付用户使用前的最后阶段，是软件质量保证的关键，一定要引起足够的重视。</p>"},{"title":"管理+技术路线","abbrlink":"d5268b29","date":"2021-02-10T12:56:54.000Z","_content":"\n <!-- more --> \n\n管理+技术路线：**\n\n　　首先是常规路线，这条发展路线要求管理与技术并重，因为软件测试的行业特点决定了这个因素：测试工程师向上晋升到测试主管、测试经理、测试总监，直至咨询域的更高方向！\n\n　　测试主管是企业项目级主管，对于中小型软件公司也可以是企业级主管，属于中级发展域，适用范围是2到5年职业经验的测试从业者。其工作内容是根据项目经理或测试经理的计划安排，调配测试工程师执行模块级或项目级测试工作，并控制与监督软件缺陷的追踪，保证每个测试环节与阶段的顺利进行。严格来说，这个级别更多属于测试的设计者，因为企业的测试流程搭建是由更高级别的测试经理或相关管理者来做的，测试主管负责该流程的具体实施；而更多的工作，是思考如何对软件进行更加深入、全面的测试。测试主管比较有创造性的工作内容就是测试设计，而恰恰很多公司忽略了或没有精力来执行此工作内容！应该说，在一个企业里做了3年左右测试工作的人员，很容易晋升到该职位，而之所以晋升，是与个人测试技术的过硬、测试方法的丰富，加上对测试流程的监控力与执行力的职业素质息息相关！\n\n　　测试经理是更高级别的测试管理者，属于高级测试方向域。对于大中型软件公司，该职位尤为重要，并且对其职业要求也比较高，一般适合4到8年的测试从业者，在管理与技术能力双双比较成熟的情况下，可以结合具体环境晋升到该级别。测试经理负责企业级或大型项目级总体测试工作的策划与实施。测试经理除了需要统筹整个企业级或项目级测试流程外，还要对于不同软件架构、不同开发技术下的测试方法进行研究与探索，为企业的测试团队成员提供指导与解决思路，同时还要合理调配不同专项测试的人力资源（如业务测试工程师、自动化测试工程师、白盒测试工程师、性能测试工程师），对软件进行全面的测试；另外，一些企业里，测试经理还需要与客户交流与沟通，负责部分的销售性或技术支持性工作。\n\n　　测试总监，属于常规发展路线的最高域，该职位一般在大型或跨国型软件企业，或者专向于测试服务型企业有所设立，一般设立测试总监的企业，该职位都相当于CTO或副总的级别，是企业级或集团级测试工作的最高领导者，驾驭着企业全部的测试与测试相关资源，管理着企业的全部测试及质量类工作。而其职业要求，也是技术与管理双结合。","source":"_posts/2021.02/管理-技术路线.md","raw":"---\ntitle: 管理+技术路线\ntags:\n  - 博客\nabbrlink: d5268b29\ndate: 2021-02-10 20:56:54\n---\n\n <!-- more --> \n\n管理+技术路线：**\n\n　　首先是常规路线，这条发展路线要求管理与技术并重，因为软件测试的行业特点决定了这个因素：测试工程师向上晋升到测试主管、测试经理、测试总监，直至咨询域的更高方向！\n\n　　测试主管是企业项目级主管，对于中小型软件公司也可以是企业级主管，属于中级发展域，适用范围是2到5年职业经验的测试从业者。其工作内容是根据项目经理或测试经理的计划安排，调配测试工程师执行模块级或项目级测试工作，并控制与监督软件缺陷的追踪，保证每个测试环节与阶段的顺利进行。严格来说，这个级别更多属于测试的设计者，因为企业的测试流程搭建是由更高级别的测试经理或相关管理者来做的，测试主管负责该流程的具体实施；而更多的工作，是思考如何对软件进行更加深入、全面的测试。测试主管比较有创造性的工作内容就是测试设计，而恰恰很多公司忽略了或没有精力来执行此工作内容！应该说，在一个企业里做了3年左右测试工作的人员，很容易晋升到该职位，而之所以晋升，是与个人测试技术的过硬、测试方法的丰富，加上对测试流程的监控力与执行力的职业素质息息相关！\n\n　　测试经理是更高级别的测试管理者，属于高级测试方向域。对于大中型软件公司，该职位尤为重要，并且对其职业要求也比较高，一般适合4到8年的测试从业者，在管理与技术能力双双比较成熟的情况下，可以结合具体环境晋升到该级别。测试经理负责企业级或大型项目级总体测试工作的策划与实施。测试经理除了需要统筹整个企业级或项目级测试流程外，还要对于不同软件架构、不同开发技术下的测试方法进行研究与探索，为企业的测试团队成员提供指导与解决思路，同时还要合理调配不同专项测试的人力资源（如业务测试工程师、自动化测试工程师、白盒测试工程师、性能测试工程师），对软件进行全面的测试；另外，一些企业里，测试经理还需要与客户交流与沟通，负责部分的销售性或技术支持性工作。\n\n　　测试总监，属于常规发展路线的最高域，该职位一般在大型或跨国型软件企业，或者专向于测试服务型企业有所设立，一般设立测试总监的企业，该职位都相当于CTO或副总的级别，是企业级或集团级测试工作的最高领导者，驾驭着企业全部的测试与测试相关资源，管理着企业的全部测试及质量类工作。而其职业要求，也是技术与管理双结合。","slug":"2021.02/管理-技术路线","published":1,"updated":"2021-02-10T12:56:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wf000dn4ep9xyu46jg","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script> <a id=\"more\"></a> \n\n<p>管理+技术路线：**</p>\n<p>　　首先是常规路线，这条发展路线要求管理与技术并重，因为软件测试的行业特点决定了这个因素：测试工程师向上晋升到测试主管、测试经理、测试总监，直至咨询域的更高方向！</p>\n<p>　　测试主管是企业项目级主管，对于中小型软件公司也可以是企业级主管，属于中级发展域，适用范围是2到5年职业经验的测试从业者。其工作内容是根据项目经理或测试经理的计划安排，调配测试工程师执行模块级或项目级测试工作，并控制与监督软件缺陷的追踪，保证每个测试环节与阶段的顺利进行。严格来说，这个级别更多属于测试的设计者，因为企业的测试流程搭建是由更高级别的测试经理或相关管理者来做的，测试主管负责该流程的具体实施；而更多的工作，是思考如何对软件进行更加深入、全面的测试。测试主管比较有创造性的工作内容就是测试设计，而恰恰很多公司忽略了或没有精力来执行此工作内容！应该说，在一个企业里做了3年左右测试工作的人员，很容易晋升到该职位，而之所以晋升，是与个人测试技术的过硬、测试方法的丰富，加上对测试流程的监控力与执行力的职业素质息息相关！</p>\n<p>　　测试经理是更高级别的测试管理者，属于高级测试方向域。对于大中型软件公司，该职位尤为重要，并且对其职业要求也比较高，一般适合4到8年的测试从业者，在管理与技术能力双双比较成熟的情况下，可以结合具体环境晋升到该级别。测试经理负责企业级或大型项目级总体测试工作的策划与实施。测试经理除了需要统筹整个企业级或项目级测试流程外，还要对于不同软件架构、不同开发技术下的测试方法进行研究与探索，为企业的测试团队成员提供指导与解决思路，同时还要合理调配不同专项测试的人力资源（如业务测试工程师、自动化测试工程师、白盒测试工程师、性能测试工程师），对软件进行全面的测试；另外，一些企业里，测试经理还需要与客户交流与沟通，负责部分的销售性或技术支持性工作。</p>\n<p>　　测试总监，属于常规发展路线的最高域，该职位一般在大型或跨国型软件企业，或者专向于测试服务型企业有所设立，一般设立测试总监的企业，该职位都相当于CTO或副总的级别，是企业级或集团级测试工作的最高领导者，驾驭着企业全部的测试与测试相关资源，管理着企业的全部测试及质量类工作。而其职业要求，也是技术与管理双结合。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>管理+技术路线：**</p>\n<p>　　首先是常规路线，这条发展路线要求管理与技术并重，因为软件测试的行业特点决定了这个因素：测试工程师向上晋升到测试主管、测试经理、测试总监，直至咨询域的更高方向！</p>\n<p>　　测试主管是企业项目级主管，对于中小型软件公司也可以是企业级主管，属于中级发展域，适用范围是2到5年职业经验的测试从业者。其工作内容是根据项目经理或测试经理的计划安排，调配测试工程师执行模块级或项目级测试工作，并控制与监督软件缺陷的追踪，保证每个测试环节与阶段的顺利进行。严格来说，这个级别更多属于测试的设计者，因为企业的测试流程搭建是由更高级别的测试经理或相关管理者来做的，测试主管负责该流程的具体实施；而更多的工作，是思考如何对软件进行更加深入、全面的测试。测试主管比较有创造性的工作内容就是测试设计，而恰恰很多公司忽略了或没有精力来执行此工作内容！应该说，在一个企业里做了3年左右测试工作的人员，很容易晋升到该职位，而之所以晋升，是与个人测试技术的过硬、测试方法的丰富，加上对测试流程的监控力与执行力的职业素质息息相关！</p>\n<p>　　测试经理是更高级别的测试管理者，属于高级测试方向域。对于大中型软件公司，该职位尤为重要，并且对其职业要求也比较高，一般适合4到8年的测试从业者，在管理与技术能力双双比较成熟的情况下，可以结合具体环境晋升到该级别。测试经理负责企业级或大型项目级总体测试工作的策划与实施。测试经理除了需要统筹整个企业级或项目级测试流程外，还要对于不同软件架构、不同开发技术下的测试方法进行研究与探索，为企业的测试团队成员提供指导与解决思路，同时还要合理调配不同专项测试的人力资源（如业务测试工程师、自动化测试工程师、白盒测试工程师、性能测试工程师），对软件进行全面的测试；另外，一些企业里，测试经理还需要与客户交流与沟通，负责部分的销售性或技术支持性工作。</p>\n<p>　　测试总监，属于常规发展路线的最高域，该职位一般在大型或跨国型软件企业，或者专向于测试服务型企业有所设立，一般设立测试总监的企业，该职位都相当于CTO或副总的级别，是企业级或集团级测试工作的最高领导者，驾驭着企业全部的测试与测试相关资源，管理着企业的全部测试及质量类工作。而其职业要求，也是技术与管理双结合。</p>"},{"title":"【DDSNTO教程】-利用软路由插件DDNSTO实现内网穿透","abbrlink":"96032b58","date":"2021-12-21T15:21:13.000Z","cover":"https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/4.png","_content":"\n> 这个插件是由小宝大神开发的, 感谢~\n\n> **傻 瓜 式 操 作 , 一 看 就 会 的 那 种 . . . 大 神 绕 道~** <!-- more --> \n\n## 一、准备条件\n\n一台Openwrt LEDE软路由系统\n微信号\n要映射的主机(网站&管理后台)\n\n## 二、开始操作\n\n进入你的Openwrt LEDE后台Web页面, 点击酷软\n\n ![打开酷软中心](https://img-blog.csdnimg.cn/img_convert/c22919ee98f8f3de883ba34fd536bf22.png) \n\n点击未安装, 找到DDNS插件, 点击安装\n等待安装完毕后, 点击这里的链接\n\n ![](https://img-blog.csdnimg.cn/img_convert/6287cb29e71dc08ea16143ec925f4ba1.png) \n\n\n再点击右上角的微信, 使用微信扫码登陆后, 你会发现右上角就出现了属于你的令牌, 把他输入到上图的token中即可\n勾选开启ddnsto, 再点击保存, 这时候你的网络中的服务就开启了\n## 三、设置映射\n\n回到刚刚的微信登陆的网页, 点击添加域名映射\n\n ![添加映射](https://img-blog.csdnimg.cn/img_convert/97d4a2e51b47a9d9aa7f392e98aab1b3.png) \n\n\n成功后你, 会看到下图,这时候你可以点击这个域名, 就可以进入到你的网站啦, 如果提示还未成功, 你就等个十几秒再次刷新网页即可.\n\n## 四、官方教程：\n> https://doc.linkease.com/zh/guide/ddnsto/\n\n ![]( /img/ddsnto_step.png) \n\n\n## 五、声明\n\n这种内网穿透的方法, 偏向私人访问, 因为在一个浏览器中第一次访问的话, 是要先进行微信验证才可以访问你设置的网站的. 这是为了安全考虑, 暂时没有去除的方法~\n\n### …Over…","source":"_posts/2021.12/【DDSNTO教程】-利用软路由插件DDNSTO实现内网穿透.md","raw":"---\ntitle: 【DDSNTO教程】-利用软路由插件DDNSTO实现内网穿透\nabbrlink: 96032b58\ndate: 2021-12-21 23:21:13\ncover: https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/4.png\ntags:\n  - 博客\n---\n\n> 这个插件是由小宝大神开发的, 感谢~\n\n> **傻 瓜 式 操 作 , 一 看 就 会 的 那 种 . . . 大 神 绕 道~** <!-- more --> \n\n## 一、准备条件\n\n一台Openwrt LEDE软路由系统\n微信号\n要映射的主机(网站&管理后台)\n\n## 二、开始操作\n\n进入你的Openwrt LEDE后台Web页面, 点击酷软\n\n ![打开酷软中心](https://img-blog.csdnimg.cn/img_convert/c22919ee98f8f3de883ba34fd536bf22.png) \n\n点击未安装, 找到DDNS插件, 点击安装\n等待安装完毕后, 点击这里的链接\n\n ![](https://img-blog.csdnimg.cn/img_convert/6287cb29e71dc08ea16143ec925f4ba1.png) \n\n\n再点击右上角的微信, 使用微信扫码登陆后, 你会发现右上角就出现了属于你的令牌, 把他输入到上图的token中即可\n勾选开启ddnsto, 再点击保存, 这时候你的网络中的服务就开启了\n## 三、设置映射\n\n回到刚刚的微信登陆的网页, 点击添加域名映射\n\n ![添加映射](https://img-blog.csdnimg.cn/img_convert/97d4a2e51b47a9d9aa7f392e98aab1b3.png) \n\n\n成功后你, 会看到下图,这时候你可以点击这个域名, 就可以进入到你的网站啦, 如果提示还未成功, 你就等个十几秒再次刷新网页即可.\n\n## 四、官方教程：\n> https://doc.linkease.com/zh/guide/ddnsto/\n\n ![]( /img/ddsnto_step.png) \n\n\n## 五、声明\n\n这种内网穿透的方法, 偏向私人访问, 因为在一个浏览器中第一次访问的话, 是要先进行微信验证才可以访问你设置的网站的. 这是为了安全考虑, 暂时没有去除的方法~\n\n### …Over…","slug":"2021.12/【DDSNTO教程】-利用软路由插件DDNSTO实现内网穿透","published":1,"updated":"2021-12-21T15:21:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wh000gn4epgrhugx23","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>这个插件是由小宝大神开发的, 感谢~</p>\n</blockquote>\n<blockquote>\n<p><strong>傻 瓜 式 操 作 , 一 看 就 会 的 那 种 . . . 大 神 绕 道~</strong> <a id=\"more\"></a> </p>\n</blockquote>\n<h2 id=\"一、准备条件\"><a href=\"#一、准备条件\" class=\"headerlink\" title=\"一、准备条件\"></a>一、准备条件</h2><p>一台Openwrt LEDE软路由系统<br>微信号<br>要映射的主机(网站&amp;管理后台)</p>\n<h2 id=\"二、开始操作\"><a href=\"#二、开始操作\" class=\"headerlink\" title=\"二、开始操作\"></a>二、开始操作</h2><p>进入你的Openwrt LEDE后台Web页面, 点击酷软</p>\n<p> <img src=\"https://img-blog.csdnimg.cn/img_convert/c22919ee98f8f3de883ba34fd536bf22.png\" alt=\"打开酷软中心\"> </p>\n<p>点击未安装, 找到DDNS插件, 点击安装<br>等待安装完毕后, 点击这里的链接</p>\n<p> <img src=\"https://img-blog.csdnimg.cn/img_convert/6287cb29e71dc08ea16143ec925f4ba1.png\" alt=\"\"> </p>\n<p>再点击右上角的微信, 使用微信扫码登陆后, 你会发现右上角就出现了属于你的令牌, 把他输入到上图的token中即可<br>勾选开启ddnsto, 再点击保存, 这时候你的网络中的服务就开启了</p>\n<h2 id=\"三、设置映射\"><a href=\"#三、设置映射\" class=\"headerlink\" title=\"三、设置映射\"></a>三、设置映射</h2><p>回到刚刚的微信登陆的网页, 点击添加域名映射</p>\n<p> <img src=\"https://img-blog.csdnimg.cn/img_convert/97d4a2e51b47a9d9aa7f392e98aab1b3.png\" alt=\"添加映射\"> </p>\n<p>成功后你, 会看到下图,这时候你可以点击这个域名, 就可以进入到你的网站啦, 如果提示还未成功, 你就等个十几秒再次刷新网页即可.</p>\n<h2 id=\"四、官方教程：\"><a href=\"#四、官方教程：\" class=\"headerlink\" title=\"四、官方教程：\"></a>四、官方教程：</h2><blockquote>\n<p><a href=\"https://doc.linkease.com/zh/guide/ddnsto/\" target=\"_blank\" rel=\"noopener\">https://doc.linkease.com/zh/guide/ddnsto/</a></p>\n</blockquote>\n<p> <img src=\"/img/ddsnto_step.png\" alt=\"\"> </p>\n<h2 id=\"五、声明\"><a href=\"#五、声明\" class=\"headerlink\" title=\"五、声明\"></a>五、声明</h2><p>这种内网穿透的方法, 偏向私人访问, 因为在一个浏览器中第一次访问的话, 是要先进行微信验证才可以访问你设置的网站的. 这是为了安全考虑, 暂时没有去除的方法~</p>\n<h3 id=\"…Over…\"><a href=\"#…Over…\" class=\"headerlink\" title=\"…Over…\"></a>…Over…</h3>","site":{"data":{}},"excerpt":"<blockquote>\n<p>这个插件是由小宝大神开发的, 感谢~</p>\n</blockquote>\n<blockquote>\n<p><strong>傻 瓜 式 操 作 , 一 看 就 会 的 那 种 . . . 大 神 绕 道~</strong>","more":"</p>\n</blockquote>\n<h2 id=\"一、准备条件\"><a href=\"#一、准备条件\" class=\"headerlink\" title=\"一、准备条件\"></a>一、准备条件</h2><p>一台Openwrt LEDE软路由系统<br>微信号<br>要映射的主机(网站&amp;管理后台)</p>\n<h2 id=\"二、开始操作\"><a href=\"#二、开始操作\" class=\"headerlink\" title=\"二、开始操作\"></a>二、开始操作</h2><p>进入你的Openwrt LEDE后台Web页面, 点击酷软</p>\n<p> <img src=\"https://img-blog.csdnimg.cn/img_convert/c22919ee98f8f3de883ba34fd536bf22.png\" alt=\"打开酷软中心\"> </p>\n<p>点击未安装, 找到DDNS插件, 点击安装<br>等待安装完毕后, 点击这里的链接</p>\n<p> <img src=\"https://img-blog.csdnimg.cn/img_convert/6287cb29e71dc08ea16143ec925f4ba1.png\" alt=\"\"> </p>\n<p>再点击右上角的微信, 使用微信扫码登陆后, 你会发现右上角就出现了属于你的令牌, 把他输入到上图的token中即可<br>勾选开启ddnsto, 再点击保存, 这时候你的网络中的服务就开启了</p>\n<h2 id=\"三、设置映射\"><a href=\"#三、设置映射\" class=\"headerlink\" title=\"三、设置映射\"></a>三、设置映射</h2><p>回到刚刚的微信登陆的网页, 点击添加域名映射</p>\n<p> <img src=\"https://img-blog.csdnimg.cn/img_convert/97d4a2e51b47a9d9aa7f392e98aab1b3.png\" alt=\"添加映射\"> </p>\n<p>成功后你, 会看到下图,这时候你可以点击这个域名, 就可以进入到你的网站啦, 如果提示还未成功, 你就等个十几秒再次刷新网页即可.</p>\n<h2 id=\"四、官方教程：\"><a href=\"#四、官方教程：\" class=\"headerlink\" title=\"四、官方教程：\"></a>四、官方教程：</h2><blockquote>\n<p><a href=\"https://doc.linkease.com/zh/guide/ddnsto/\" target=\"_blank\" rel=\"noopener\">https://doc.linkease.com/zh/guide/ddnsto/</a></p>\n</blockquote>\n<p> <img src=\"/img/ddsnto_step.png\" alt=\"\"> </p>\n<h2 id=\"五、声明\"><a href=\"#五、声明\" class=\"headerlink\" title=\"五、声明\"></a>五、声明</h2><p>这种内网穿透的方法, 偏向私人访问, 因为在一个浏览器中第一次访问的话, 是要先进行微信验证才可以访问你设置的网站的. 这是为了安全考虑, 暂时没有去除的方法~</p>\n<h3 id=\"…Over…\"><a href=\"#…Over…\" class=\"headerlink\" title=\"…Over…\"></a>…Over…</h3>"},{"title":"技术路线中级域","abbrlink":"42f034cf","date":"2021-02-16T12:58:29.000Z","_content":"\n <!-- more --> \n\n技术路线中级域**：\n\n　　技术路线，划分为三个半方向，分别是自动化测试工程师、白盒测试工程师、性能测试工程师和认证测试工程师；前三者适用于通用软件测试领域，认证测试工程师乃嵌入式测试领域职位，至少目前仅出现在嵌入式领域。\n\n　　自动化测试工程师，定义在功能测试范畴，指通常所说的依靠自动化测试工具进行软件黑盒测试的工程师。从大环境讲，自动化测试是软件测试执行阶段的必然趋势，社会对于软件测试的认可度以及对自动化测试人才的需求必将日益增加。\n\n　　白盒测试工程师，定位于在软件测试周期的单元测试阶段对软件进行的代码级测试的人，包括代码走读、代码功能与逻辑测试、代码内存泄漏检查、代码运行效率检查、代码测试覆盖率分析等。如果说，自动化测试只是依靠脚本语言完成测试脚本编写与调试的过程（因为自动化测试工程师的工作重点不在编写脚本），对于自动化测试工程师的技术要求要相对偏低的话，那么白盒测试工程师就要对大型程序开发语言的完全掌握，因此其技术要求相对偏高！\n\n　　性能测试工程师，即在系统测试阶段、功能测试后对软件系统性能指标进行采集分析和运行效率检测的人。在一个尽量压缩的测试流程里，功能测试可以手工进行，白盒测试可以不做，但是性能测试必须要做，除非该软件非网络类软件即单机版软件！软件测试，从宏观上可以划分为三个大方面：功能测试、性能测试、安全性测试，功能测试说明软件做对了，功能测试+性能测试说明软件做好了，三者结合起来说明软件做的非常好！安全测试暂且抛之不提，这是下一个发展域的内容，但是为了把软件做好，为了真正保证软件的质量，性能测试绝不容忽视；只因目前很多企业由于时间、成本、人力条件的限制，暂且不做性能测试。性能测试工程师相对来说，是三个技术路线里技术要求最高的，因为软件的性能瓶颈归根结底落实到代码的运行效率这个问题上，因此性能测试要做好，性能测试工程师起码要懂开发；而为了发现性能问题，要懂软件开发架构；为了定位性能问题，要懂操作系统、网络协议、应用服务器乃至数据库的原理与使用；为了最终解决性能问题，要根据定位的问题有针对性的对代码、操作系统、网络架构、服务器、数据库进行优化！当然性能测试是一个系统工程师，绝对不是一两个人的事情，对于常规性能测试工程师，具备定位性能问题的能力即可。","source":"_posts/2021.02/技术路线中级域.md","raw":"---\ntitle: 技术路线中级域\ntags:\n  - 博客\nabbrlink: 42f034cf\ndate: 2021-02-16 20:58:29\n---\n\n <!-- more --> \n\n技术路线中级域**：\n\n　　技术路线，划分为三个半方向，分别是自动化测试工程师、白盒测试工程师、性能测试工程师和认证测试工程师；前三者适用于通用软件测试领域，认证测试工程师乃嵌入式测试领域职位，至少目前仅出现在嵌入式领域。\n\n　　自动化测试工程师，定义在功能测试范畴，指通常所说的依靠自动化测试工具进行软件黑盒测试的工程师。从大环境讲，自动化测试是软件测试执行阶段的必然趋势，社会对于软件测试的认可度以及对自动化测试人才的需求必将日益增加。\n\n　　白盒测试工程师，定位于在软件测试周期的单元测试阶段对软件进行的代码级测试的人，包括代码走读、代码功能与逻辑测试、代码内存泄漏检查、代码运行效率检查、代码测试覆盖率分析等。如果说，自动化测试只是依靠脚本语言完成测试脚本编写与调试的过程（因为自动化测试工程师的工作重点不在编写脚本），对于自动化测试工程师的技术要求要相对偏低的话，那么白盒测试工程师就要对大型程序开发语言的完全掌握，因此其技术要求相对偏高！\n\n　　性能测试工程师，即在系统测试阶段、功能测试后对软件系统性能指标进行采集分析和运行效率检测的人。在一个尽量压缩的测试流程里，功能测试可以手工进行，白盒测试可以不做，但是性能测试必须要做，除非该软件非网络类软件即单机版软件！软件测试，从宏观上可以划分为三个大方面：功能测试、性能测试、安全性测试，功能测试说明软件做对了，功能测试+性能测试说明软件做好了，三者结合起来说明软件做的非常好！安全测试暂且抛之不提，这是下一个发展域的内容，但是为了把软件做好，为了真正保证软件的质量，性能测试绝不容忽视；只因目前很多企业由于时间、成本、人力条件的限制，暂且不做性能测试。性能测试工程师相对来说，是三个技术路线里技术要求最高的，因为软件的性能瓶颈归根结底落实到代码的运行效率这个问题上，因此性能测试要做好，性能测试工程师起码要懂开发；而为了发现性能问题，要懂软件开发架构；为了定位性能问题，要懂操作系统、网络协议、应用服务器乃至数据库的原理与使用；为了最终解决性能问题，要根据定位的问题有针对性的对代码、操作系统、网络架构、服务器、数据库进行优化！当然性能测试是一个系统工程师，绝对不是一两个人的事情，对于常规性能测试工程师，具备定位性能问题的能力即可。","slug":"2021.02/技术路线中级域","published":1,"updated":"2021-02-16T12:58:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wi000in4ep38vpeuw1","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script> <a id=\"more\"></a> \n\n<p>技术路线中级域**：</p>\n<p>　　技术路线，划分为三个半方向，分别是自动化测试工程师、白盒测试工程师、性能测试工程师和认证测试工程师；前三者适用于通用软件测试领域，认证测试工程师乃嵌入式测试领域职位，至少目前仅出现在嵌入式领域。</p>\n<p>　　自动化测试工程师，定义在功能测试范畴，指通常所说的依靠自动化测试工具进行软件黑盒测试的工程师。从大环境讲，自动化测试是软件测试执行阶段的必然趋势，社会对于软件测试的认可度以及对自动化测试人才的需求必将日益增加。</p>\n<p>　　白盒测试工程师，定位于在软件测试周期的单元测试阶段对软件进行的代码级测试的人，包括代码走读、代码功能与逻辑测试、代码内存泄漏检查、代码运行效率检查、代码测试覆盖率分析等。如果说，自动化测试只是依靠脚本语言完成测试脚本编写与调试的过程（因为自动化测试工程师的工作重点不在编写脚本），对于自动化测试工程师的技术要求要相对偏低的话，那么白盒测试工程师就要对大型程序开发语言的完全掌握，因此其技术要求相对偏高！</p>\n<p>　　性能测试工程师，即在系统测试阶段、功能测试后对软件系统性能指标进行采集分析和运行效率检测的人。在一个尽量压缩的测试流程里，功能测试可以手工进行，白盒测试可以不做，但是性能测试必须要做，除非该软件非网络类软件即单机版软件！软件测试，从宏观上可以划分为三个大方面：功能测试、性能测试、安全性测试，功能测试说明软件做对了，功能测试+性能测试说明软件做好了，三者结合起来说明软件做的非常好！安全测试暂且抛之不提，这是下一个发展域的内容，但是为了把软件做好，为了真正保证软件的质量，性能测试绝不容忽视；只因目前很多企业由于时间、成本、人力条件的限制，暂且不做性能测试。性能测试工程师相对来说，是三个技术路线里技术要求最高的，因为软件的性能瓶颈归根结底落实到代码的运行效率这个问题上，因此性能测试要做好，性能测试工程师起码要懂开发；而为了发现性能问题，要懂软件开发架构；为了定位性能问题，要懂操作系统、网络协议、应用服务器乃至数据库的原理与使用；为了最终解决性能问题，要根据定位的问题有针对性的对代码、操作系统、网络架构、服务器、数据库进行优化！当然性能测试是一个系统工程师，绝对不是一两个人的事情，对于常规性能测试工程师，具备定位性能问题的能力即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>技术路线中级域**：</p>\n<p>　　技术路线，划分为三个半方向，分别是自动化测试工程师、白盒测试工程师、性能测试工程师和认证测试工程师；前三者适用于通用软件测试领域，认证测试工程师乃嵌入式测试领域职位，至少目前仅出现在嵌入式领域。</p>\n<p>　　自动化测试工程师，定义在功能测试范畴，指通常所说的依靠自动化测试工具进行软件黑盒测试的工程师。从大环境讲，自动化测试是软件测试执行阶段的必然趋势，社会对于软件测试的认可度以及对自动化测试人才的需求必将日益增加。</p>\n<p>　　白盒测试工程师，定位于在软件测试周期的单元测试阶段对软件进行的代码级测试的人，包括代码走读、代码功能与逻辑测试、代码内存泄漏检查、代码运行效率检查、代码测试覆盖率分析等。如果说，自动化测试只是依靠脚本语言完成测试脚本编写与调试的过程（因为自动化测试工程师的工作重点不在编写脚本），对于自动化测试工程师的技术要求要相对偏低的话，那么白盒测试工程师就要对大型程序开发语言的完全掌握，因此其技术要求相对偏高！</p>\n<p>　　性能测试工程师，即在系统测试阶段、功能测试后对软件系统性能指标进行采集分析和运行效率检测的人。在一个尽量压缩的测试流程里，功能测试可以手工进行，白盒测试可以不做，但是性能测试必须要做，除非该软件非网络类软件即单机版软件！软件测试，从宏观上可以划分为三个大方面：功能测试、性能测试、安全性测试，功能测试说明软件做对了，功能测试+性能测试说明软件做好了，三者结合起来说明软件做的非常好！安全测试暂且抛之不提，这是下一个发展域的内容，但是为了把软件做好，为了真正保证软件的质量，性能测试绝不容忽视；只因目前很多企业由于时间、成本、人力条件的限制，暂且不做性能测试。性能测试工程师相对来说，是三个技术路线里技术要求最高的，因为软件的性能瓶颈归根结底落实到代码的运行效率这个问题上，因此性能测试要做好，性能测试工程师起码要懂开发；而为了发现性能问题，要懂软件开发架构；为了定位性能问题，要懂操作系统、网络协议、应用服务器乃至数据库的原理与使用；为了最终解决性能问题，要根据定位的问题有针对性的对代码、操作系统、网络架构、服务器、数据库进行优化！当然性能测试是一个系统工程师，绝对不是一两个人的事情，对于常规性能测试工程师，具备定位性能问题的能力即可。</p>"},{"title":"【工具分享】DDNSTO 简单、快速的内网穿透工具","abbrlink":"f6c5d65f","cover":"https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/5.png","date":"2021-12-20T16:07:00.000Z","_content":"\n### 随时随地抵达你的 私人网络\n\n简单、快速的内网穿透工具，不受\n网络限制，全局掌控您的私人设备 <!-- more --> \n\nDDNSTO 由 [KoolShare (opens new window)](https://koolshare.cn/space-uid-2380.html)@小宝 开发，是一款稳定、快速、简单易用的内网穿透工具。 让用户在公司、旅行途中都能够使用浏览器方便的访问家庭内的网络设备。\n\n目前市面上的穿透工具都有各种小缺点，有的需要电脑安装客户端并且要支付几百块钱的年费、frp需要自行购买云服务器并且配置过程对小白用户来说也比较复杂。\n\n**DDNSTO 解决了常见穿透工具年费贵、配置复杂的问题，让小白用户几分钟就能搞定内网穿透。**\n\nDDNSTO 的优秀之处：\n\n1. 无需公网 IP，不被网络环境限制\n2. 无需购买域名或服务器，省去了服务器年费和带宽要求以及域名购买、备案等等繁琐操作\n3. 全部的安装、配置、使用都可在浏览器完成，不需要敲一行代码，对小白用户非常友好\n4. 支持http2，访问家庭内部网络速度更快\n5. 独家的远程应用中心，让远程电脑桌面、远程下载、远程文件管理等多种丰富的功能在浏览器上就可以实现\n\n","source":"_posts/2021.12/【工具分享】DDNSTO 简单、快速的内网穿透工具.md","raw":"---\ntitle: 【工具分享】DDNSTO 简单、快速的内网穿透工具\nabbrlink: f6c5d65f\ncover: https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/5.png\ndate: 2021-12-21 00:07:00\ntags:\n---\n\n### 随时随地抵达你的 私人网络\n\n简单、快速的内网穿透工具，不受\n网络限制，全局掌控您的私人设备 <!-- more --> \n\nDDNSTO 由 [KoolShare (opens new window)](https://koolshare.cn/space-uid-2380.html)@小宝 开发，是一款稳定、快速、简单易用的内网穿透工具。 让用户在公司、旅行途中都能够使用浏览器方便的访问家庭内的网络设备。\n\n目前市面上的穿透工具都有各种小缺点，有的需要电脑安装客户端并且要支付几百块钱的年费、frp需要自行购买云服务器并且配置过程对小白用户来说也比较复杂。\n\n**DDNSTO 解决了常见穿透工具年费贵、配置复杂的问题，让小白用户几分钟就能搞定内网穿透。**\n\nDDNSTO 的优秀之处：\n\n1. 无需公网 IP，不被网络环境限制\n2. 无需购买域名或服务器，省去了服务器年费和带宽要求以及域名购买、备案等等繁琐操作\n3. 全部的安装、配置、使用都可在浏览器完成，不需要敲一行代码，对小白用户非常友好\n4. 支持http2，访问家庭内部网络速度更快\n5. 独家的远程应用中心，让远程电脑桌面、远程下载、远程文件管理等多种丰富的功能在浏览器上就可以实现\n\n","slug":"2021.12/【工具分享】DDNSTO 简单、快速的内网穿透工具","published":1,"updated":"2021-12-20T16:07:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wj000ln4epcbmu3zu5","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h3 id=\"随时随地抵达你的-私人网络\"><a href=\"#随时随地抵达你的-私人网络\" class=\"headerlink\" title=\"随时随地抵达你的 私人网络\"></a>随时随地抵达你的 私人网络</h3><p>简单、快速的内网穿透工具，不受<br>网络限制，全局掌控您的私人设备 <a id=\"more\"></a> </p>\n<p>DDNSTO 由 <a href=\"https://koolshare.cn/space-uid-2380.html\" target=\"_blank\" rel=\"noopener\">KoolShare (opens new window)</a>@小宝 开发，是一款稳定、快速、简单易用的内网穿透工具。 让用户在公司、旅行途中都能够使用浏览器方便的访问家庭内的网络设备。</p>\n<p>目前市面上的穿透工具都有各种小缺点，有的需要电脑安装客户端并且要支付几百块钱的年费、frp需要自行购买云服务器并且配置过程对小白用户来说也比较复杂。</p>\n<p><strong>DDNSTO 解决了常见穿透工具年费贵、配置复杂的问题，让小白用户几分钟就能搞定内网穿透。</strong></p>\n<p>DDNSTO 的优秀之处：</p>\n<ol>\n<li>无需公网 IP，不被网络环境限制</li>\n<li>无需购买域名或服务器，省去了服务器年费和带宽要求以及域名购买、备案等等繁琐操作</li>\n<li>全部的安装、配置、使用都可在浏览器完成，不需要敲一行代码，对小白用户非常友好</li>\n<li>支持http2，访问家庭内部网络速度更快</li>\n<li>独家的远程应用中心，让远程电脑桌面、远程下载、远程文件管理等多种丰富的功能在浏览器上就可以实现</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"随时随地抵达你的-私人网络\"><a href=\"#随时随地抵达你的-私人网络\" class=\"headerlink\" title=\"随时随地抵达你的 私人网络\"></a>随时随地抵达你的 私人网络</h3><p>简单、快速的内网穿透工具，不受<br>网络限制，全局掌控您的私人设备","more":"</p>\n<p>DDNSTO 由 <a href=\"https://koolshare.cn/space-uid-2380.html\" target=\"_blank\" rel=\"noopener\">KoolShare (opens new window)</a>@小宝 开发，是一款稳定、快速、简单易用的内网穿透工具。 让用户在公司、旅行途中都能够使用浏览器方便的访问家庭内的网络设备。</p>\n<p>目前市面上的穿透工具都有各种小缺点，有的需要电脑安装客户端并且要支付几百块钱的年费、frp需要自行购买云服务器并且配置过程对小白用户来说也比较复杂。</p>\n<p><strong>DDNSTO 解决了常见穿透工具年费贵、配置复杂的问题，让小白用户几分钟就能搞定内网穿透。</strong></p>\n<p>DDNSTO 的优秀之处：</p>\n<ol>\n<li>无需公网 IP，不被网络环境限制</li>\n<li>无需购买域名或服务器，省去了服务器年费和带宽要求以及域名购买、备案等等繁琐操作</li>\n<li>全部的安装、配置、使用都可在浏览器完成，不需要敲一行代码，对小白用户非常友好</li>\n<li>支持http2，访问家庭内部网络速度更快</li>\n<li>独家的远程应用中心，让远程电脑桌面、远程下载、远程文件管理等多种丰富的功能在浏览器上就可以实现</li>\n</ol>"},{"title":"【博客搭建】HEXO踩坑指南","banner_img":"/img/banner.png","abbrlink":"3447554d","date":"2021-11-30T14:00:00.000Z","_content":"\n ### 踩坑指南\n\n> 发现点击标题文章打开不对，尝试安装 abbrlink 插件试试吧\n\ncnpm install hexo-abbrlink --save\n\n\n\n> 想要隐藏这篇文章\n在title里添加这行代码试试\n```\nhide: true\n```\n\n\n\n![](/img/1638799083784.png)\n\n","source":"_posts/2021.12/【博客搭建】HEXO踩坑指南.md","raw":"---\ntitle: 【博客搭建】HEXO踩坑指南\ntags:\n  - 博客\nbanner_img: /img/banner.png\nabbrlink: 3447554d\ndate: 2021-11-30 22:00:00\n---\n\n ### 踩坑指南\n\n> 发现点击标题文章打开不对，尝试安装 abbrlink 插件试试吧\n\ncnpm install hexo-abbrlink --save\n\n\n\n> 想要隐藏这篇文章\n在title里添加这行代码试试\n```\nhide: true\n```\n\n\n\n![](/img/1638799083784.png)\n\n","slug":"2021.12/【博客搭建】HEXO踩坑指南","published":1,"updated":"2021-11-30T14:00:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wk000nn4ep1c7u2vbo","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h3 id=\"踩坑指南\"><a href=\"#踩坑指南\" class=\"headerlink\" title=\"踩坑指南\"></a>踩坑指南</h3><blockquote>\n<p>发现点击标题文章打开不对，尝试安装 abbrlink 插件试试吧</p>\n</blockquote>\n<p>cnpm install hexo-abbrlink –save</p>\n<blockquote>\n<p>想要隐藏这篇文章<br>在title里添加这行代码试试</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hide: true</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/img/1638799083784.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"踩坑指南\"><a href=\"#踩坑指南\" class=\"headerlink\" title=\"踩坑指南\"></a>踩坑指南</h3><blockquote>\n<p>发现点击标题文章打开不对，尝试安装 abbrlink 插件试试吧</p>\n</blockquote>\n<p>cnpm install hexo-abbrlink –save</p>\n<blockquote>\n<p>想要隐藏这篇文章<br>在title里添加这行代码试试</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hide: true</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"/img/1638799083784.png\" alt=\"\"></p>\n"},{"title":"【测试工具】Android Input命令","abbrlink":"7de15477","cover":"https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/6.png","date":"2021-12-15T14:52:48.000Z","_content":"\n## input\n\ninput是Android系统中的一个特殊的命令，用于模拟遥控器、键盘、鼠标的各种按键操作。我们都知道Android是阉割版本的Linux系统，Linux中很多命令在Android系统中是没有的。但是他们之间并没有包含的关系，Android系统中有些特有的东西（命令、属性）在Linux中也是没有的。 <!-- more --> \n\n### 命令路径\n\n可以通过which 命令查看该命令的位置：\n\n```\n130|superli:/ # which -a input        \n/system/bin/input\nsuperli:/ # \n```\n\n\n### 命令概要\n\n#### Android 4.4以前\n\n使用help命令查看命令如何使用：\n\n```\nroot@hwH30-U10:/ # input --help\nError: Unknown command: --help\nusage: input ...\n       input text <string>\n       input keyevent <key code number or name>\n       input [touchscreen|touchpad] tap <x> <y>\n       input [touchscreen|touchpad] swipe <x1> <y1> <x2> <y2>\n       input trackball press\n       input trackball roll <dx> <dy>\nroot@hwH30-U10:/ #\n```\n### Android 4.4+\n\n使用help命令查看命令如何使用：\n\n```\n130|superli:/ # input --help\nError: Unknown command: --help  ## 未知命令？为什么会出现这个？？？算了，不重要，可能系统抽风了。\nUsage: input [<source>] <command> [<arg>...]\n\nThe sources are: ##模拟的输入设备类型\n      keyboard\n      mouse\n      joystick\n      touchnavigation\n      touchpad\n      trackball\n      dpad\n      stylus\n      gamepad\n      touchscreen\n\nThe commands and default sources are: ## 不指定source时，命令的默认输入设备类型为：\n      text <string> (Default: touchscreen)\n      keyevent [--longpress] <key code number or name> ... (Default: keyboard)\n      tap <x> <y> (Default: touchscreen)\n      swipe <x1> <y1> <x2> <y2> [duration(ms)] (Default: touchscreen)\n      press (Default: trackball)\n      roll <dx> <dy> (Default: trackball)\nsuperli:/ # \n```\n\n### 命令解读和使用\n\n后续内容主要分析Android 4.4+版本关于input命令的使用，当然4.4以前的版本也可以参考，毕竟差别并不是很大。\n\n命令格式：input [<source>] <command> [<arg>...]\n\n命令格式（中文版）：input [<设备类型（可选）>] <命令> [<参数（可选）>...]\n\n命令格式中可以看到有两个可选的部分：\n\n设备类型：设备类型不输入时，使用命令的默认设备类型。默认类型见下文。\n参数：当命令没有参数时，可不输入（想了半天，想不出来什么命令不需要参数）\n\n#### 设备类型\n\nsources\t模拟的输入设备类型\nkeyboard\t键盘\nmouse\t鼠标\njoystick\t操纵杆（玩过游戏手柄的同学应该懂吧）\ntouchnavigation\t？？触摸导航？？\ntouchpad\t触摸板\ntrackball\t轨迹球（啥意思？）\ndpad\t什么鬼\nstylus\t触控笔（styluses）\ngamepad\t游戏手柄\ntouchscreen\t触摸屏\n设备类型还挺丰富的，好多普通人根本接触不到，哎，我就是普通人。\n\n### 命令列表和默认设备类型\n\n命令\t默认设备类型\t示例\ntext\ttouchscreen\tinput text \"hello\"\nkeyevent [–longpress]\tkeyboard\tinput keyevent 4\ntap\ttouchscreen\tinput tap 500 500\nswipe [duration(ms)]\ttouchscreen\tinput swipe 500 500 600 500 200\npress\ttrackball\tinput press\nroll\ttrackball\tinput roll 500 500\n命令演练与解释\n命令列表中，关于press和roll都是针对触控球的设备设计的，因为手中没有设备，而且这种设备现实中使用的比较少，所以就不做演示\n\ntext\n该命令用于模拟触摸屏的虚拟键盘输入字符串。\n\n比如，下面使用命令输入“hello”：\n\nHWVKY:/ $ input text hello\n\ntext命令后面的字符都会以字符串的形式输入，如果恰好设备的焦点在一个可输入控件（通常为EditText）中，那么可输入控件中就会出现“hello”字样。\n\n如果命令执行后，“hello”并没有显示，请检查一下控件是否有限定输入类型。\n\nkeyevent\n该命令用以默认按键输入，对应的输入设备场景可能是遥控器、键盘等。\n\n例如，下面使用命令模拟遥控器的返回键：\n\nHWVKY:/ $ input keyevent 4\n\n命令执行后，设备中能很明显的看到有回退动作。命令中的参数“4”，对应的是keyevent中的返回键。下面列出部分常用keyevent事件的键值列表。\n\nKeyevent\tvalue\t备注\nKEYCODE_BACK\t4\t返回键\nKEYCODE_HOME\t3\tHOME键\nKEYCODE_MENU\t82\t菜单键\nKEYCODE_DPAD_UP\t19\t上\nKEYCODE_DPAD_DOWN\t20\t下\nKEYCODE_DPAD_LEFT\t21\t左\nKEYCODE_DPAD_RIGHT\t22\t右\nKEYCODE_DPAD_CENTER\t23\tOK键\nKEYCODE_VOLUME_UP\t24\t音量+\nKEYCODE_VOLUME_DOWN\t25\t音量-\n如果列表中不满足你的需求，可以去android.view.KeyEvent.java中查看\n\ntap\n该命令用于模拟触摸操作，感觉就是点击一下指定位置，可以让指定的点变相的获取焦点。\n\n例如，下面的命令，如果位于首页，500*500的坐标处恰好有一个应用图标，那么命令执行后，会打开该应用：\n\n```HWVKY:/ $ input tap 500 500```\n\nswipe\n该命令用于模拟手势滑动操作\n\n例如，下面的命令模拟，从500*500的坐标滑动到600*500的位置：\n\n```HWVKY:/ $ input swipe 500 500 600 500```\n\n上边的命令执行后，屏幕瞬间就会滑动，那么我要慢慢的滑动怎么办呢，看下面的命令:\n\n```HWVKY:/ $ input swipe 500 500 600 500 500```\n\n两个命令的区别在于第二个多了一个参数，该参数表示该滑动需要执行的时长为500ms。\n\n值得一提的是，当参数中的两个坐标点使用一个点时，秒变长按事件：\n\n```HWVKY:/ $ input swipe 500 500 500 500 1000```\n\n该命令表示：长按坐标为500*500的点1秒钟。\n\n","source":"_posts/2021.12/【测试工具】Android Input命令.md","raw":"---\ntitle: 【测试工具】Android Input命令\nabbrlink: 7de15477\ncover: https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/6.png\ndate: 2021-12-15 22:52:48\ntags:\n---\n\n## input\n\ninput是Android系统中的一个特殊的命令，用于模拟遥控器、键盘、鼠标的各种按键操作。我们都知道Android是阉割版本的Linux系统，Linux中很多命令在Android系统中是没有的。但是他们之间并没有包含的关系，Android系统中有些特有的东西（命令、属性）在Linux中也是没有的。 <!-- more --> \n\n### 命令路径\n\n可以通过which 命令查看该命令的位置：\n\n```\n130|superli:/ # which -a input        \n/system/bin/input\nsuperli:/ # \n```\n\n\n### 命令概要\n\n#### Android 4.4以前\n\n使用help命令查看命令如何使用：\n\n```\nroot@hwH30-U10:/ # input --help\nError: Unknown command: --help\nusage: input ...\n       input text <string>\n       input keyevent <key code number or name>\n       input [touchscreen|touchpad] tap <x> <y>\n       input [touchscreen|touchpad] swipe <x1> <y1> <x2> <y2>\n       input trackball press\n       input trackball roll <dx> <dy>\nroot@hwH30-U10:/ #\n```\n### Android 4.4+\n\n使用help命令查看命令如何使用：\n\n```\n130|superli:/ # input --help\nError: Unknown command: --help  ## 未知命令？为什么会出现这个？？？算了，不重要，可能系统抽风了。\nUsage: input [<source>] <command> [<arg>...]\n\nThe sources are: ##模拟的输入设备类型\n      keyboard\n      mouse\n      joystick\n      touchnavigation\n      touchpad\n      trackball\n      dpad\n      stylus\n      gamepad\n      touchscreen\n\nThe commands and default sources are: ## 不指定source时，命令的默认输入设备类型为：\n      text <string> (Default: touchscreen)\n      keyevent [--longpress] <key code number or name> ... (Default: keyboard)\n      tap <x> <y> (Default: touchscreen)\n      swipe <x1> <y1> <x2> <y2> [duration(ms)] (Default: touchscreen)\n      press (Default: trackball)\n      roll <dx> <dy> (Default: trackball)\nsuperli:/ # \n```\n\n### 命令解读和使用\n\n后续内容主要分析Android 4.4+版本关于input命令的使用，当然4.4以前的版本也可以参考，毕竟差别并不是很大。\n\n命令格式：input [<source>] <command> [<arg>...]\n\n命令格式（中文版）：input [<设备类型（可选）>] <命令> [<参数（可选）>...]\n\n命令格式中可以看到有两个可选的部分：\n\n设备类型：设备类型不输入时，使用命令的默认设备类型。默认类型见下文。\n参数：当命令没有参数时，可不输入（想了半天，想不出来什么命令不需要参数）\n\n#### 设备类型\n\nsources\t模拟的输入设备类型\nkeyboard\t键盘\nmouse\t鼠标\njoystick\t操纵杆（玩过游戏手柄的同学应该懂吧）\ntouchnavigation\t？？触摸导航？？\ntouchpad\t触摸板\ntrackball\t轨迹球（啥意思？）\ndpad\t什么鬼\nstylus\t触控笔（styluses）\ngamepad\t游戏手柄\ntouchscreen\t触摸屏\n设备类型还挺丰富的，好多普通人根本接触不到，哎，我就是普通人。\n\n### 命令列表和默认设备类型\n\n命令\t默认设备类型\t示例\ntext\ttouchscreen\tinput text \"hello\"\nkeyevent [–longpress]\tkeyboard\tinput keyevent 4\ntap\ttouchscreen\tinput tap 500 500\nswipe [duration(ms)]\ttouchscreen\tinput swipe 500 500 600 500 200\npress\ttrackball\tinput press\nroll\ttrackball\tinput roll 500 500\n命令演练与解释\n命令列表中，关于press和roll都是针对触控球的设备设计的，因为手中没有设备，而且这种设备现实中使用的比较少，所以就不做演示\n\ntext\n该命令用于模拟触摸屏的虚拟键盘输入字符串。\n\n比如，下面使用命令输入“hello”：\n\nHWVKY:/ $ input text hello\n\ntext命令后面的字符都会以字符串的形式输入，如果恰好设备的焦点在一个可输入控件（通常为EditText）中，那么可输入控件中就会出现“hello”字样。\n\n如果命令执行后，“hello”并没有显示，请检查一下控件是否有限定输入类型。\n\nkeyevent\n该命令用以默认按键输入，对应的输入设备场景可能是遥控器、键盘等。\n\n例如，下面使用命令模拟遥控器的返回键：\n\nHWVKY:/ $ input keyevent 4\n\n命令执行后，设备中能很明显的看到有回退动作。命令中的参数“4”，对应的是keyevent中的返回键。下面列出部分常用keyevent事件的键值列表。\n\nKeyevent\tvalue\t备注\nKEYCODE_BACK\t4\t返回键\nKEYCODE_HOME\t3\tHOME键\nKEYCODE_MENU\t82\t菜单键\nKEYCODE_DPAD_UP\t19\t上\nKEYCODE_DPAD_DOWN\t20\t下\nKEYCODE_DPAD_LEFT\t21\t左\nKEYCODE_DPAD_RIGHT\t22\t右\nKEYCODE_DPAD_CENTER\t23\tOK键\nKEYCODE_VOLUME_UP\t24\t音量+\nKEYCODE_VOLUME_DOWN\t25\t音量-\n如果列表中不满足你的需求，可以去android.view.KeyEvent.java中查看\n\ntap\n该命令用于模拟触摸操作，感觉就是点击一下指定位置，可以让指定的点变相的获取焦点。\n\n例如，下面的命令，如果位于首页，500*500的坐标处恰好有一个应用图标，那么命令执行后，会打开该应用：\n\n```HWVKY:/ $ input tap 500 500```\n\nswipe\n该命令用于模拟手势滑动操作\n\n例如，下面的命令模拟，从500*500的坐标滑动到600*500的位置：\n\n```HWVKY:/ $ input swipe 500 500 600 500```\n\n上边的命令执行后，屏幕瞬间就会滑动，那么我要慢慢的滑动怎么办呢，看下面的命令:\n\n```HWVKY:/ $ input swipe 500 500 600 500 500```\n\n两个命令的区别在于第二个多了一个参数，该参数表示该滑动需要执行的时长为500ms。\n\n值得一提的是，当参数中的两个坐标点使用一个点时，秒变长按事件：\n\n```HWVKY:/ $ input swipe 500 500 500 500 1000```\n\n该命令表示：长按坐标为500*500的点1秒钟。\n\n","slug":"2021.12/【测试工具】Android Input命令","published":1,"updated":"2021-12-15T14:52:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wl000pn4ep2zx8fkdv","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h2><p>input是Android系统中的一个特殊的命令，用于模拟遥控器、键盘、鼠标的各种按键操作。我们都知道Android是阉割版本的Linux系统，Linux中很多命令在Android系统中是没有的。但是他们之间并没有包含的关系，Android系统中有些特有的东西（命令、属性）在Linux中也是没有的。 <a id=\"more\"></a> </p>\n<h3 id=\"命令路径\"><a href=\"#命令路径\" class=\"headerlink\" title=\"命令路径\"></a>命令路径</h3><p>可以通过which 命令查看该命令的位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">130|superli:&#x2F; # which -a input        </span><br><span class=\"line\">&#x2F;system&#x2F;bin&#x2F;input</span><br><span class=\"line\">superli:&#x2F; #</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"命令概要\"><a href=\"#命令概要\" class=\"headerlink\" title=\"命令概要\"></a>命令概要</h3><h4 id=\"Android-4-4以前\"><a href=\"#Android-4-4以前\" class=\"headerlink\" title=\"Android 4.4以前\"></a>Android 4.4以前</h4><p>使用help命令查看命令如何使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hwH30-U10:&#x2F; # input --help</span><br><span class=\"line\">Error: Unknown command: --help</span><br><span class=\"line\">usage: input ...</span><br><span class=\"line\">       input text &lt;string&gt;</span><br><span class=\"line\">       input keyevent &lt;key code number or name&gt;</span><br><span class=\"line\">       input [touchscreen|touchpad] tap &lt;x&gt; &lt;y&gt;</span><br><span class=\"line\">       input [touchscreen|touchpad] swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt;</span><br><span class=\"line\">       input trackball press</span><br><span class=\"line\">       input trackball roll &lt;dx&gt; &lt;dy&gt;</span><br><span class=\"line\">root@hwH30-U10:&#x2F; #</span><br></pre></td></tr></table></figure>\n<h3 id=\"Android-4-4\"><a href=\"#Android-4-4\" class=\"headerlink\" title=\"Android 4.4+\"></a>Android 4.4+</h3><p>使用help命令查看命令如何使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">130|superli:&#x2F; # input --help</span><br><span class=\"line\">Error: Unknown command: --help  ## 未知命令？为什么会出现这个？？？算了，不重要，可能系统抽风了。</span><br><span class=\"line\">Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]</span><br><span class=\"line\"></span><br><span class=\"line\">The sources are: ##模拟的输入设备类型</span><br><span class=\"line\">      keyboard</span><br><span class=\"line\">      mouse</span><br><span class=\"line\">      joystick</span><br><span class=\"line\">      touchnavigation</span><br><span class=\"line\">      touchpad</span><br><span class=\"line\">      trackball</span><br><span class=\"line\">      dpad</span><br><span class=\"line\">      stylus</span><br><span class=\"line\">      gamepad</span><br><span class=\"line\">      touchscreen</span><br><span class=\"line\"></span><br><span class=\"line\">The commands and default sources are: ## 不指定source时，命令的默认输入设备类型为：</span><br><span class=\"line\">      text &lt;string&gt; (Default: touchscreen)</span><br><span class=\"line\">      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)</span><br><span class=\"line\">      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)</span><br><span class=\"line\">      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class=\"line\">      press (Default: trackball)</span><br><span class=\"line\">      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)</span><br><span class=\"line\">superli:&#x2F; #</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令解读和使用\"><a href=\"#命令解读和使用\" class=\"headerlink\" title=\"命令解读和使用\"></a>命令解读和使用</h3><p>后续内容主要分析Android 4.4+版本关于input命令的使用，当然4.4以前的版本也可以参考，毕竟差别并不是很大。</p>\n<p>命令格式：input [<source>] <command> [<arg>…]</p>\n<p>命令格式（中文版）：input [&lt;设备类型（可选）&gt;] &lt;命令&gt; [&lt;参数（可选）&gt;…]</p>\n<p>命令格式中可以看到有两个可选的部分：</p>\n<p>设备类型：设备类型不输入时，使用命令的默认设备类型。默认类型见下文。<br>参数：当命令没有参数时，可不输入（想了半天，想不出来什么命令不需要参数）</p>\n<h4 id=\"设备类型\"><a href=\"#设备类型\" class=\"headerlink\" title=\"设备类型\"></a>设备类型</h4><p>sources    模拟的输入设备类型<br>keyboard    键盘<br>mouse    鼠标<br>joystick    操纵杆（玩过游戏手柄的同学应该懂吧）<br>touchnavigation    ？？触摸导航？？<br>touchpad    触摸板<br>trackball    轨迹球（啥意思？）<br>dpad    什么鬼<br>stylus    触控笔（styluses）<br>gamepad    游戏手柄<br>touchscreen    触摸屏<br>设备类型还挺丰富的，好多普通人根本接触不到，哎，我就是普通人。</p>\n<h3 id=\"命令列表和默认设备类型\"><a href=\"#命令列表和默认设备类型\" class=\"headerlink\" title=\"命令列表和默认设备类型\"></a>命令列表和默认设备类型</h3><p>命令    默认设备类型    示例<br>text    touchscreen    input text “hello”<br>keyevent [–longpress]    keyboard    input keyevent 4<br>tap    touchscreen    input tap 500 500<br>swipe [duration(ms)]    touchscreen    input swipe 500 500 600 500 200<br>press    trackball    input press<br>roll    trackball    input roll 500 500<br>命令演练与解释<br>命令列表中，关于press和roll都是针对触控球的设备设计的，因为手中没有设备，而且这种设备现实中使用的比较少，所以就不做演示</p>\n<p>text<br>该命令用于模拟触摸屏的虚拟键盘输入字符串。</p>\n<p>比如，下面使用命令输入“hello”：</p>\n<p>HWVKY:/ $ input text hello</p>\n<p>text命令后面的字符都会以字符串的形式输入，如果恰好设备的焦点在一个可输入控件（通常为EditText）中，那么可输入控件中就会出现“hello”字样。</p>\n<p>如果命令执行后，“hello”并没有显示，请检查一下控件是否有限定输入类型。</p>\n<p>keyevent<br>该命令用以默认按键输入，对应的输入设备场景可能是遥控器、键盘等。</p>\n<p>例如，下面使用命令模拟遥控器的返回键：</p>\n<p>HWVKY:/ $ input keyevent 4</p>\n<p>命令执行后，设备中能很明显的看到有回退动作。命令中的参数“4”，对应的是keyevent中的返回键。下面列出部分常用keyevent事件的键值列表。</p>\n<p>Keyevent    value    备注<br>KEYCODE_BACK    4    返回键<br>KEYCODE_HOME    3    HOME键<br>KEYCODE_MENU    82    菜单键<br>KEYCODE_DPAD_UP    19    上<br>KEYCODE_DPAD_DOWN    20    下<br>KEYCODE_DPAD_LEFT    21    左<br>KEYCODE_DPAD_RIGHT    22    右<br>KEYCODE_DPAD_CENTER    23    OK键<br>KEYCODE_VOLUME_UP    24    音量+<br>KEYCODE_VOLUME_DOWN    25    音量-<br>如果列表中不满足你的需求，可以去android.view.KeyEvent.java中查看</p>\n<p>tap<br>该命令用于模拟触摸操作，感觉就是点击一下指定位置，可以让指定的点变相的获取焦点。</p>\n<p>例如，下面的命令，如果位于首页，500*500的坐标处恰好有一个应用图标，那么命令执行后，会打开该应用：</p>\n<figure class=\"highlight plain\"><figcaption><span>$ input tap 500 500```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">swipe</span><br><span class=\"line\">该命令用于模拟手势滑动操作</span><br><span class=\"line\"></span><br><span class=\"line\">例如，下面的命令模拟，从500*500的坐标滑动到600*500的位置：</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;HWVKY:&#x2F; $ input swipe 500 500 600 500</span><br></pre></td></tr></table></figure>\n\n<p>上边的命令执行后，屏幕瞬间就会滑动，那么我要慢慢的滑动怎么办呢，看下面的命令:</p>\n<figure class=\"highlight plain\"><figcaption><span>$ input swipe 500 500 600 500 500```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">两个命令的区别在于第二个多了一个参数，该参数表示该滑动需要执行的时长为500ms。</span><br><span class=\"line\"></span><br><span class=\"line\">值得一提的是，当参数中的两个坐标点使用一个点时，秒变长按事件：</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;HWVKY:&#x2F; $ input swipe 500 500 500 500 1000</span><br></pre></td></tr></table></figure>\n\n<p>该命令表示：长按坐标为500*500的点1秒钟。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"input\"><a href=\"#input\" class=\"headerlink\" title=\"input\"></a>input</h2><p>input是Android系统中的一个特殊的命令，用于模拟遥控器、键盘、鼠标的各种按键操作。我们都知道Android是阉割版本的Linux系统，Linux中很多命令在Android系统中是没有的。但是他们之间并没有包含的关系，Android系统中有些特有的东西（命令、属性）在Linux中也是没有的。","more":"</p>\n<h3 id=\"命令路径\"><a href=\"#命令路径\" class=\"headerlink\" title=\"命令路径\"></a>命令路径</h3><p>可以通过which 命令查看该命令的位置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">130|superli:&#x2F; # which -a input        </span><br><span class=\"line\">&#x2F;system&#x2F;bin&#x2F;input</span><br><span class=\"line\">superli:&#x2F; #</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"命令概要\"><a href=\"#命令概要\" class=\"headerlink\" title=\"命令概要\"></a>命令概要</h3><h4 id=\"Android-4-4以前\"><a href=\"#Android-4-4以前\" class=\"headerlink\" title=\"Android 4.4以前\"></a>Android 4.4以前</h4><p>使用help命令查看命令如何使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@hwH30-U10:&#x2F; # input --help</span><br><span class=\"line\">Error: Unknown command: --help</span><br><span class=\"line\">usage: input ...</span><br><span class=\"line\">       input text &lt;string&gt;</span><br><span class=\"line\">       input keyevent &lt;key code number or name&gt;</span><br><span class=\"line\">       input [touchscreen|touchpad] tap &lt;x&gt; &lt;y&gt;</span><br><span class=\"line\">       input [touchscreen|touchpad] swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt;</span><br><span class=\"line\">       input trackball press</span><br><span class=\"line\">       input trackball roll &lt;dx&gt; &lt;dy&gt;</span><br><span class=\"line\">root@hwH30-U10:&#x2F; #</span><br></pre></td></tr></table></figure>\n<h3 id=\"Android-4-4\"><a href=\"#Android-4-4\" class=\"headerlink\" title=\"Android 4.4+\"></a>Android 4.4+</h3><p>使用help命令查看命令如何使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">130|superli:&#x2F; # input --help</span><br><span class=\"line\">Error: Unknown command: --help  ## 未知命令？为什么会出现这个？？？算了，不重要，可能系统抽风了。</span><br><span class=\"line\">Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]</span><br><span class=\"line\"></span><br><span class=\"line\">The sources are: ##模拟的输入设备类型</span><br><span class=\"line\">      keyboard</span><br><span class=\"line\">      mouse</span><br><span class=\"line\">      joystick</span><br><span class=\"line\">      touchnavigation</span><br><span class=\"line\">      touchpad</span><br><span class=\"line\">      trackball</span><br><span class=\"line\">      dpad</span><br><span class=\"line\">      stylus</span><br><span class=\"line\">      gamepad</span><br><span class=\"line\">      touchscreen</span><br><span class=\"line\"></span><br><span class=\"line\">The commands and default sources are: ## 不指定source时，命令的默认输入设备类型为：</span><br><span class=\"line\">      text &lt;string&gt; (Default: touchscreen)</span><br><span class=\"line\">      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)</span><br><span class=\"line\">      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)</span><br><span class=\"line\">      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class=\"line\">      press (Default: trackball)</span><br><span class=\"line\">      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)</span><br><span class=\"line\">superli:&#x2F; #</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令解读和使用\"><a href=\"#命令解读和使用\" class=\"headerlink\" title=\"命令解读和使用\"></a>命令解读和使用</h3><p>后续内容主要分析Android 4.4+版本关于input命令的使用，当然4.4以前的版本也可以参考，毕竟差别并不是很大。</p>\n<p>命令格式：input [<source>] <command> [<arg>…]</p>\n<p>命令格式（中文版）：input [&lt;设备类型（可选）&gt;] &lt;命令&gt; [&lt;参数（可选）&gt;…]</p>\n<p>命令格式中可以看到有两个可选的部分：</p>\n<p>设备类型：设备类型不输入时，使用命令的默认设备类型。默认类型见下文。<br>参数：当命令没有参数时，可不输入（想了半天，想不出来什么命令不需要参数）</p>\n<h4 id=\"设备类型\"><a href=\"#设备类型\" class=\"headerlink\" title=\"设备类型\"></a>设备类型</h4><p>sources    模拟的输入设备类型<br>keyboard    键盘<br>mouse    鼠标<br>joystick    操纵杆（玩过游戏手柄的同学应该懂吧）<br>touchnavigation    ？？触摸导航？？<br>touchpad    触摸板<br>trackball    轨迹球（啥意思？）<br>dpad    什么鬼<br>stylus    触控笔（styluses）<br>gamepad    游戏手柄<br>touchscreen    触摸屏<br>设备类型还挺丰富的，好多普通人根本接触不到，哎，我就是普通人。</p>\n<h3 id=\"命令列表和默认设备类型\"><a href=\"#命令列表和默认设备类型\" class=\"headerlink\" title=\"命令列表和默认设备类型\"></a>命令列表和默认设备类型</h3><p>命令    默认设备类型    示例<br>text    touchscreen    input text “hello”<br>keyevent [–longpress]    keyboard    input keyevent 4<br>tap    touchscreen    input tap 500 500<br>swipe [duration(ms)]    touchscreen    input swipe 500 500 600 500 200<br>press    trackball    input press<br>roll    trackball    input roll 500 500<br>命令演练与解释<br>命令列表中，关于press和roll都是针对触控球的设备设计的，因为手中没有设备，而且这种设备现实中使用的比较少，所以就不做演示</p>\n<p>text<br>该命令用于模拟触摸屏的虚拟键盘输入字符串。</p>\n<p>比如，下面使用命令输入“hello”：</p>\n<p>HWVKY:/ $ input text hello</p>\n<p>text命令后面的字符都会以字符串的形式输入，如果恰好设备的焦点在一个可输入控件（通常为EditText）中，那么可输入控件中就会出现“hello”字样。</p>\n<p>如果命令执行后，“hello”并没有显示，请检查一下控件是否有限定输入类型。</p>\n<p>keyevent<br>该命令用以默认按键输入，对应的输入设备场景可能是遥控器、键盘等。</p>\n<p>例如，下面使用命令模拟遥控器的返回键：</p>\n<p>HWVKY:/ $ input keyevent 4</p>\n<p>命令执行后，设备中能很明显的看到有回退动作。命令中的参数“4”，对应的是keyevent中的返回键。下面列出部分常用keyevent事件的键值列表。</p>\n<p>Keyevent    value    备注<br>KEYCODE_BACK    4    返回键<br>KEYCODE_HOME    3    HOME键<br>KEYCODE_MENU    82    菜单键<br>KEYCODE_DPAD_UP    19    上<br>KEYCODE_DPAD_DOWN    20    下<br>KEYCODE_DPAD_LEFT    21    左<br>KEYCODE_DPAD_RIGHT    22    右<br>KEYCODE_DPAD_CENTER    23    OK键<br>KEYCODE_VOLUME_UP    24    音量+<br>KEYCODE_VOLUME_DOWN    25    音量-<br>如果列表中不满足你的需求，可以去android.view.KeyEvent.java中查看</p>\n<p>tap<br>该命令用于模拟触摸操作，感觉就是点击一下指定位置，可以让指定的点变相的获取焦点。</p>\n<p>例如，下面的命令，如果位于首页，500*500的坐标处恰好有一个应用图标，那么命令执行后，会打开该应用：</p>\n<figure class=\"highlight plain\"><figcaption><span>$ input tap 500 500```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">swipe</span><br><span class=\"line\">该命令用于模拟手势滑动操作</span><br><span class=\"line\"></span><br><span class=\"line\">例如，下面的命令模拟，从500*500的坐标滑动到600*500的位置：</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;HWVKY:&#x2F; $ input swipe 500 500 600 500</span><br></pre></td></tr></table></figure>\n\n<p>上边的命令执行后，屏幕瞬间就会滑动，那么我要慢慢的滑动怎么办呢，看下面的命令:</p>\n<figure class=\"highlight plain\"><figcaption><span>$ input swipe 500 500 600 500 500```</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">两个命令的区别在于第二个多了一个参数，该参数表示该滑动需要执行的时长为500ms。</span><br><span class=\"line\"></span><br><span class=\"line\">值得一提的是，当参数中的两个坐标点使用一个点时，秒变长按事件：</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;HWVKY:&#x2F; $ input swipe 500 500 500 500 1000</span><br></pre></td></tr></table></figure>\n\n<p>该命令表示：长按坐标为500*500的点1秒钟。</p>"},{"title":"【测试工具】是时候扔掉 Postman 了，Apifox 真香！","abbrlink":"de4de369","cover":"https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/9.png","date":"2021-12-14T14:56:17.000Z","_content":"\n> 作为开软件开发从业者，接口调试是必不可少的一项技能，我们经常使用 Postman 工具来进行接口调试，在接口调试方面 Postman 做的非常出色。但是在整个软件开发过程中，接口调试只是其中的一部分，还有很多事情 Postman 无法完成，或者无法高效完成，比如：接口文档定义、Mock 数据、接口自动化测试等等。 <!-- more --> \n\n需要 Apifox 功能介绍 PPT 版本的（可用于团队内部分享/推广 Apifox），可点击以下链接下载。\n[Apifox 功能介绍 ppt 格式](https://cdn3.apifox.cn/www/assets/ppt/Apifox介绍.pptx)\n[Apifox 功能介绍 pdf 格式](https://cdn3.apifox.cn/www/assets/ppt/Apifox介绍.pdf)\n\n## 接口管理现状\n\n### 一、常用解决方案\n\n1. 使用 Swagger 作为[接口文档工具](https://www.apifox.cn/)\n2. 使用 Postman 调试接口\n3. 使用 RAP 等工具 Mock 数据\n4. 使用 JMeter 做接口自动化测试\n\n### 二、存在的问题\n\n维护不同工具之间数据一致性非常困难、低效。并且这里不仅仅是工作量的问题，更大的问题是多个系统之间数据不一致，导致协作低效、频繁出问题，开发测试人员痛苦不堪。\n\n1. 开发人员在 Swagger 定义好文档后，接口调试的时候还需要去 Postman 再定义一遍。\n2. 前端开发 Mock 数据的时候又要去 RAP 定义一遍，还需要手动设置 Mock 规则。\n3. 测试人员需要去 JMeter 再定义一遍。\n4. 前端根据 RAP Mock 出来的数据开发完，后端根据 Swagger 定义的接口文档开发完，各自都试测试通过了，本以为可以马上上线，结果一对接发现各种问题：\n\n- 开发过程中接口变更了，只修改了 Swagger，但是没有及时同步修改 RAP。\n- 后端开发的接口数据类型和文档不一致，肉眼难以发现问题。\n\n\n\n1. 同样，测试在 JMeter 写好的测试用例，真正运行的时候也会发现各种不一致。\n2. 时间久了，各种不一致会越来越严重。\n\n## Apifox 解决方案\n\n### 一、如何解决这些问题\n\n### 1、Apifox 定位\n\n```\nApifox = Postman + Swagger + Mock + JMeter\n```\n\n通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好接口文档，接口调试、数据 Mock、接口测试就可以直接使用，无需再次定义；接口文档和接口开发调试使用同一个工具，接口调试完成后即可保证和接口文档定义完全一致。高效、及时、准确！\n\n### 2、Apifox 宗旨\n\n节省研发团队的每一分钟！\n\n### 3、Apifox 功能\n\n1. **接口设计**：Apifox 接口文档遵循 [OpenApi](https://openapi.apifox.cn/) 3.0 (原 Swagger)、[JSON Schema](https://json-schema.org/) 规范的同时，提供了非常好用的`可视化`文档管理功能，零学习成本，非常高效。并且支持在线分享接口文档。\n2. **数据模型**：可复用的数据结构，定义接口`返回数据结构`及`请求参数数据结构`（仅 JSON 和 XML 模式）时可直接引用。支持模型直接嵌套引用，直接 JSON/XML 智能导入，支持 oneOf、allOf 等高级组合模式。\n3. **接口调试**：Postman 有的功能，比如环境变量、前置/后置脚本、Cookie/Session 全局共享 等功能，Apifox 都有，并且比 Postman 更高效好用。接口运行完之后点击`保存为用例`按钮，即可生成`接口用例`，后续可直接运行接口用例，无需再输入参数，非常方便。自定义脚本 100% 兼容 Postman 语法，并且支持运行javascript、java、python、php、js、BeanShell、go、shell、ruby、lua等各种语言代码。\n4. **接口用例**：通常一个接口会有多种情况用例，比如`参数正确`用例、`参数错误`用例、`数据为空`用例、`不同数据状态`用例等等。运行接口用例时会自动校验数据正确性，用接口用例来调试接口非常高效。\n5. **接口数据 Mock**：内置 [Mock.js](http://mockjs.com/) 规则引擎，非常方便 mock 出各种数据，并且可以在定义数据结构的同时写好 mock 规则。支持添加“期望”，根据请求参数返回不同 mock 数据。最重要的是 Apifox `零配置` 即可 Mock 出非常人性化的数据，具体在本文后面介绍。\n6. **接口自动化测试**：提供接口集合测试，可以通过选择接口（或接口用例）快速创建测试集。目前接口自动化测试更多功能还在开发中，敬请期待！目标是： JMeter 有的功能基本都会有，并且要更好用。\n7. **数据库操作**：支持读取数据库数据，作为接口请求参数使用。支持读取数据库数据，用来校验(断言)接口请求是否成功。\n8. **快捷调试**：类似 Postman 的接口调试方式，主要用途为临时调试一些`无需文档化`的接口，无需提前定义接口即可快速调试。\n9. **代码生成**：根据接口及数据数据模型定义，系统自动生成`接口请求代码`、`前端业务代码`及`后端业务代码`。\n10. **团队协作**：Apifox 天生就是为团队协作而生的，接口云端实时同步更新，成熟的`团队/项目/成员权限`管理，满足各类企业的需求。\n\n### 二、Apifox 做的不仅仅是数据打通\n\n如果你认为 Apifox 只做了数据打通，来提升研发团队的效率，那就错了。Apifox 还做了非常多的创新，来提升开发人员的效率。\n\n### 1、接口支持“用例管理”\n\n通常一个接口会有多种情况用例，比如 `正确用例` `参数错误用例` `数据为空用例` `不同数据状态用例`。定义接口的时候定义好这些不同状态的用例，接口调试的时候直接运行，非常高效。\n\n### 2、“数据模型”定义、引用\n\n可以独立定义数据模型，接口定义时可以直接引用数据模型，数据模型之间也可以相互引用。同样的数据结构，只需要定义一次即可多处使用；修改的时候只需要修改一处，多处实时更新，避免不一致。\n\n### 3、调试时“自动校验”数据结构\n\n使用 Apifox 调试接口的时候，系统会根据接口文档里的定义，自动校验返回的数据结构是否正确，无需通过肉识别，也无需手动写断言脚本检测，非常高效！\n\n\n\n![img](https://pic3.zhimg.com/v2-84b60639898cf51fd75bb557e615a5d2_r.jpg)\n\n\n\n### 4、“可视化”设置断言\n\n设置断言：\n\n\n\n![img](https://pic4.zhimg.com/v2-09c5c04497eabbe8be8617ce8f12ea97_r.jpg)\n\n\n\n运行后，查看断言结果：\n\n\n\n![img](https://pic1.zhimg.com/v2-93c6ad02f0fb83ced91aaddab5299204_r.jpg)\n\n\n\n### 5、“可视化”设置提取变量\n\n\n\n![img](https://pic2.zhimg.com/v2-e1bfaee9f4a6b935db7f354255dc9c5d_r.jpg)\n\n\n\n### 6、支持数据库操作\n\n\n\n![img](https://pic1.zhimg.com/v2-07fcb7adc6b2e157b26c244b5c930b6c_r.jpg)\n\n\n\n### 7、“零配置”Mock 出非常人性化的数据\n\n先放一张图对比下 Apifox 和其他同类工具 `零配置` mock 出来的数据效果：\n\n\n\n![img](https://pic1.zhimg.com/v2-cf3012a053f55cf2ecd84871c4db4394_r.jpg)\n\n\n\n可以看出 Apifox `零配置` Mock 出来的数据和真实情况是非常接近的，前端开发可以直接使用，而无需再手动写 mock 规则。\n\n**Apifox 如何做到`高效率`、`零配置`生成非常人性化的 mock 数据**\n\n1. Apifox 根据接口定义里的数据结构、数据类型，自动生成 mock 规则。\n2. Apifox 内置智能 mock 规则库，根据字段名、字段数据类型，智能优化自动生成的 mock 规则。如：名称包含字符串`image`的`string`类型字段，自动 mock 出一个图片地址 URL；包含字符串`time`的`string`类型字段，自动 mock 出一个时间字符串；包含字符串`city`的`string`类型字段，自动 mock 出一个城市名。\n3. Apifox 根据内置规则，可自动识别出图片、头像、用户名、手机号、网址、日期、时间、时间戳、邮箱、省份、城市、地址、IP 等字段，从而 Mock 出非常人性化的数据。\n4. 除了内置 mock 规则，用户还可以自定义规则库，满足各种个性化需求。支持使用 `正则表达式`、`通配符` 来匹配字段名自定义 mock 规则。\n\n### 8、代码自动生成\n\n根据接口模型定义，自动生成各种语言/框架（如 TypeScript、Java、Go、Swift、ObjectiveC、Kotlin、Dart、C++、C#、Rust 等）的业务代码（如 Model、Controller、单元测试代码等）和接口请求代码。目前 Apifox 支持 130 种语言及框架的代码自动生成。\n\n更重要的是：你可以通过`自定义代码模板`来生成符合自己团队的架构规范的代码，满足各种个性化的需求。\n\n### 9、导入、导出\n\n1. 支持导出 `OpenApi (Swagger)`、`Markdown`、`Html` 等数据格式，因为可以导出`OpenApi`格式数据，所以你可以利用 OpenApi (Swagger) 丰富的生态工具完成各种接口相关的事情。\n2. 支持导入 `OpenApi (Swagger)`、`Postman`、`HAR`、`RAML`、`RAP2`、`YApi`、`Eolinker`、`NEI`、`DOClever`、`ApiPost` 、`Apizza` 、`ShowDoc`、`API Blueprint`、`I/O Docs`、`WADL`、`Google Discovery`等数据格式，方便旧项目迁移。\n\n### 三、后续功能规划\n\n1. 接口文档公开对外发布。\n2. 接口性能测试支持（类似 JMeter）。\n3. 支持插件市场，可以自己开发插件。\n4. 支持更多接口协议，如`GraphQL`、`websocket`等。\n5. 支持离线使用，项目可选择在线同步（团队协作）还是仅本地存储（单机离线使用）。\n\n### 四、更多 Apifox 功能截图\n\n\n\n![img](https://pic3.zhimg.com/v2-cb29c171a62fec7792e09d4dea5601e2_r.jpg)\n\n![img](https://pic4.zhimg.com/v2-b8a6e673775dead99fb7bf55fa3675e3_r.jpg)\n\n![img](https://pic4.zhimg.com/v2-c0d31e348ca6fb205222ad5dbf95d9ab_r.jpg)\n\n![img](https://pic3.zhimg.com/v2-a5f3fe99fd6deae3d00a107b8444d506_r.jpg)\n\n![img](https://pic3.zhimg.com/v2-ea0e973c7134c19edbf2b80ef2fcf05a_r.jpg)\n\n![img](https://pic4.zhimg.com/v2-b8c20d0818b3c7bef56137cb2e2cb2fb_r.jpg)\n\n![img](https://pic2.zhimg.com/v2-5ac1da128a350111cfcbf47ab2f60b59_r.jpg)\n\n![img](https://pic3.zhimg.com/v2-6ef28c655835d5c8c98723c1c9d41f1a_r.jpg)\n\n![img](https://pic1.zhimg.com/v2-fb6a6c2696b5e07015a071f480673854_r.jpg)\n\n![img](https://pic1.zhimg.com/v2-eb8c27f09926a8dbe448c63d8d57ef74_r.jpg)\n\n![img](https://pic1.zhimg.com/v2-149c5990e064bd371d3ea283a2d420d0_r.jpg)\n\n![img](https://pic2.zhimg.com/v2-53926e1ca0884baed2c9ab20bed12bed_r.jpg)\n\n\n\n\n\n![img](https://pic4.zhimg.com/v2-1dc4db7aa4ffcee95888c84da74812cf_r.jpg)\n\n![img](https://pic3.zhimg.com/v2-ae3f1d1e3eba65908c843b238dbf728a_r.jpg)\n\n![img](https://pic3.zhimg.com/v2-199dc8a814c5cbd2b6c603fb96589db6_r.jpg)\n\n![img](https://pic1.zhimg.com/v2-c95173613dd345831e9fc8a9e96b3624_r.jpg)\n\n![img](https://pic2.zhimg.com/v2-f5d96e21a55bf995f3d003bf09b2947d_r.jpg)\n\n\n\n### 五、 Apifox 下载地址\n\n请访问 Apifox 官网下载：[https://www.apifox.cn/](https://www.apifox.cn/?utm_source=zhihu&utm_medium=article_10001&utm_content=377387530)\n","source":"_posts/2021.12/【测试工具】是时候扔掉 Postman 了，Apifox 真香！.md","raw":"---\ntitle: 【测试工具】是时候扔掉 Postman 了，Apifox 真香！\nabbrlink: de4de369\ncover: https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/9.png\ndate: 2021-12-14 22:56:17\ntags:\n---\n\n> 作为开软件开发从业者，接口调试是必不可少的一项技能，我们经常使用 Postman 工具来进行接口调试，在接口调试方面 Postman 做的非常出色。但是在整个软件开发过程中，接口调试只是其中的一部分，还有很多事情 Postman 无法完成，或者无法高效完成，比如：接口文档定义、Mock 数据、接口自动化测试等等。 <!-- more --> \n\n需要 Apifox 功能介绍 PPT 版本的（可用于团队内部分享/推广 Apifox），可点击以下链接下载。\n[Apifox 功能介绍 ppt 格式](https://cdn3.apifox.cn/www/assets/ppt/Apifox介绍.pptx)\n[Apifox 功能介绍 pdf 格式](https://cdn3.apifox.cn/www/assets/ppt/Apifox介绍.pdf)\n\n## 接口管理现状\n\n### 一、常用解决方案\n\n1. 使用 Swagger 作为[接口文档工具](https://www.apifox.cn/)\n2. 使用 Postman 调试接口\n3. 使用 RAP 等工具 Mock 数据\n4. 使用 JMeter 做接口自动化测试\n\n### 二、存在的问题\n\n维护不同工具之间数据一致性非常困难、低效。并且这里不仅仅是工作量的问题，更大的问题是多个系统之间数据不一致，导致协作低效、频繁出问题，开发测试人员痛苦不堪。\n\n1. 开发人员在 Swagger 定义好文档后，接口调试的时候还需要去 Postman 再定义一遍。\n2. 前端开发 Mock 数据的时候又要去 RAP 定义一遍，还需要手动设置 Mock 规则。\n3. 测试人员需要去 JMeter 再定义一遍。\n4. 前端根据 RAP Mock 出来的数据开发完，后端根据 Swagger 定义的接口文档开发完，各自都试测试通过了，本以为可以马上上线，结果一对接发现各种问题：\n\n- 开发过程中接口变更了，只修改了 Swagger，但是没有及时同步修改 RAP。\n- 后端开发的接口数据类型和文档不一致，肉眼难以发现问题。\n\n\n\n1. 同样，测试在 JMeter 写好的测试用例，真正运行的时候也会发现各种不一致。\n2. 时间久了，各种不一致会越来越严重。\n\n## Apifox 解决方案\n\n### 一、如何解决这些问题\n\n### 1、Apifox 定位\n\n```\nApifox = Postman + Swagger + Mock + JMeter\n```\n\n通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好接口文档，接口调试、数据 Mock、接口测试就可以直接使用，无需再次定义；接口文档和接口开发调试使用同一个工具，接口调试完成后即可保证和接口文档定义完全一致。高效、及时、准确！\n\n### 2、Apifox 宗旨\n\n节省研发团队的每一分钟！\n\n### 3、Apifox 功能\n\n1. **接口设计**：Apifox 接口文档遵循 [OpenApi](https://openapi.apifox.cn/) 3.0 (原 Swagger)、[JSON Schema](https://json-schema.org/) 规范的同时，提供了非常好用的`可视化`文档管理功能，零学习成本，非常高效。并且支持在线分享接口文档。\n2. **数据模型**：可复用的数据结构，定义接口`返回数据结构`及`请求参数数据结构`（仅 JSON 和 XML 模式）时可直接引用。支持模型直接嵌套引用，直接 JSON/XML 智能导入，支持 oneOf、allOf 等高级组合模式。\n3. **接口调试**：Postman 有的功能，比如环境变量、前置/后置脚本、Cookie/Session 全局共享 等功能，Apifox 都有，并且比 Postman 更高效好用。接口运行完之后点击`保存为用例`按钮，即可生成`接口用例`，后续可直接运行接口用例，无需再输入参数，非常方便。自定义脚本 100% 兼容 Postman 语法，并且支持运行javascript、java、python、php、js、BeanShell、go、shell、ruby、lua等各种语言代码。\n4. **接口用例**：通常一个接口会有多种情况用例，比如`参数正确`用例、`参数错误`用例、`数据为空`用例、`不同数据状态`用例等等。运行接口用例时会自动校验数据正确性，用接口用例来调试接口非常高效。\n5. **接口数据 Mock**：内置 [Mock.js](http://mockjs.com/) 规则引擎，非常方便 mock 出各种数据，并且可以在定义数据结构的同时写好 mock 规则。支持添加“期望”，根据请求参数返回不同 mock 数据。最重要的是 Apifox `零配置` 即可 Mock 出非常人性化的数据，具体在本文后面介绍。\n6. **接口自动化测试**：提供接口集合测试，可以通过选择接口（或接口用例）快速创建测试集。目前接口自动化测试更多功能还在开发中，敬请期待！目标是： JMeter 有的功能基本都会有，并且要更好用。\n7. **数据库操作**：支持读取数据库数据，作为接口请求参数使用。支持读取数据库数据，用来校验(断言)接口请求是否成功。\n8. **快捷调试**：类似 Postman 的接口调试方式，主要用途为临时调试一些`无需文档化`的接口，无需提前定义接口即可快速调试。\n9. **代码生成**：根据接口及数据数据模型定义，系统自动生成`接口请求代码`、`前端业务代码`及`后端业务代码`。\n10. **团队协作**：Apifox 天生就是为团队协作而生的，接口云端实时同步更新，成熟的`团队/项目/成员权限`管理，满足各类企业的需求。\n\n### 二、Apifox 做的不仅仅是数据打通\n\n如果你认为 Apifox 只做了数据打通，来提升研发团队的效率，那就错了。Apifox 还做了非常多的创新，来提升开发人员的效率。\n\n### 1、接口支持“用例管理”\n\n通常一个接口会有多种情况用例，比如 `正确用例` `参数错误用例` `数据为空用例` `不同数据状态用例`。定义接口的时候定义好这些不同状态的用例，接口调试的时候直接运行，非常高效。\n\n### 2、“数据模型”定义、引用\n\n可以独立定义数据模型，接口定义时可以直接引用数据模型，数据模型之间也可以相互引用。同样的数据结构，只需要定义一次即可多处使用；修改的时候只需要修改一处，多处实时更新，避免不一致。\n\n### 3、调试时“自动校验”数据结构\n\n使用 Apifox 调试接口的时候，系统会根据接口文档里的定义，自动校验返回的数据结构是否正确，无需通过肉识别，也无需手动写断言脚本检测，非常高效！\n\n\n\n![img](https://pic3.zhimg.com/v2-84b60639898cf51fd75bb557e615a5d2_r.jpg)\n\n\n\n### 4、“可视化”设置断言\n\n设置断言：\n\n\n\n![img](https://pic4.zhimg.com/v2-09c5c04497eabbe8be8617ce8f12ea97_r.jpg)\n\n\n\n运行后，查看断言结果：\n\n\n\n![img](https://pic1.zhimg.com/v2-93c6ad02f0fb83ced91aaddab5299204_r.jpg)\n\n\n\n### 5、“可视化”设置提取变量\n\n\n\n![img](https://pic2.zhimg.com/v2-e1bfaee9f4a6b935db7f354255dc9c5d_r.jpg)\n\n\n\n### 6、支持数据库操作\n\n\n\n![img](https://pic1.zhimg.com/v2-07fcb7adc6b2e157b26c244b5c930b6c_r.jpg)\n\n\n\n### 7、“零配置”Mock 出非常人性化的数据\n\n先放一张图对比下 Apifox 和其他同类工具 `零配置` mock 出来的数据效果：\n\n\n\n![img](https://pic1.zhimg.com/v2-cf3012a053f55cf2ecd84871c4db4394_r.jpg)\n\n\n\n可以看出 Apifox `零配置` Mock 出来的数据和真实情况是非常接近的，前端开发可以直接使用，而无需再手动写 mock 规则。\n\n**Apifox 如何做到`高效率`、`零配置`生成非常人性化的 mock 数据**\n\n1. Apifox 根据接口定义里的数据结构、数据类型，自动生成 mock 规则。\n2. Apifox 内置智能 mock 规则库，根据字段名、字段数据类型，智能优化自动生成的 mock 规则。如：名称包含字符串`image`的`string`类型字段，自动 mock 出一个图片地址 URL；包含字符串`time`的`string`类型字段，自动 mock 出一个时间字符串；包含字符串`city`的`string`类型字段，自动 mock 出一个城市名。\n3. Apifox 根据内置规则，可自动识别出图片、头像、用户名、手机号、网址、日期、时间、时间戳、邮箱、省份、城市、地址、IP 等字段，从而 Mock 出非常人性化的数据。\n4. 除了内置 mock 规则，用户还可以自定义规则库，满足各种个性化需求。支持使用 `正则表达式`、`通配符` 来匹配字段名自定义 mock 规则。\n\n### 8、代码自动生成\n\n根据接口模型定义，自动生成各种语言/框架（如 TypeScript、Java、Go、Swift、ObjectiveC、Kotlin、Dart、C++、C#、Rust 等）的业务代码（如 Model、Controller、单元测试代码等）和接口请求代码。目前 Apifox 支持 130 种语言及框架的代码自动生成。\n\n更重要的是：你可以通过`自定义代码模板`来生成符合自己团队的架构规范的代码，满足各种个性化的需求。\n\n### 9、导入、导出\n\n1. 支持导出 `OpenApi (Swagger)`、`Markdown`、`Html` 等数据格式，因为可以导出`OpenApi`格式数据，所以你可以利用 OpenApi (Swagger) 丰富的生态工具完成各种接口相关的事情。\n2. 支持导入 `OpenApi (Swagger)`、`Postman`、`HAR`、`RAML`、`RAP2`、`YApi`、`Eolinker`、`NEI`、`DOClever`、`ApiPost` 、`Apizza` 、`ShowDoc`、`API Blueprint`、`I/O Docs`、`WADL`、`Google Discovery`等数据格式，方便旧项目迁移。\n\n### 三、后续功能规划\n\n1. 接口文档公开对外发布。\n2. 接口性能测试支持（类似 JMeter）。\n3. 支持插件市场，可以自己开发插件。\n4. 支持更多接口协议，如`GraphQL`、`websocket`等。\n5. 支持离线使用，项目可选择在线同步（团队协作）还是仅本地存储（单机离线使用）。\n\n### 四、更多 Apifox 功能截图\n\n\n\n![img](https://pic3.zhimg.com/v2-cb29c171a62fec7792e09d4dea5601e2_r.jpg)\n\n![img](https://pic4.zhimg.com/v2-b8a6e673775dead99fb7bf55fa3675e3_r.jpg)\n\n![img](https://pic4.zhimg.com/v2-c0d31e348ca6fb205222ad5dbf95d9ab_r.jpg)\n\n![img](https://pic3.zhimg.com/v2-a5f3fe99fd6deae3d00a107b8444d506_r.jpg)\n\n![img](https://pic3.zhimg.com/v2-ea0e973c7134c19edbf2b80ef2fcf05a_r.jpg)\n\n![img](https://pic4.zhimg.com/v2-b8c20d0818b3c7bef56137cb2e2cb2fb_r.jpg)\n\n![img](https://pic2.zhimg.com/v2-5ac1da128a350111cfcbf47ab2f60b59_r.jpg)\n\n![img](https://pic3.zhimg.com/v2-6ef28c655835d5c8c98723c1c9d41f1a_r.jpg)\n\n![img](https://pic1.zhimg.com/v2-fb6a6c2696b5e07015a071f480673854_r.jpg)\n\n![img](https://pic1.zhimg.com/v2-eb8c27f09926a8dbe448c63d8d57ef74_r.jpg)\n\n![img](https://pic1.zhimg.com/v2-149c5990e064bd371d3ea283a2d420d0_r.jpg)\n\n![img](https://pic2.zhimg.com/v2-53926e1ca0884baed2c9ab20bed12bed_r.jpg)\n\n\n\n\n\n![img](https://pic4.zhimg.com/v2-1dc4db7aa4ffcee95888c84da74812cf_r.jpg)\n\n![img](https://pic3.zhimg.com/v2-ae3f1d1e3eba65908c843b238dbf728a_r.jpg)\n\n![img](https://pic3.zhimg.com/v2-199dc8a814c5cbd2b6c603fb96589db6_r.jpg)\n\n![img](https://pic1.zhimg.com/v2-c95173613dd345831e9fc8a9e96b3624_r.jpg)\n\n![img](https://pic2.zhimg.com/v2-f5d96e21a55bf995f3d003bf09b2947d_r.jpg)\n\n\n\n### 五、 Apifox 下载地址\n\n请访问 Apifox 官网下载：[https://www.apifox.cn/](https://www.apifox.cn/?utm_source=zhihu&utm_medium=article_10001&utm_content=377387530)\n","slug":"2021.12/【测试工具】是时候扔掉 Postman 了，Apifox 真香！","published":1,"updated":"2021-12-14T14:56:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wm000rn4ep76gh9g2a","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>作为开软件开发从业者，接口调试是必不可少的一项技能，我们经常使用 Postman 工具来进行接口调试，在接口调试方面 Postman 做的非常出色。但是在整个软件开发过程中，接口调试只是其中的一部分，还有很多事情 Postman 无法完成，或者无法高效完成，比如：接口文档定义、Mock 数据、接口自动化测试等等。 <a id=\"more\"></a> </p>\n</blockquote>\n<p>需要 Apifox 功能介绍 PPT 版本的（可用于团队内部分享/推广 Apifox），可点击以下链接下载。<br><a href=\"https://cdn3.apifox.cn/www/assets/ppt/Apifox介绍.pptx\" target=\"_blank\" rel=\"noopener\">Apifox 功能介绍 ppt 格式</a><br><a href=\"https://cdn3.apifox.cn/www/assets/ppt/Apifox介绍.pdf\" target=\"_blank\" rel=\"noopener\">Apifox 功能介绍 pdf 格式</a></p>\n<h2 id=\"接口管理现状\"><a href=\"#接口管理现状\" class=\"headerlink\" title=\"接口管理现状\"></a>接口管理现状</h2><h3 id=\"一、常用解决方案\"><a href=\"#一、常用解决方案\" class=\"headerlink\" title=\"一、常用解决方案\"></a>一、常用解决方案</h3><ol>\n<li>使用 Swagger 作为<a href=\"https://www.apifox.cn/\" target=\"_blank\" rel=\"noopener\">接口文档工具</a></li>\n<li>使用 Postman 调试接口</li>\n<li>使用 RAP 等工具 Mock 数据</li>\n<li>使用 JMeter 做接口自动化测试</li>\n</ol>\n<h3 id=\"二、存在的问题\"><a href=\"#二、存在的问题\" class=\"headerlink\" title=\"二、存在的问题\"></a>二、存在的问题</h3><p>维护不同工具之间数据一致性非常困难、低效。并且这里不仅仅是工作量的问题，更大的问题是多个系统之间数据不一致，导致协作低效、频繁出问题，开发测试人员痛苦不堪。</p>\n<ol>\n<li>开发人员在 Swagger 定义好文档后，接口调试的时候还需要去 Postman 再定义一遍。</li>\n<li>前端开发 Mock 数据的时候又要去 RAP 定义一遍，还需要手动设置 Mock 规则。</li>\n<li>测试人员需要去 JMeter 再定义一遍。</li>\n<li>前端根据 RAP Mock 出来的数据开发完，后端根据 Swagger 定义的接口文档开发完，各自都试测试通过了，本以为可以马上上线，结果一对接发现各种问题：</li>\n</ol>\n<ul>\n<li>开发过程中接口变更了，只修改了 Swagger，但是没有及时同步修改 RAP。</li>\n<li>后端开发的接口数据类型和文档不一致，肉眼难以发现问题。</li>\n</ul>\n<ol>\n<li>同样，测试在 JMeter 写好的测试用例，真正运行的时候也会发现各种不一致。</li>\n<li>时间久了，各种不一致会越来越严重。</li>\n</ol>\n<h2 id=\"Apifox-解决方案\"><a href=\"#Apifox-解决方案\" class=\"headerlink\" title=\"Apifox 解决方案\"></a>Apifox 解决方案</h2><h3 id=\"一、如何解决这些问题\"><a href=\"#一、如何解决这些问题\" class=\"headerlink\" title=\"一、如何解决这些问题\"></a>一、如何解决这些问题</h3><h3 id=\"1、Apifox-定位\"><a href=\"#1、Apifox-定位\" class=\"headerlink\" title=\"1、Apifox 定位\"></a>1、Apifox 定位</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Apifox &#x3D; Postman + Swagger + Mock + JMeter</span><br></pre></td></tr></table></figure>\n\n<p>通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好接口文档，接口调试、数据 Mock、接口测试就可以直接使用，无需再次定义；接口文档和接口开发调试使用同一个工具，接口调试完成后即可保证和接口文档定义完全一致。高效、及时、准确！</p>\n<h3 id=\"2、Apifox-宗旨\"><a href=\"#2、Apifox-宗旨\" class=\"headerlink\" title=\"2、Apifox 宗旨\"></a>2、Apifox 宗旨</h3><p>节省研发团队的每一分钟！</p>\n<h3 id=\"3、Apifox-功能\"><a href=\"#3、Apifox-功能\" class=\"headerlink\" title=\"3、Apifox 功能\"></a>3、Apifox 功能</h3><ol>\n<li><strong>接口设计</strong>：Apifox 接口文档遵循 <a href=\"https://openapi.apifox.cn/\" target=\"_blank\" rel=\"noopener\">OpenApi</a> 3.0 (原 Swagger)、<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON Schema</a> 规范的同时，提供了非常好用的<code>可视化</code>文档管理功能，零学习成本，非常高效。并且支持在线分享接口文档。</li>\n<li><strong>数据模型</strong>：可复用的数据结构，定义接口<code>返回数据结构</code>及<code>请求参数数据结构</code>（仅 JSON 和 XML 模式）时可直接引用。支持模型直接嵌套引用，直接 JSON/XML 智能导入，支持 oneOf、allOf 等高级组合模式。</li>\n<li><strong>接口调试</strong>：Postman 有的功能，比如环境变量、前置/后置脚本、Cookie/Session 全局共享 等功能，Apifox 都有，并且比 Postman 更高效好用。接口运行完之后点击<code>保存为用例</code>按钮，即可生成<code>接口用例</code>，后续可直接运行接口用例，无需再输入参数，非常方便。自定义脚本 100% 兼容 Postman 语法，并且支持运行javascript、java、python、php、js、BeanShell、go、shell、ruby、lua等各种语言代码。</li>\n<li><strong>接口用例</strong>：通常一个接口会有多种情况用例，比如<code>参数正确</code>用例、<code>参数错误</code>用例、<code>数据为空</code>用例、<code>不同数据状态</code>用例等等。运行接口用例时会自动校验数据正确性，用接口用例来调试接口非常高效。</li>\n<li><strong>接口数据 Mock</strong>：内置 <a href=\"http://mockjs.com/\" target=\"_blank\" rel=\"noopener\">Mock.js</a> 规则引擎，非常方便 mock 出各种数据，并且可以在定义数据结构的同时写好 mock 规则。支持添加“期望”，根据请求参数返回不同 mock 数据。最重要的是 Apifox <code>零配置</code> 即可 Mock 出非常人性化的数据，具体在本文后面介绍。</li>\n<li><strong>接口自动化测试</strong>：提供接口集合测试，可以通过选择接口（或接口用例）快速创建测试集。目前接口自动化测试更多功能还在开发中，敬请期待！目标是： JMeter 有的功能基本都会有，并且要更好用。</li>\n<li><strong>数据库操作</strong>：支持读取数据库数据，作为接口请求参数使用。支持读取数据库数据，用来校验(断言)接口请求是否成功。</li>\n<li><strong>快捷调试</strong>：类似 Postman 的接口调试方式，主要用途为临时调试一些<code>无需文档化</code>的接口，无需提前定义接口即可快速调试。</li>\n<li><strong>代码生成</strong>：根据接口及数据数据模型定义，系统自动生成<code>接口请求代码</code>、<code>前端业务代码</code>及<code>后端业务代码</code>。</li>\n<li><strong>团队协作</strong>：Apifox 天生就是为团队协作而生的，接口云端实时同步更新，成熟的<code>团队/项目/成员权限</code>管理，满足各类企业的需求。</li>\n</ol>\n<h3 id=\"二、Apifox-做的不仅仅是数据打通\"><a href=\"#二、Apifox-做的不仅仅是数据打通\" class=\"headerlink\" title=\"二、Apifox 做的不仅仅是数据打通\"></a>二、Apifox 做的不仅仅是数据打通</h3><p>如果你认为 Apifox 只做了数据打通，来提升研发团队的效率，那就错了。Apifox 还做了非常多的创新，来提升开发人员的效率。</p>\n<h3 id=\"1、接口支持“用例管理”\"><a href=\"#1、接口支持“用例管理”\" class=\"headerlink\" title=\"1、接口支持“用例管理”\"></a>1、接口支持“用例管理”</h3><p>通常一个接口会有多种情况用例，比如 <code>正确用例</code> <code>参数错误用例</code> <code>数据为空用例</code> <code>不同数据状态用例</code>。定义接口的时候定义好这些不同状态的用例，接口调试的时候直接运行，非常高效。</p>\n<h3 id=\"2、“数据模型”定义、引用\"><a href=\"#2、“数据模型”定义、引用\" class=\"headerlink\" title=\"2、“数据模型”定义、引用\"></a>2、“数据模型”定义、引用</h3><p>可以独立定义数据模型，接口定义时可以直接引用数据模型，数据模型之间也可以相互引用。同样的数据结构，只需要定义一次即可多处使用；修改的时候只需要修改一处，多处实时更新，避免不一致。</p>\n<h3 id=\"3、调试时“自动校验”数据结构\"><a href=\"#3、调试时“自动校验”数据结构\" class=\"headerlink\" title=\"3、调试时“自动校验”数据结构\"></a>3、调试时“自动校验”数据结构</h3><p>使用 Apifox 调试接口的时候，系统会根据接口文档里的定义，自动校验返回的数据结构是否正确，无需通过肉识别，也无需手动写断言脚本检测，非常高效！</p>\n<p><img src=\"https://pic3.zhimg.com/v2-84b60639898cf51fd75bb557e615a5d2_r.jpg\" alt=\"img\"></p>\n<h3 id=\"4、“可视化”设置断言\"><a href=\"#4、“可视化”设置断言\" class=\"headerlink\" title=\"4、“可视化”设置断言\"></a>4、“可视化”设置断言</h3><p>设置断言：</p>\n<p><img src=\"https://pic4.zhimg.com/v2-09c5c04497eabbe8be8617ce8f12ea97_r.jpg\" alt=\"img\"></p>\n<p>运行后，查看断言结果：</p>\n<p><img src=\"https://pic1.zhimg.com/v2-93c6ad02f0fb83ced91aaddab5299204_r.jpg\" alt=\"img\"></p>\n<h3 id=\"5、“可视化”设置提取变量\"><a href=\"#5、“可视化”设置提取变量\" class=\"headerlink\" title=\"5、“可视化”设置提取变量\"></a>5、“可视化”设置提取变量</h3><p><img src=\"https://pic2.zhimg.com/v2-e1bfaee9f4a6b935db7f354255dc9c5d_r.jpg\" alt=\"img\"></p>\n<h3 id=\"6、支持数据库操作\"><a href=\"#6、支持数据库操作\" class=\"headerlink\" title=\"6、支持数据库操作\"></a>6、支持数据库操作</h3><p><img src=\"https://pic1.zhimg.com/v2-07fcb7adc6b2e157b26c244b5c930b6c_r.jpg\" alt=\"img\"></p>\n<h3 id=\"7、“零配置”Mock-出非常人性化的数据\"><a href=\"#7、“零配置”Mock-出非常人性化的数据\" class=\"headerlink\" title=\"7、“零配置”Mock 出非常人性化的数据\"></a>7、“零配置”Mock 出非常人性化的数据</h3><p>先放一张图对比下 Apifox 和其他同类工具 <code>零配置</code> mock 出来的数据效果：</p>\n<p><img src=\"https://pic1.zhimg.com/v2-cf3012a053f55cf2ecd84871c4db4394_r.jpg\" alt=\"img\"></p>\n<p>可以看出 Apifox <code>零配置</code> Mock 出来的数据和真实情况是非常接近的，前端开发可以直接使用，而无需再手动写 mock 规则。</p>\n<p><strong>Apifox 如何做到<code>高效率</code>、<code>零配置</code>生成非常人性化的 mock 数据</strong></p>\n<ol>\n<li>Apifox 根据接口定义里的数据结构、数据类型，自动生成 mock 规则。</li>\n<li>Apifox 内置智能 mock 规则库，根据字段名、字段数据类型，智能优化自动生成的 mock 规则。如：名称包含字符串<code>image</code>的<code>string</code>类型字段，自动 mock 出一个图片地址 URL；包含字符串<code>time</code>的<code>string</code>类型字段，自动 mock 出一个时间字符串；包含字符串<code>city</code>的<code>string</code>类型字段，自动 mock 出一个城市名。</li>\n<li>Apifox 根据内置规则，可自动识别出图片、头像、用户名、手机号、网址、日期、时间、时间戳、邮箱、省份、城市、地址、IP 等字段，从而 Mock 出非常人性化的数据。</li>\n<li>除了内置 mock 规则，用户还可以自定义规则库，满足各种个性化需求。支持使用 <code>正则表达式</code>、<code>通配符</code> 来匹配字段名自定义 mock 规则。</li>\n</ol>\n<h3 id=\"8、代码自动生成\"><a href=\"#8、代码自动生成\" class=\"headerlink\" title=\"8、代码自动生成\"></a>8、代码自动生成</h3><p>根据接口模型定义，自动生成各种语言/框架（如 TypeScript、Java、Go、Swift、ObjectiveC、Kotlin、Dart、C++、C#、Rust 等）的业务代码（如 Model、Controller、单元测试代码等）和接口请求代码。目前 Apifox 支持 130 种语言及框架的代码自动生成。</p>\n<p>更重要的是：你可以通过<code>自定义代码模板</code>来生成符合自己团队的架构规范的代码，满足各种个性化的需求。</p>\n<h3 id=\"9、导入、导出\"><a href=\"#9、导入、导出\" class=\"headerlink\" title=\"9、导入、导出\"></a>9、导入、导出</h3><ol>\n<li>支持导出 <code>OpenApi (Swagger)</code>、<code>Markdown</code>、<code>Html</code> 等数据格式，因为可以导出<code>OpenApi</code>格式数据，所以你可以利用 OpenApi (Swagger) 丰富的生态工具完成各种接口相关的事情。</li>\n<li>支持导入 <code>OpenApi (Swagger)</code>、<code>Postman</code>、<code>HAR</code>、<code>RAML</code>、<code>RAP2</code>、<code>YApi</code>、<code>Eolinker</code>、<code>NEI</code>、<code>DOClever</code>、<code>ApiPost</code> 、<code>Apizza</code> 、<code>ShowDoc</code>、<code>API Blueprint</code>、<code>I/O Docs</code>、<code>WADL</code>、<code>Google Discovery</code>等数据格式，方便旧项目迁移。</li>\n</ol>\n<h3 id=\"三、后续功能规划\"><a href=\"#三、后续功能规划\" class=\"headerlink\" title=\"三、后续功能规划\"></a>三、后续功能规划</h3><ol>\n<li>接口文档公开对外发布。</li>\n<li>接口性能测试支持（类似 JMeter）。</li>\n<li>支持插件市场，可以自己开发插件。</li>\n<li>支持更多接口协议，如<code>GraphQL</code>、<code>websocket</code>等。</li>\n<li>支持离线使用，项目可选择在线同步（团队协作）还是仅本地存储（单机离线使用）。</li>\n</ol>\n<h3 id=\"四、更多-Apifox-功能截图\"><a href=\"#四、更多-Apifox-功能截图\" class=\"headerlink\" title=\"四、更多 Apifox 功能截图\"></a>四、更多 Apifox 功能截图</h3><p><img src=\"https://pic3.zhimg.com/v2-cb29c171a62fec7792e09d4dea5601e2_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic4.zhimg.com/v2-b8a6e673775dead99fb7bf55fa3675e3_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic4.zhimg.com/v2-c0d31e348ca6fb205222ad5dbf95d9ab_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/v2-a5f3fe99fd6deae3d00a107b8444d506_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/v2-ea0e973c7134c19edbf2b80ef2fcf05a_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic4.zhimg.com/v2-b8c20d0818b3c7bef56137cb2e2cb2fb_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic2.zhimg.com/v2-5ac1da128a350111cfcbf47ab2f60b59_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/v2-6ef28c655835d5c8c98723c1c9d41f1a_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic1.zhimg.com/v2-fb6a6c2696b5e07015a071f480673854_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic1.zhimg.com/v2-eb8c27f09926a8dbe448c63d8d57ef74_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic1.zhimg.com/v2-149c5990e064bd371d3ea283a2d420d0_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic2.zhimg.com/v2-53926e1ca0884baed2c9ab20bed12bed_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic4.zhimg.com/v2-1dc4db7aa4ffcee95888c84da74812cf_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/v2-ae3f1d1e3eba65908c843b238dbf728a_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/v2-199dc8a814c5cbd2b6c603fb96589db6_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic1.zhimg.com/v2-c95173613dd345831e9fc8a9e96b3624_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic2.zhimg.com/v2-f5d96e21a55bf995f3d003bf09b2947d_r.jpg\" alt=\"img\"></p>\n<h3 id=\"五、-Apifox-下载地址\"><a href=\"#五、-Apifox-下载地址\" class=\"headerlink\" title=\"五、 Apifox 下载地址\"></a>五、 Apifox 下载地址</h3><p>请访问 Apifox 官网下载：<a href=\"https://www.apifox.cn/?utm_source=zhihu&utm_medium=article_10001&utm_content=377387530\" target=\"_blank\" rel=\"noopener\">https://www.apifox.cn/</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>作为开软件开发从业者，接口调试是必不可少的一项技能，我们经常使用 Postman 工具来进行接口调试，在接口调试方面 Postman 做的非常出色。但是在整个软件开发过程中，接口调试只是其中的一部分，还有很多事情 Postman 无法完成，或者无法高效完成，比如：接口文档定义、Mock 数据、接口自动化测试等等。","more":"</p>\n</blockquote>\n<p>需要 Apifox 功能介绍 PPT 版本的（可用于团队内部分享/推广 Apifox），可点击以下链接下载。<br><a href=\"https://cdn3.apifox.cn/www/assets/ppt/Apifox介绍.pptx\" target=\"_blank\" rel=\"noopener\">Apifox 功能介绍 ppt 格式</a><br><a href=\"https://cdn3.apifox.cn/www/assets/ppt/Apifox介绍.pdf\" target=\"_blank\" rel=\"noopener\">Apifox 功能介绍 pdf 格式</a></p>\n<h2 id=\"接口管理现状\"><a href=\"#接口管理现状\" class=\"headerlink\" title=\"接口管理现状\"></a>接口管理现状</h2><h3 id=\"一、常用解决方案\"><a href=\"#一、常用解决方案\" class=\"headerlink\" title=\"一、常用解决方案\"></a>一、常用解决方案</h3><ol>\n<li>使用 Swagger 作为<a href=\"https://www.apifox.cn/\" target=\"_blank\" rel=\"noopener\">接口文档工具</a></li>\n<li>使用 Postman 调试接口</li>\n<li>使用 RAP 等工具 Mock 数据</li>\n<li>使用 JMeter 做接口自动化测试</li>\n</ol>\n<h3 id=\"二、存在的问题\"><a href=\"#二、存在的问题\" class=\"headerlink\" title=\"二、存在的问题\"></a>二、存在的问题</h3><p>维护不同工具之间数据一致性非常困难、低效。并且这里不仅仅是工作量的问题，更大的问题是多个系统之间数据不一致，导致协作低效、频繁出问题，开发测试人员痛苦不堪。</p>\n<ol>\n<li>开发人员在 Swagger 定义好文档后，接口调试的时候还需要去 Postman 再定义一遍。</li>\n<li>前端开发 Mock 数据的时候又要去 RAP 定义一遍，还需要手动设置 Mock 规则。</li>\n<li>测试人员需要去 JMeter 再定义一遍。</li>\n<li>前端根据 RAP Mock 出来的数据开发完，后端根据 Swagger 定义的接口文档开发完，各自都试测试通过了，本以为可以马上上线，结果一对接发现各种问题：</li>\n</ol>\n<ul>\n<li>开发过程中接口变更了，只修改了 Swagger，但是没有及时同步修改 RAP。</li>\n<li>后端开发的接口数据类型和文档不一致，肉眼难以发现问题。</li>\n</ul>\n<ol>\n<li>同样，测试在 JMeter 写好的测试用例，真正运行的时候也会发现各种不一致。</li>\n<li>时间久了，各种不一致会越来越严重。</li>\n</ol>\n<h2 id=\"Apifox-解决方案\"><a href=\"#Apifox-解决方案\" class=\"headerlink\" title=\"Apifox 解决方案\"></a>Apifox 解决方案</h2><h3 id=\"一、如何解决这些问题\"><a href=\"#一、如何解决这些问题\" class=\"headerlink\" title=\"一、如何解决这些问题\"></a>一、如何解决这些问题</h3><h3 id=\"1、Apifox-定位\"><a href=\"#1、Apifox-定位\" class=\"headerlink\" title=\"1、Apifox 定位\"></a>1、Apifox 定位</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Apifox &#x3D; Postman + Swagger + Mock + JMeter</span><br></pre></td></tr></table></figure>\n\n<p>通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好接口文档，接口调试、数据 Mock、接口测试就可以直接使用，无需再次定义；接口文档和接口开发调试使用同一个工具，接口调试完成后即可保证和接口文档定义完全一致。高效、及时、准确！</p>\n<h3 id=\"2、Apifox-宗旨\"><a href=\"#2、Apifox-宗旨\" class=\"headerlink\" title=\"2、Apifox 宗旨\"></a>2、Apifox 宗旨</h3><p>节省研发团队的每一分钟！</p>\n<h3 id=\"3、Apifox-功能\"><a href=\"#3、Apifox-功能\" class=\"headerlink\" title=\"3、Apifox 功能\"></a>3、Apifox 功能</h3><ol>\n<li><strong>接口设计</strong>：Apifox 接口文档遵循 <a href=\"https://openapi.apifox.cn/\" target=\"_blank\" rel=\"noopener\">OpenApi</a> 3.0 (原 Swagger)、<a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener\">JSON Schema</a> 规范的同时，提供了非常好用的<code>可视化</code>文档管理功能，零学习成本，非常高效。并且支持在线分享接口文档。</li>\n<li><strong>数据模型</strong>：可复用的数据结构，定义接口<code>返回数据结构</code>及<code>请求参数数据结构</code>（仅 JSON 和 XML 模式）时可直接引用。支持模型直接嵌套引用，直接 JSON/XML 智能导入，支持 oneOf、allOf 等高级组合模式。</li>\n<li><strong>接口调试</strong>：Postman 有的功能，比如环境变量、前置/后置脚本、Cookie/Session 全局共享 等功能，Apifox 都有，并且比 Postman 更高效好用。接口运行完之后点击<code>保存为用例</code>按钮，即可生成<code>接口用例</code>，后续可直接运行接口用例，无需再输入参数，非常方便。自定义脚本 100% 兼容 Postman 语法，并且支持运行javascript、java、python、php、js、BeanShell、go、shell、ruby、lua等各种语言代码。</li>\n<li><strong>接口用例</strong>：通常一个接口会有多种情况用例，比如<code>参数正确</code>用例、<code>参数错误</code>用例、<code>数据为空</code>用例、<code>不同数据状态</code>用例等等。运行接口用例时会自动校验数据正确性，用接口用例来调试接口非常高效。</li>\n<li><strong>接口数据 Mock</strong>：内置 <a href=\"http://mockjs.com/\" target=\"_blank\" rel=\"noopener\">Mock.js</a> 规则引擎，非常方便 mock 出各种数据，并且可以在定义数据结构的同时写好 mock 规则。支持添加“期望”，根据请求参数返回不同 mock 数据。最重要的是 Apifox <code>零配置</code> 即可 Mock 出非常人性化的数据，具体在本文后面介绍。</li>\n<li><strong>接口自动化测试</strong>：提供接口集合测试，可以通过选择接口（或接口用例）快速创建测试集。目前接口自动化测试更多功能还在开发中，敬请期待！目标是： JMeter 有的功能基本都会有，并且要更好用。</li>\n<li><strong>数据库操作</strong>：支持读取数据库数据，作为接口请求参数使用。支持读取数据库数据，用来校验(断言)接口请求是否成功。</li>\n<li><strong>快捷调试</strong>：类似 Postman 的接口调试方式，主要用途为临时调试一些<code>无需文档化</code>的接口，无需提前定义接口即可快速调试。</li>\n<li><strong>代码生成</strong>：根据接口及数据数据模型定义，系统自动生成<code>接口请求代码</code>、<code>前端业务代码</code>及<code>后端业务代码</code>。</li>\n<li><strong>团队协作</strong>：Apifox 天生就是为团队协作而生的，接口云端实时同步更新，成熟的<code>团队/项目/成员权限</code>管理，满足各类企业的需求。</li>\n</ol>\n<h3 id=\"二、Apifox-做的不仅仅是数据打通\"><a href=\"#二、Apifox-做的不仅仅是数据打通\" class=\"headerlink\" title=\"二、Apifox 做的不仅仅是数据打通\"></a>二、Apifox 做的不仅仅是数据打通</h3><p>如果你认为 Apifox 只做了数据打通，来提升研发团队的效率，那就错了。Apifox 还做了非常多的创新，来提升开发人员的效率。</p>\n<h3 id=\"1、接口支持“用例管理”\"><a href=\"#1、接口支持“用例管理”\" class=\"headerlink\" title=\"1、接口支持“用例管理”\"></a>1、接口支持“用例管理”</h3><p>通常一个接口会有多种情况用例，比如 <code>正确用例</code> <code>参数错误用例</code> <code>数据为空用例</code> <code>不同数据状态用例</code>。定义接口的时候定义好这些不同状态的用例，接口调试的时候直接运行，非常高效。</p>\n<h3 id=\"2、“数据模型”定义、引用\"><a href=\"#2、“数据模型”定义、引用\" class=\"headerlink\" title=\"2、“数据模型”定义、引用\"></a>2、“数据模型”定义、引用</h3><p>可以独立定义数据模型，接口定义时可以直接引用数据模型，数据模型之间也可以相互引用。同样的数据结构，只需要定义一次即可多处使用；修改的时候只需要修改一处，多处实时更新，避免不一致。</p>\n<h3 id=\"3、调试时“自动校验”数据结构\"><a href=\"#3、调试时“自动校验”数据结构\" class=\"headerlink\" title=\"3、调试时“自动校验”数据结构\"></a>3、调试时“自动校验”数据结构</h3><p>使用 Apifox 调试接口的时候，系统会根据接口文档里的定义，自动校验返回的数据结构是否正确，无需通过肉识别，也无需手动写断言脚本检测，非常高效！</p>\n<p><img src=\"https://pic3.zhimg.com/v2-84b60639898cf51fd75bb557e615a5d2_r.jpg\" alt=\"img\"></p>\n<h3 id=\"4、“可视化”设置断言\"><a href=\"#4、“可视化”设置断言\" class=\"headerlink\" title=\"4、“可视化”设置断言\"></a>4、“可视化”设置断言</h3><p>设置断言：</p>\n<p><img src=\"https://pic4.zhimg.com/v2-09c5c04497eabbe8be8617ce8f12ea97_r.jpg\" alt=\"img\"></p>\n<p>运行后，查看断言结果：</p>\n<p><img src=\"https://pic1.zhimg.com/v2-93c6ad02f0fb83ced91aaddab5299204_r.jpg\" alt=\"img\"></p>\n<h3 id=\"5、“可视化”设置提取变量\"><a href=\"#5、“可视化”设置提取变量\" class=\"headerlink\" title=\"5、“可视化”设置提取变量\"></a>5、“可视化”设置提取变量</h3><p><img src=\"https://pic2.zhimg.com/v2-e1bfaee9f4a6b935db7f354255dc9c5d_r.jpg\" alt=\"img\"></p>\n<h3 id=\"6、支持数据库操作\"><a href=\"#6、支持数据库操作\" class=\"headerlink\" title=\"6、支持数据库操作\"></a>6、支持数据库操作</h3><p><img src=\"https://pic1.zhimg.com/v2-07fcb7adc6b2e157b26c244b5c930b6c_r.jpg\" alt=\"img\"></p>\n<h3 id=\"7、“零配置”Mock-出非常人性化的数据\"><a href=\"#7、“零配置”Mock-出非常人性化的数据\" class=\"headerlink\" title=\"7、“零配置”Mock 出非常人性化的数据\"></a>7、“零配置”Mock 出非常人性化的数据</h3><p>先放一张图对比下 Apifox 和其他同类工具 <code>零配置</code> mock 出来的数据效果：</p>\n<p><img src=\"https://pic1.zhimg.com/v2-cf3012a053f55cf2ecd84871c4db4394_r.jpg\" alt=\"img\"></p>\n<p>可以看出 Apifox <code>零配置</code> Mock 出来的数据和真实情况是非常接近的，前端开发可以直接使用，而无需再手动写 mock 规则。</p>\n<p><strong>Apifox 如何做到<code>高效率</code>、<code>零配置</code>生成非常人性化的 mock 数据</strong></p>\n<ol>\n<li>Apifox 根据接口定义里的数据结构、数据类型，自动生成 mock 规则。</li>\n<li>Apifox 内置智能 mock 规则库，根据字段名、字段数据类型，智能优化自动生成的 mock 规则。如：名称包含字符串<code>image</code>的<code>string</code>类型字段，自动 mock 出一个图片地址 URL；包含字符串<code>time</code>的<code>string</code>类型字段，自动 mock 出一个时间字符串；包含字符串<code>city</code>的<code>string</code>类型字段，自动 mock 出一个城市名。</li>\n<li>Apifox 根据内置规则，可自动识别出图片、头像、用户名、手机号、网址、日期、时间、时间戳、邮箱、省份、城市、地址、IP 等字段，从而 Mock 出非常人性化的数据。</li>\n<li>除了内置 mock 规则，用户还可以自定义规则库，满足各种个性化需求。支持使用 <code>正则表达式</code>、<code>通配符</code> 来匹配字段名自定义 mock 规则。</li>\n</ol>\n<h3 id=\"8、代码自动生成\"><a href=\"#8、代码自动生成\" class=\"headerlink\" title=\"8、代码自动生成\"></a>8、代码自动生成</h3><p>根据接口模型定义，自动生成各种语言/框架（如 TypeScript、Java、Go、Swift、ObjectiveC、Kotlin、Dart、C++、C#、Rust 等）的业务代码（如 Model、Controller、单元测试代码等）和接口请求代码。目前 Apifox 支持 130 种语言及框架的代码自动生成。</p>\n<p>更重要的是：你可以通过<code>自定义代码模板</code>来生成符合自己团队的架构规范的代码，满足各种个性化的需求。</p>\n<h3 id=\"9、导入、导出\"><a href=\"#9、导入、导出\" class=\"headerlink\" title=\"9、导入、导出\"></a>9、导入、导出</h3><ol>\n<li>支持导出 <code>OpenApi (Swagger)</code>、<code>Markdown</code>、<code>Html</code> 等数据格式，因为可以导出<code>OpenApi</code>格式数据，所以你可以利用 OpenApi (Swagger) 丰富的生态工具完成各种接口相关的事情。</li>\n<li>支持导入 <code>OpenApi (Swagger)</code>、<code>Postman</code>、<code>HAR</code>、<code>RAML</code>、<code>RAP2</code>、<code>YApi</code>、<code>Eolinker</code>、<code>NEI</code>、<code>DOClever</code>、<code>ApiPost</code> 、<code>Apizza</code> 、<code>ShowDoc</code>、<code>API Blueprint</code>、<code>I/O Docs</code>、<code>WADL</code>、<code>Google Discovery</code>等数据格式，方便旧项目迁移。</li>\n</ol>\n<h3 id=\"三、后续功能规划\"><a href=\"#三、后续功能规划\" class=\"headerlink\" title=\"三、后续功能规划\"></a>三、后续功能规划</h3><ol>\n<li>接口文档公开对外发布。</li>\n<li>接口性能测试支持（类似 JMeter）。</li>\n<li>支持插件市场，可以自己开发插件。</li>\n<li>支持更多接口协议，如<code>GraphQL</code>、<code>websocket</code>等。</li>\n<li>支持离线使用，项目可选择在线同步（团队协作）还是仅本地存储（单机离线使用）。</li>\n</ol>\n<h3 id=\"四、更多-Apifox-功能截图\"><a href=\"#四、更多-Apifox-功能截图\" class=\"headerlink\" title=\"四、更多 Apifox 功能截图\"></a>四、更多 Apifox 功能截图</h3><p><img src=\"https://pic3.zhimg.com/v2-cb29c171a62fec7792e09d4dea5601e2_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic4.zhimg.com/v2-b8a6e673775dead99fb7bf55fa3675e3_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic4.zhimg.com/v2-c0d31e348ca6fb205222ad5dbf95d9ab_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/v2-a5f3fe99fd6deae3d00a107b8444d506_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/v2-ea0e973c7134c19edbf2b80ef2fcf05a_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic4.zhimg.com/v2-b8c20d0818b3c7bef56137cb2e2cb2fb_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic2.zhimg.com/v2-5ac1da128a350111cfcbf47ab2f60b59_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/v2-6ef28c655835d5c8c98723c1c9d41f1a_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic1.zhimg.com/v2-fb6a6c2696b5e07015a071f480673854_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic1.zhimg.com/v2-eb8c27f09926a8dbe448c63d8d57ef74_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic1.zhimg.com/v2-149c5990e064bd371d3ea283a2d420d0_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic2.zhimg.com/v2-53926e1ca0884baed2c9ab20bed12bed_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic4.zhimg.com/v2-1dc4db7aa4ffcee95888c84da74812cf_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/v2-ae3f1d1e3eba65908c843b238dbf728a_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic3.zhimg.com/v2-199dc8a814c5cbd2b6c603fb96589db6_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic1.zhimg.com/v2-c95173613dd345831e9fc8a9e96b3624_r.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic2.zhimg.com/v2-f5d96e21a55bf995f3d003bf09b2947d_r.jpg\" alt=\"img\"></p>\n<h3 id=\"五、-Apifox-下载地址\"><a href=\"#五、-Apifox-下载地址\" class=\"headerlink\" title=\"五、 Apifox 下载地址\"></a>五、 Apifox 下载地址</h3><p>请访问 Apifox 官网下载：<a href=\"https://www.apifox.cn/?utm_source=zhihu&utm_medium=article_10001&utm_content=377387530\" target=\"_blank\" rel=\"noopener\">https://www.apifox.cn/</a></p>"},{"title":"【测试工具】浅度测评：requests、aiohttp、httpx 我应该用哪一个？","abbrlink":"2173e2a4","cover":"https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/7.png","date":"2021-12-12T14:12:58.000Z","layout":"post","_content":"\n在武汉，房子里待着，不出去影响世界了，转载点文章。 <!-- more --> \n\n在 Python 众多的 HTTP 客户端中，最有名的莫过于requests、aiohttp和httpx。在不借助其他第三方库的情况下，requests只能发送同步请求；aiohttp只能发送异步请求；httpx既能发送同步请求，又能发送异步请求。\n\n所谓的同步请求，是指在单进程单线程的代码中，发起一次请求后，在收到返回结果之前，不能发起下一次请求。所谓异步请求，是指在单进程单线程的代码中，发起一次请求后，在等待网站返回结果的时间里，可以继续发送更多请求。\n\n今天我们来一个浅度测评，仅仅以多次发送 POST 请求这个角度来对比这三个库的性能。\n\n测试使用的 HTTP 服务地址为http://122.51.39.219:8000/query，向它发送 POST 请求的格式如下图所示：\n\n![img](https://pics6.baidu.com/feed/0b46f21fbe096b6301e3838247be9b42e9f8acfa.jpeg?token=70d39787cf58d67bf77a9106c04807a4&s=C096E73B1CA8440D18E1A5DB0000E0B3)\n\n请求发送的 ts 字段日期距离今天大于10天，那么返回{\"success\": false}，如果小于等于10天，那么返回{\"success\": true}。\n\n首先我们通过各个客户端使用相同的参数只发送一次请求，看看效果。\n\n发送一次请求\n\n**requests**\n\nimport requestsresp = requests.post('http://122.51.39.219:8000/query', json={'ts': '2020-01-20 13:14:15'}).json()print(resp)运行效果如下图所示：\n\n![img](https://pics2.baidu.com/feed/63d9f2d3572c11df47d7597328aa7ed6f603c2f4.png?token=a37daa3c6812a2d7d1f92ffa76fd4e77&s=718A7D3B110E554D1674B0DA030050B0)\n\n**httpx**\n\n使用 httpx 发送同步请求：\n\nimport httpxresp = httpx.post('http://122.51.39.219:8000/query', json={'ts': '2020-01-20 13:14:15'}).json()print(resp)httpx 的同步模式与 requests 代码重合度99%，只需要把requests改成httpx即可正常运行。如下图所示：\n\n![img](https://pics4.baidu.com/feed/faedab64034f78f02435131e32bc1653b2191cb0.png?token=e3e2e21a11fa3f55e0d73094d6b578cd&s=718A7D3B110E554D1674B0DA030050B0)\n\n使用 httpx 发送异步请求：\n\nimport httpximport asyncioasyncdefmain():asyncwith httpx.AsyncClient() as client: resp = await client.post('http://122.51.39.219:8000/query', json={'ts': '2020-01-20 13:14:15'}) result = resp.json() print(result)asyncio.run(main())运行效果如下图所示：\n\n![img](https://pics2.baidu.com/feed/0823dd54564e9258a5a27545d20fcd5ecdbf4e1e.png?token=53fcebbef383dda74aa8d3adea337a1d&s=7108753B111E55CC4AC19DDA0300D0B1)\n\n**aiohttp**\n\nimport aiohttpimport asyncioasyncdefmain():asyncwith aiohttp.ClientSession() as client: resp = await client.post('http://122.51.39.219:8000/query', json={'ts': '2020-01-20 13:14:15'}) result = await resp.json() print(result)asyncio.run(main())运行效果如下图所示：\n\n![img](https://pics1.baidu.com/feed/0824ab18972bd407aed406f4310482570fb3093f.png?token=38acd3253e87bd2f0628fbf3c4781a70&s=7B08752B111E55CC42C11DDA0300D0B1)\n\naiohttp 的代码与 httpx 异步模式的代码重合度90%，只不过把AsyncClient换成了ClientSession，另外，在使用 httpx 时，当你await client.post时就已经发送了请求。但是当使用aiohttp时，只有在awiat resp.json() 时才会真正发送请求。\n\n发送100次请求\n\n我们现在随机生成一个距离今天在5-15天的日期，发送到 HTTP接口中。如果日期距离今天超过10天，那么返回的数据的 False，如果小于等于10天，那么返回的数据是 True。\n\n我们发送100次请求，计算总共耗时。\n\n**requests**\n\n在前几天的文章中，我们提到，使用requests.post每次都会创建新的连接，速度较慢。而如果首先初始化一个 Session，那么 requests 会保持连接，从而大大提高请求速度。所以在这次测评中，我们分别对两种情况进行测试。\n\n不保持连接\n\nimport randomimport timeimport datetimeimport requestsdefmake_request(body): resp = requests.post('http://122.51.39.219:8000/query', json=body) result = resp.json() print(result)defmain(): start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime('%Y-%m-%d %H:%M:%S') make_request({'ts': ts}) end = time.time() print(f'发送100次请求，耗时：{end - start}')if __name__ == '__main__': main()运行效果如下图所示：\n\n![img](https://pics2.baidu.com/feed/0ff41bd5ad6eddc4b5380c217356aafb506633a4.jpeg?token=8f345eb6f471f83547307a2770098fa4&s=E11A643B011ED5CE46D405DA0000C0B1)\n\n**发送100次请求，requests 不保持连接时耗时2.7秒**\n\n保持连接\n\n对代码稍作修改，使用同一个 Session 发送请求：\n\nimport randomimport timeimport datetimeimport requestsdefmake_request(session, body): resp = session.post('http://122.51.39.219:8000/query', json=body) result = resp.json() print(result)defmain(): session = requests.Session() start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime('%Y-%m-%d %H:%M:%S') make_request(session, {'ts': ts}) end = time.time() print(f'发送100次请求，耗时：{end - start}')if __name__ == '__main__': main()运行效果如下图所示：\n\n![img](https://pics2.baidu.com/feed/1e30e924b899a901c2b847365718167d0308f5b0.jpeg?token=389373396414cd3fd0c8e558d2fcf9ac&s=F008743B811ED5CE004500DA0000C0B1)\n\n**发送100次请求，requests 保持连接耗时1.4秒**\n\n**httpx**\n\n同步模式\n\n代码如下：\n\nimport randomimport timeimport datetimeimport httpxdefmake_request(client, body): resp = client.post('http://122.51.39.219:8000/query', json=body) result = resp.json() print(result)defmain(): session = httpx.Client() start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime('%Y-%m-%d %H:%M:%S') make_request(session, {'ts': ts}) end = time.time() print(f'发送100次请求，耗时：{end - start}')if __name__ == '__main__': main()运行效果如下图所示：\n\n![img](https://pics1.baidu.com/feed/f636afc379310a55c4caf697fdc85faf8326107d.jpeg?token=32ab623d88054400cb2bd2ba44f6a743&s=50087C3BC11ED5CC18D508DA0000C0B1)\n\n**发送100次请求，httpx 同步模式耗时1.5秒左右。**\n\n异步模式\n\n代码如下：\n\nimport httpximport randomimport datetimeimport asyncioimport timeasyncdefrequest(client, body): resp = await client.post('http://122.51.39.219:8000/query', json=body) result = resp.json() print(result)asyncdefmain():asyncwith httpx.AsyncClient() as client: start = time.time() task_list = []for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime('%Y-%m-%d %H:%M:%S') req = request(client, {'ts': ts}) task = asyncio.create_task(req) task_list.append(task)await asyncio.gather(*task_list) end = time.time() print(f'发送100次请求，耗时：{end - start}')asyncio.run(main())运行效果如下图所示：\n\n![img](https://pics3.baidu.com/feed/1f178a82b9014a90bef4207ee4fa2514b11beeba.jpeg?token=01173500e927b2967d8da8b7e470f17a&s=4418743BC15EC5CC404128DA000010B0)\n\n**发送100次请求，httpx 异步模式耗时0.6秒左右。**\n\n**aiohttp**\n\n测试代码如下：\n\nimport aiohttpimport randomimport datetimeimport asyncioimport timeasyncdefrequest(client, body): resp = await client.post('http://122.51.39.219:8000/query', json=body) result = await resp.json() print(result)asyncdefmain():asyncwith aiohttp.ClientSession() as client: start = time.time() task_list = []for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime('%Y-%m-%d %H:%M:%S') req = request(client, {'ts': ts}) task = asyncio.create_task(req) task_list.append(task)await asyncio.gather(*task_list) end = time.time() print(f'发送100次请求，耗时：{end - start}')asyncio.run(main())运行效果如下图所示：\n\n![img](https://pics3.baidu.com/feed/2e2eb9389b504fc2313ebc72a950fb1791ef6df3.jpeg?token=a595216712e08dec3f155133f27e38a4&s=E4986C3AC95EE5CC4CC544DE0000C0B1)\n\n**发送100次请求，使用 aiohttp 耗时0.3秒左右**\n\n发送1000次请求\n\n由于 request 保持连接的速度比不保持连接快，所以我们这里只用保持连接的方式来测试。并且不打印返回的结果。\n\n**requests**\n\n运行效果如下图所示：\n\n![img](https://pics4.baidu.com/feed/359b033b5bb5c9ea40e4afa798b4aa063bf3b3f6.jpeg?token=514171994f18a98a6e7bb65e4ecff4ce&s=54087C3BD15FF5CC024548DA000080B1)\n\n**发送1000次请求，requests 耗时16秒左右**\n\n**httpx**\n\n同步模式\n\n运行效果如下图所示：\n\n![img](https://pics6.baidu.com/feed/a1ec08fa513d26976689b5e21a76aefd4216d84e.jpeg?token=9306ad5ffa386a1d9a2227e36a4adbcf&s=D508743B915FD5CC045500DA0000C0B1)\n\n**发送1000次请求，httpx 同步模式耗时18秒左右**\n\n异步模式\n\n运行效果如下图所示：\n\n![img](https://pics0.baidu.com/feed/7aec54e736d12f2e0585c540034fc964843568a5.jpeg?token=1f6bd37b4fc444498a0e7cb32ff03378&s=4018543BD15FC1CC584520DA000080B1)\n\n**发送1000次请求，httpx 异步模式耗时5秒左右**\n\n**aiohttp**\n\n运行效果如下图所示：\n\n![img](https://pics7.baidu.com/feed/5366d0160924ab182be2692f7f77facb7a890b41.jpeg?token=1394197262765a9fda0b13fde6b4fbb9&s=4418643BD15FC1CC545564DA000080B2)\n\n**发送1000次请求，aiohttp 耗时4秒左右**\n\n总结\n\n如果你只发几条请求。那么使用 requests 或者 httpx 的同步模式，代码最简单。\n\n如果你要发送很多请求，但是有些地方要发送同步请求，有些地方要发送异步请求，那么使用 httpx 最省事。\n\n如果你要发送很多请求，并且越快越好，那么使用 aiohttp 最快。\n\n这篇测评文章只是一个非常浅度的评测，只考虑了请求速度这一个角度。如果你要在生产环境使用，那么你可以做更多实验来看是不是符合你的实际使用情况。\n\n原文链接：https://baijiahao.baidu.com/s?id=1656736744425905392&wfr=spider&for=pc","source":"_posts/2021.12/【测试工具】浅度测评：requests、aiohttp、httpx 我应该用哪一个？.md","raw":"---\ntitle: 【测试工具】浅度测评：requests、aiohttp、httpx 我应该用哪一个？\nabbrlink: 2173e2a4\ncover: https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/7.png\ndate: 2021-12-12 22:12:58\nlayout:\ntags:\n---\n\n在武汉，房子里待着，不出去影响世界了，转载点文章。 <!-- more --> \n\n在 Python 众多的 HTTP 客户端中，最有名的莫过于requests、aiohttp和httpx。在不借助其他第三方库的情况下，requests只能发送同步请求；aiohttp只能发送异步请求；httpx既能发送同步请求，又能发送异步请求。\n\n所谓的同步请求，是指在单进程单线程的代码中，发起一次请求后，在收到返回结果之前，不能发起下一次请求。所谓异步请求，是指在单进程单线程的代码中，发起一次请求后，在等待网站返回结果的时间里，可以继续发送更多请求。\n\n今天我们来一个浅度测评，仅仅以多次发送 POST 请求这个角度来对比这三个库的性能。\n\n测试使用的 HTTP 服务地址为http://122.51.39.219:8000/query，向它发送 POST 请求的格式如下图所示：\n\n![img](https://pics6.baidu.com/feed/0b46f21fbe096b6301e3838247be9b42e9f8acfa.jpeg?token=70d39787cf58d67bf77a9106c04807a4&s=C096E73B1CA8440D18E1A5DB0000E0B3)\n\n请求发送的 ts 字段日期距离今天大于10天，那么返回{\"success\": false}，如果小于等于10天，那么返回{\"success\": true}。\n\n首先我们通过各个客户端使用相同的参数只发送一次请求，看看效果。\n\n发送一次请求\n\n**requests**\n\nimport requestsresp = requests.post('http://122.51.39.219:8000/query', json={'ts': '2020-01-20 13:14:15'}).json()print(resp)运行效果如下图所示：\n\n![img](https://pics2.baidu.com/feed/63d9f2d3572c11df47d7597328aa7ed6f603c2f4.png?token=a37daa3c6812a2d7d1f92ffa76fd4e77&s=718A7D3B110E554D1674B0DA030050B0)\n\n**httpx**\n\n使用 httpx 发送同步请求：\n\nimport httpxresp = httpx.post('http://122.51.39.219:8000/query', json={'ts': '2020-01-20 13:14:15'}).json()print(resp)httpx 的同步模式与 requests 代码重合度99%，只需要把requests改成httpx即可正常运行。如下图所示：\n\n![img](https://pics4.baidu.com/feed/faedab64034f78f02435131e32bc1653b2191cb0.png?token=e3e2e21a11fa3f55e0d73094d6b578cd&s=718A7D3B110E554D1674B0DA030050B0)\n\n使用 httpx 发送异步请求：\n\nimport httpximport asyncioasyncdefmain():asyncwith httpx.AsyncClient() as client: resp = await client.post('http://122.51.39.219:8000/query', json={'ts': '2020-01-20 13:14:15'}) result = resp.json() print(result)asyncio.run(main())运行效果如下图所示：\n\n![img](https://pics2.baidu.com/feed/0823dd54564e9258a5a27545d20fcd5ecdbf4e1e.png?token=53fcebbef383dda74aa8d3adea337a1d&s=7108753B111E55CC4AC19DDA0300D0B1)\n\n**aiohttp**\n\nimport aiohttpimport asyncioasyncdefmain():asyncwith aiohttp.ClientSession() as client: resp = await client.post('http://122.51.39.219:8000/query', json={'ts': '2020-01-20 13:14:15'}) result = await resp.json() print(result)asyncio.run(main())运行效果如下图所示：\n\n![img](https://pics1.baidu.com/feed/0824ab18972bd407aed406f4310482570fb3093f.png?token=38acd3253e87bd2f0628fbf3c4781a70&s=7B08752B111E55CC42C11DDA0300D0B1)\n\naiohttp 的代码与 httpx 异步模式的代码重合度90%，只不过把AsyncClient换成了ClientSession，另外，在使用 httpx 时，当你await client.post时就已经发送了请求。但是当使用aiohttp时，只有在awiat resp.json() 时才会真正发送请求。\n\n发送100次请求\n\n我们现在随机生成一个距离今天在5-15天的日期，发送到 HTTP接口中。如果日期距离今天超过10天，那么返回的数据的 False，如果小于等于10天，那么返回的数据是 True。\n\n我们发送100次请求，计算总共耗时。\n\n**requests**\n\n在前几天的文章中，我们提到，使用requests.post每次都会创建新的连接，速度较慢。而如果首先初始化一个 Session，那么 requests 会保持连接，从而大大提高请求速度。所以在这次测评中，我们分别对两种情况进行测试。\n\n不保持连接\n\nimport randomimport timeimport datetimeimport requestsdefmake_request(body): resp = requests.post('http://122.51.39.219:8000/query', json=body) result = resp.json() print(result)defmain(): start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime('%Y-%m-%d %H:%M:%S') make_request({'ts': ts}) end = time.time() print(f'发送100次请求，耗时：{end - start}')if __name__ == '__main__': main()运行效果如下图所示：\n\n![img](https://pics2.baidu.com/feed/0ff41bd5ad6eddc4b5380c217356aafb506633a4.jpeg?token=8f345eb6f471f83547307a2770098fa4&s=E11A643B011ED5CE46D405DA0000C0B1)\n\n**发送100次请求，requests 不保持连接时耗时2.7秒**\n\n保持连接\n\n对代码稍作修改，使用同一个 Session 发送请求：\n\nimport randomimport timeimport datetimeimport requestsdefmake_request(session, body): resp = session.post('http://122.51.39.219:8000/query', json=body) result = resp.json() print(result)defmain(): session = requests.Session() start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime('%Y-%m-%d %H:%M:%S') make_request(session, {'ts': ts}) end = time.time() print(f'发送100次请求，耗时：{end - start}')if __name__ == '__main__': main()运行效果如下图所示：\n\n![img](https://pics2.baidu.com/feed/1e30e924b899a901c2b847365718167d0308f5b0.jpeg?token=389373396414cd3fd0c8e558d2fcf9ac&s=F008743B811ED5CE004500DA0000C0B1)\n\n**发送100次请求，requests 保持连接耗时1.4秒**\n\n**httpx**\n\n同步模式\n\n代码如下：\n\nimport randomimport timeimport datetimeimport httpxdefmake_request(client, body): resp = client.post('http://122.51.39.219:8000/query', json=body) result = resp.json() print(result)defmain(): session = httpx.Client() start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime('%Y-%m-%d %H:%M:%S') make_request(session, {'ts': ts}) end = time.time() print(f'发送100次请求，耗时：{end - start}')if __name__ == '__main__': main()运行效果如下图所示：\n\n![img](https://pics1.baidu.com/feed/f636afc379310a55c4caf697fdc85faf8326107d.jpeg?token=32ab623d88054400cb2bd2ba44f6a743&s=50087C3BC11ED5CC18D508DA0000C0B1)\n\n**发送100次请求，httpx 同步模式耗时1.5秒左右。**\n\n异步模式\n\n代码如下：\n\nimport httpximport randomimport datetimeimport asyncioimport timeasyncdefrequest(client, body): resp = await client.post('http://122.51.39.219:8000/query', json=body) result = resp.json() print(result)asyncdefmain():asyncwith httpx.AsyncClient() as client: start = time.time() task_list = []for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime('%Y-%m-%d %H:%M:%S') req = request(client, {'ts': ts}) task = asyncio.create_task(req) task_list.append(task)await asyncio.gather(*task_list) end = time.time() print(f'发送100次请求，耗时：{end - start}')asyncio.run(main())运行效果如下图所示：\n\n![img](https://pics3.baidu.com/feed/1f178a82b9014a90bef4207ee4fa2514b11beeba.jpeg?token=01173500e927b2967d8da8b7e470f17a&s=4418743BC15EC5CC404128DA000010B0)\n\n**发送100次请求，httpx 异步模式耗时0.6秒左右。**\n\n**aiohttp**\n\n测试代码如下：\n\nimport aiohttpimport randomimport datetimeimport asyncioimport timeasyncdefrequest(client, body): resp = await client.post('http://122.51.39.219:8000/query', json=body) result = await resp.json() print(result)asyncdefmain():asyncwith aiohttp.ClientSession() as client: start = time.time() task_list = []for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime('%Y-%m-%d %H:%M:%S') req = request(client, {'ts': ts}) task = asyncio.create_task(req) task_list.append(task)await asyncio.gather(*task_list) end = time.time() print(f'发送100次请求，耗时：{end - start}')asyncio.run(main())运行效果如下图所示：\n\n![img](https://pics3.baidu.com/feed/2e2eb9389b504fc2313ebc72a950fb1791ef6df3.jpeg?token=a595216712e08dec3f155133f27e38a4&s=E4986C3AC95EE5CC4CC544DE0000C0B1)\n\n**发送100次请求，使用 aiohttp 耗时0.3秒左右**\n\n发送1000次请求\n\n由于 request 保持连接的速度比不保持连接快，所以我们这里只用保持连接的方式来测试。并且不打印返回的结果。\n\n**requests**\n\n运行效果如下图所示：\n\n![img](https://pics4.baidu.com/feed/359b033b5bb5c9ea40e4afa798b4aa063bf3b3f6.jpeg?token=514171994f18a98a6e7bb65e4ecff4ce&s=54087C3BD15FF5CC024548DA000080B1)\n\n**发送1000次请求，requests 耗时16秒左右**\n\n**httpx**\n\n同步模式\n\n运行效果如下图所示：\n\n![img](https://pics6.baidu.com/feed/a1ec08fa513d26976689b5e21a76aefd4216d84e.jpeg?token=9306ad5ffa386a1d9a2227e36a4adbcf&s=D508743B915FD5CC045500DA0000C0B1)\n\n**发送1000次请求，httpx 同步模式耗时18秒左右**\n\n异步模式\n\n运行效果如下图所示：\n\n![img](https://pics0.baidu.com/feed/7aec54e736d12f2e0585c540034fc964843568a5.jpeg?token=1f6bd37b4fc444498a0e7cb32ff03378&s=4018543BD15FC1CC584520DA000080B1)\n\n**发送1000次请求，httpx 异步模式耗时5秒左右**\n\n**aiohttp**\n\n运行效果如下图所示：\n\n![img](https://pics7.baidu.com/feed/5366d0160924ab182be2692f7f77facb7a890b41.jpeg?token=1394197262765a9fda0b13fde6b4fbb9&s=4418643BD15FC1CC545564DA000080B2)\n\n**发送1000次请求，aiohttp 耗时4秒左右**\n\n总结\n\n如果你只发几条请求。那么使用 requests 或者 httpx 的同步模式，代码最简单。\n\n如果你要发送很多请求，但是有些地方要发送同步请求，有些地方要发送异步请求，那么使用 httpx 最省事。\n\n如果你要发送很多请求，并且越快越好，那么使用 aiohttp 最快。\n\n这篇测评文章只是一个非常浅度的评测，只考虑了请求速度这一个角度。如果你要在生产环境使用，那么你可以做更多实验来看是不是符合你的实际使用情况。\n\n原文链接：https://baijiahao.baidu.com/s?id=1656736744425905392&wfr=spider&for=pc","slug":"2021.12/【测试工具】浅度测评：requests、aiohttp、httpx 我应该用哪一个？","published":1,"updated":"2021-12-12T14:12:58.000Z","comments":1,"photos":[],"link":"","_id":"cl2y4l3wn000tn4ep0672d6yj","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>在武汉，房子里待着，不出去影响世界了，转载点文章。 <a id=\"more\"></a> </p>\n<p>在 Python 众多的 HTTP 客户端中，最有名的莫过于requests、aiohttp和httpx。在不借助其他第三方库的情况下，requests只能发送同步请求；aiohttp只能发送异步请求；httpx既能发送同步请求，又能发送异步请求。</p>\n<p>所谓的同步请求，是指在单进程单线程的代码中，发起一次请求后，在收到返回结果之前，不能发起下一次请求。所谓异步请求，是指在单进程单线程的代码中，发起一次请求后，在等待网站返回结果的时间里，可以继续发送更多请求。</p>\n<p>今天我们来一个浅度测评，仅仅以多次发送 POST 请求这个角度来对比这三个库的性能。</p>\n<p>测试使用的 HTTP 服务地址为<a href=\"http://122.51.39.219:8000/query，向它发送\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query，向它发送</a> POST 请求的格式如下图所示：</p>\n<p><img src=\"https://pics6.baidu.com/feed/0b46f21fbe096b6301e3838247be9b42e9f8acfa.jpeg?token=70d39787cf58d67bf77a9106c04807a4&s=C096E73B1CA8440D18E1A5DB0000E0B3\" alt=\"img\"></p>\n<p>请求发送的 ts 字段日期距离今天大于10天，那么返回{“success”: false}，如果小于等于10天，那么返回{“success”: true}。</p>\n<p>首先我们通过各个客户端使用相同的参数只发送一次请求，看看效果。</p>\n<p>发送一次请求</p>\n<p><strong>requests</strong></p>\n<p>import requestsresp = requests.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}).json()print(resp)运行效果如下图所示：</p>\n<p><img src=\"https://pics2.baidu.com/feed/63d9f2d3572c11df47d7597328aa7ed6f603c2f4.png?token=a37daa3c6812a2d7d1f92ffa76fd4e77&s=718A7D3B110E554D1674B0DA030050B0\" alt=\"img\"></p>\n<p><strong>httpx</strong></p>\n<p>使用 httpx 发送同步请求：</p>\n<p>import httpxresp = httpx.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}).json()print(resp)httpx 的同步模式与 requests 代码重合度99%，只需要把requests改成httpx即可正常运行。如下图所示：</p>\n<p><img src=\"https://pics4.baidu.com/feed/faedab64034f78f02435131e32bc1653b2191cb0.png?token=e3e2e21a11fa3f55e0d73094d6b578cd&s=718A7D3B110E554D1674B0DA030050B0\" alt=\"img\"></p>\n<p>使用 httpx 发送异步请求：</p>\n<p>import httpximport asyncioasyncdefmain():asyncwith httpx.AsyncClient() as client: resp = await client.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}) result = resp.json() print(result)asyncio.run(main())运行效果如下图所示：</p>\n<p><img src=\"https://pics2.baidu.com/feed/0823dd54564e9258a5a27545d20fcd5ecdbf4e1e.png?token=53fcebbef383dda74aa8d3adea337a1d&s=7108753B111E55CC4AC19DDA0300D0B1\" alt=\"img\"></p>\n<p><strong>aiohttp</strong></p>\n<p>import aiohttpimport asyncioasyncdefmain():asyncwith aiohttp.ClientSession() as client: resp = await client.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}) result = await resp.json() print(result)asyncio.run(main())运行效果如下图所示：</p>\n<p><img src=\"https://pics1.baidu.com/feed/0824ab18972bd407aed406f4310482570fb3093f.png?token=38acd3253e87bd2f0628fbf3c4781a70&s=7B08752B111E55CC42C11DDA0300D0B1\" alt=\"img\"></p>\n<p>aiohttp 的代码与 httpx 异步模式的代码重合度90%，只不过把AsyncClient换成了ClientSession，另外，在使用 httpx 时，当你await client.post时就已经发送了请求。但是当使用aiohttp时，只有在awiat resp.json() 时才会真正发送请求。</p>\n<p>发送100次请求</p>\n<p>我们现在随机生成一个距离今天在5-15天的日期，发送到 HTTP接口中。如果日期距离今天超过10天，那么返回的数据的 False，如果小于等于10天，那么返回的数据是 True。</p>\n<p>我们发送100次请求，计算总共耗时。</p>\n<p><strong>requests</strong></p>\n<p>在前几天的文章中，我们提到，使用requests.post每次都会创建新的连接，速度较慢。而如果首先初始化一个 Session，那么 requests 会保持连接，从而大大提高请求速度。所以在这次测评中，我们分别对两种情况进行测试。</p>\n<p>不保持连接</p>\n<p>import randomimport timeimport datetimeimport requestsdefmake_request(body): resp = requests.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)defmain(): start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) make_request({‘ts’: ts}) end = time.time() print(f’发送100次请求，耗时：{end - start}’)if <strong>name</strong> == ‘<strong>main</strong>‘: main()运行效果如下图所示：</p>\n<p><img src=\"https://pics2.baidu.com/feed/0ff41bd5ad6eddc4b5380c217356aafb506633a4.jpeg?token=8f345eb6f471f83547307a2770098fa4&s=E11A643B011ED5CE46D405DA0000C0B1\" alt=\"img\"></p>\n<p><strong>发送100次请求，requests 不保持连接时耗时2.7秒</strong></p>\n<p>保持连接</p>\n<p>对代码稍作修改，使用同一个 Session 发送请求：</p>\n<p>import randomimport timeimport datetimeimport requestsdefmake_request(session, body): resp = session.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)defmain(): session = requests.Session() start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) make_request(session, {‘ts’: ts}) end = time.time() print(f’发送100次请求，耗时：{end - start}’)if <strong>name</strong> == ‘<strong>main</strong>‘: main()运行效果如下图所示：</p>\n<p><img src=\"https://pics2.baidu.com/feed/1e30e924b899a901c2b847365718167d0308f5b0.jpeg?token=389373396414cd3fd0c8e558d2fcf9ac&s=F008743B811ED5CE004500DA0000C0B1\" alt=\"img\"></p>\n<p><strong>发送100次请求，requests 保持连接耗时1.4秒</strong></p>\n<p><strong>httpx</strong></p>\n<p>同步模式</p>\n<p>代码如下：</p>\n<p>import randomimport timeimport datetimeimport httpxdefmake_request(client, body): resp = client.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)defmain(): session = httpx.Client() start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) make_request(session, {‘ts’: ts}) end = time.time() print(f’发送100次请求，耗时：{end - start}’)if <strong>name</strong> == ‘<strong>main</strong>‘: main()运行效果如下图所示：</p>\n<p><img src=\"https://pics1.baidu.com/feed/f636afc379310a55c4caf697fdc85faf8326107d.jpeg?token=32ab623d88054400cb2bd2ba44f6a743&s=50087C3BC11ED5CC18D508DA0000C0B1\" alt=\"img\"></p>\n<p><strong>发送100次请求，httpx 同步模式耗时1.5秒左右。</strong></p>\n<p>异步模式</p>\n<p>代码如下：</p>\n<p>import httpximport randomimport datetimeimport asyncioimport timeasyncdefrequest(client, body): resp = await client.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)asyncdefmain():asyncwith httpx.AsyncClient() as client: start = time.time() task_list = []for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) req = request(client, {‘ts’: ts}) task = asyncio.create_task(req) task_list.append(task)await asyncio.gather(*task_list) end = time.time() print(f’发送100次请求，耗时：{end - start}’)asyncio.run(main())运行效果如下图所示：</p>\n<p><img src=\"https://pics3.baidu.com/feed/1f178a82b9014a90bef4207ee4fa2514b11beeba.jpeg?token=01173500e927b2967d8da8b7e470f17a&s=4418743BC15EC5CC404128DA000010B0\" alt=\"img\"></p>\n<p><strong>发送100次请求，httpx 异步模式耗时0.6秒左右。</strong></p>\n<p><strong>aiohttp</strong></p>\n<p>测试代码如下：</p>\n<p>import aiohttpimport randomimport datetimeimport asyncioimport timeasyncdefrequest(client, body): resp = await client.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json=body) result = await resp.json() print(result)asyncdefmain():asyncwith aiohttp.ClientSession() as client: start = time.time() task_list = []for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) req = request(client, {‘ts’: ts}) task = asyncio.create_task(req) task_list.append(task)await asyncio.gather(*task_list) end = time.time() print(f’发送100次请求，耗时：{end - start}’)asyncio.run(main())运行效果如下图所示：</p>\n<p><img src=\"https://pics3.baidu.com/feed/2e2eb9389b504fc2313ebc72a950fb1791ef6df3.jpeg?token=a595216712e08dec3f155133f27e38a4&s=E4986C3AC95EE5CC4CC544DE0000C0B1\" alt=\"img\"></p>\n<p><strong>发送100次请求，使用 aiohttp 耗时0.3秒左右</strong></p>\n<p>发送1000次请求</p>\n<p>由于 request 保持连接的速度比不保持连接快，所以我们这里只用保持连接的方式来测试。并且不打印返回的结果。</p>\n<p><strong>requests</strong></p>\n<p>运行效果如下图所示：</p>\n<p><img src=\"https://pics4.baidu.com/feed/359b033b5bb5c9ea40e4afa798b4aa063bf3b3f6.jpeg?token=514171994f18a98a6e7bb65e4ecff4ce&s=54087C3BD15FF5CC024548DA000080B1\" alt=\"img\"></p>\n<p><strong>发送1000次请求，requests 耗时16秒左右</strong></p>\n<p><strong>httpx</strong></p>\n<p>同步模式</p>\n<p>运行效果如下图所示：</p>\n<p><img src=\"https://pics6.baidu.com/feed/a1ec08fa513d26976689b5e21a76aefd4216d84e.jpeg?token=9306ad5ffa386a1d9a2227e36a4adbcf&s=D508743B915FD5CC045500DA0000C0B1\" alt=\"img\"></p>\n<p><strong>发送1000次请求，httpx 同步模式耗时18秒左右</strong></p>\n<p>异步模式</p>\n<p>运行效果如下图所示：</p>\n<p><img src=\"https://pics0.baidu.com/feed/7aec54e736d12f2e0585c540034fc964843568a5.jpeg?token=1f6bd37b4fc444498a0e7cb32ff03378&s=4018543BD15FC1CC584520DA000080B1\" alt=\"img\"></p>\n<p><strong>发送1000次请求，httpx 异步模式耗时5秒左右</strong></p>\n<p><strong>aiohttp</strong></p>\n<p>运行效果如下图所示：</p>\n<p><img src=\"https://pics7.baidu.com/feed/5366d0160924ab182be2692f7f77facb7a890b41.jpeg?token=1394197262765a9fda0b13fde6b4fbb9&s=4418643BD15FC1CC545564DA000080B2\" alt=\"img\"></p>\n<p><strong>发送1000次请求，aiohttp 耗时4秒左右</strong></p>\n<p>总结</p>\n<p>如果你只发几条请求。那么使用 requests 或者 httpx 的同步模式，代码最简单。</p>\n<p>如果你要发送很多请求，但是有些地方要发送同步请求，有些地方要发送异步请求，那么使用 httpx 最省事。</p>\n<p>如果你要发送很多请求，并且越快越好，那么使用 aiohttp 最快。</p>\n<p>这篇测评文章只是一个非常浅度的评测，只考虑了请求速度这一个角度。如果你要在生产环境使用，那么你可以做更多实验来看是不是符合你的实际使用情况。</p>\n<p>原文链接：<a href=\"https://baijiahao.baidu.com/s?id=1656736744425905392&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">https://baijiahao.baidu.com/s?id=1656736744425905392&amp;wfr=spider&amp;for=pc</a></p>\n","site":{"data":{}},"excerpt":"<p>在武汉，房子里待着，不出去影响世界了，转载点文章。","more":"</p>\n<p>在 Python 众多的 HTTP 客户端中，最有名的莫过于requests、aiohttp和httpx。在不借助其他第三方库的情况下，requests只能发送同步请求；aiohttp只能发送异步请求；httpx既能发送同步请求，又能发送异步请求。</p>\n<p>所谓的同步请求，是指在单进程单线程的代码中，发起一次请求后，在收到返回结果之前，不能发起下一次请求。所谓异步请求，是指在单进程单线程的代码中，发起一次请求后，在等待网站返回结果的时间里，可以继续发送更多请求。</p>\n<p>今天我们来一个浅度测评，仅仅以多次发送 POST 请求这个角度来对比这三个库的性能。</p>\n<p>测试使用的 HTTP 服务地址为<a href=\"http://122.51.39.219:8000/query，向它发送\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query，向它发送</a> POST 请求的格式如下图所示：</p>\n<p><img src=\"https://pics6.baidu.com/feed/0b46f21fbe096b6301e3838247be9b42e9f8acfa.jpeg?token=70d39787cf58d67bf77a9106c04807a4&s=C096E73B1CA8440D18E1A5DB0000E0B3\" alt=\"img\"></p>\n<p>请求发送的 ts 字段日期距离今天大于10天，那么返回{“success”: false}，如果小于等于10天，那么返回{“success”: true}。</p>\n<p>首先我们通过各个客户端使用相同的参数只发送一次请求，看看效果。</p>\n<p>发送一次请求</p>\n<p><strong>requests</strong></p>\n<p>import requestsresp = requests.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}).json()print(resp)运行效果如下图所示：</p>\n<p><img src=\"https://pics2.baidu.com/feed/63d9f2d3572c11df47d7597328aa7ed6f603c2f4.png?token=a37daa3c6812a2d7d1f92ffa76fd4e77&s=718A7D3B110E554D1674B0DA030050B0\" alt=\"img\"></p>\n<p><strong>httpx</strong></p>\n<p>使用 httpx 发送同步请求：</p>\n<p>import httpxresp = httpx.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}).json()print(resp)httpx 的同步模式与 requests 代码重合度99%，只需要把requests改成httpx即可正常运行。如下图所示：</p>\n<p><img src=\"https://pics4.baidu.com/feed/faedab64034f78f02435131e32bc1653b2191cb0.png?token=e3e2e21a11fa3f55e0d73094d6b578cd&s=718A7D3B110E554D1674B0DA030050B0\" alt=\"img\"></p>\n<p>使用 httpx 发送异步请求：</p>\n<p>import httpximport asyncioasyncdefmain():asyncwith httpx.AsyncClient() as client: resp = await client.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}) result = resp.json() print(result)asyncio.run(main())运行效果如下图所示：</p>\n<p><img src=\"https://pics2.baidu.com/feed/0823dd54564e9258a5a27545d20fcd5ecdbf4e1e.png?token=53fcebbef383dda74aa8d3adea337a1d&s=7108753B111E55CC4AC19DDA0300D0B1\" alt=\"img\"></p>\n<p><strong>aiohttp</strong></p>\n<p>import aiohttpimport asyncioasyncdefmain():asyncwith aiohttp.ClientSession() as client: resp = await client.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}) result = await resp.json() print(result)asyncio.run(main())运行效果如下图所示：</p>\n<p><img src=\"https://pics1.baidu.com/feed/0824ab18972bd407aed406f4310482570fb3093f.png?token=38acd3253e87bd2f0628fbf3c4781a70&s=7B08752B111E55CC42C11DDA0300D0B1\" alt=\"img\"></p>\n<p>aiohttp 的代码与 httpx 异步模式的代码重合度90%，只不过把AsyncClient换成了ClientSession，另外，在使用 httpx 时，当你await client.post时就已经发送了请求。但是当使用aiohttp时，只有在awiat resp.json() 时才会真正发送请求。</p>\n<p>发送100次请求</p>\n<p>我们现在随机生成一个距离今天在5-15天的日期，发送到 HTTP接口中。如果日期距离今天超过10天，那么返回的数据的 False，如果小于等于10天，那么返回的数据是 True。</p>\n<p>我们发送100次请求，计算总共耗时。</p>\n<p><strong>requests</strong></p>\n<p>在前几天的文章中，我们提到，使用requests.post每次都会创建新的连接，速度较慢。而如果首先初始化一个 Session，那么 requests 会保持连接，从而大大提高请求速度。所以在这次测评中，我们分别对两种情况进行测试。</p>\n<p>不保持连接</p>\n<p>import randomimport timeimport datetimeimport requestsdefmake_request(body): resp = requests.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)defmain(): start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) make_request({‘ts’: ts}) end = time.time() print(f’发送100次请求，耗时：{end - start}’)if <strong>name</strong> == ‘<strong>main</strong>‘: main()运行效果如下图所示：</p>\n<p><img src=\"https://pics2.baidu.com/feed/0ff41bd5ad6eddc4b5380c217356aafb506633a4.jpeg?token=8f345eb6f471f83547307a2770098fa4&s=E11A643B011ED5CE46D405DA0000C0B1\" alt=\"img\"></p>\n<p><strong>发送100次请求，requests 不保持连接时耗时2.7秒</strong></p>\n<p>保持连接</p>\n<p>对代码稍作修改，使用同一个 Session 发送请求：</p>\n<p>import randomimport timeimport datetimeimport requestsdefmake_request(session, body): resp = session.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)defmain(): session = requests.Session() start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) make_request(session, {‘ts’: ts}) end = time.time() print(f’发送100次请求，耗时：{end - start}’)if <strong>name</strong> == ‘<strong>main</strong>‘: main()运行效果如下图所示：</p>\n<p><img src=\"https://pics2.baidu.com/feed/1e30e924b899a901c2b847365718167d0308f5b0.jpeg?token=389373396414cd3fd0c8e558d2fcf9ac&s=F008743B811ED5CE004500DA0000C0B1\" alt=\"img\"></p>\n<p><strong>发送100次请求，requests 保持连接耗时1.4秒</strong></p>\n<p><strong>httpx</strong></p>\n<p>同步模式</p>\n<p>代码如下：</p>\n<p>import randomimport timeimport datetimeimport httpxdefmake_request(client, body): resp = client.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)defmain(): session = httpx.Client() start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) make_request(session, {‘ts’: ts}) end = time.time() print(f’发送100次请求，耗时：{end - start}’)if <strong>name</strong> == ‘<strong>main</strong>‘: main()运行效果如下图所示：</p>\n<p><img src=\"https://pics1.baidu.com/feed/f636afc379310a55c4caf697fdc85faf8326107d.jpeg?token=32ab623d88054400cb2bd2ba44f6a743&s=50087C3BC11ED5CC18D508DA0000C0B1\" alt=\"img\"></p>\n<p><strong>发送100次请求，httpx 同步模式耗时1.5秒左右。</strong></p>\n<p>异步模式</p>\n<p>代码如下：</p>\n<p>import httpximport randomimport datetimeimport asyncioimport timeasyncdefrequest(client, body): resp = await client.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)asyncdefmain():asyncwith httpx.AsyncClient() as client: start = time.time() task_list = []for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) req = request(client, {‘ts’: ts}) task = asyncio.create_task(req) task_list.append(task)await asyncio.gather(*task_list) end = time.time() print(f’发送100次请求，耗时：{end - start}’)asyncio.run(main())运行效果如下图所示：</p>\n<p><img src=\"https://pics3.baidu.com/feed/1f178a82b9014a90bef4207ee4fa2514b11beeba.jpeg?token=01173500e927b2967d8da8b7e470f17a&s=4418743BC15EC5CC404128DA000010B0\" alt=\"img\"></p>\n<p><strong>发送100次请求，httpx 异步模式耗时0.6秒左右。</strong></p>\n<p><strong>aiohttp</strong></p>\n<p>测试代码如下：</p>\n<p>import aiohttpimport randomimport datetimeimport asyncioimport timeasyncdefrequest(client, body): resp = await client.post(‘<a href=\"http://122.51.39.219:8000/query&#39;\" target=\"_blank\" rel=\"noopener\">http://122.51.39.219:8000/query&#39;</a>, json=body) result = await resp.json() print(result)asyncdefmain():asyncwith aiohttp.ClientSession() as client: start = time.time() task_list = []for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) req = request(client, {‘ts’: ts}) task = asyncio.create_task(req) task_list.append(task)await asyncio.gather(*task_list) end = time.time() print(f’发送100次请求，耗时：{end - start}’)asyncio.run(main())运行效果如下图所示：</p>\n<p><img src=\"https://pics3.baidu.com/feed/2e2eb9389b504fc2313ebc72a950fb1791ef6df3.jpeg?token=a595216712e08dec3f155133f27e38a4&s=E4986C3AC95EE5CC4CC544DE0000C0B1\" alt=\"img\"></p>\n<p><strong>发送100次请求，使用 aiohttp 耗时0.3秒左右</strong></p>\n<p>发送1000次请求</p>\n<p>由于 request 保持连接的速度比不保持连接快，所以我们这里只用保持连接的方式来测试。并且不打印返回的结果。</p>\n<p><strong>requests</strong></p>\n<p>运行效果如下图所示：</p>\n<p><img src=\"https://pics4.baidu.com/feed/359b033b5bb5c9ea40e4afa798b4aa063bf3b3f6.jpeg?token=514171994f18a98a6e7bb65e4ecff4ce&s=54087C3BD15FF5CC024548DA000080B1\" alt=\"img\"></p>\n<p><strong>发送1000次请求，requests 耗时16秒左右</strong></p>\n<p><strong>httpx</strong></p>\n<p>同步模式</p>\n<p>运行效果如下图所示：</p>\n<p><img src=\"https://pics6.baidu.com/feed/a1ec08fa513d26976689b5e21a76aefd4216d84e.jpeg?token=9306ad5ffa386a1d9a2227e36a4adbcf&s=D508743B915FD5CC045500DA0000C0B1\" alt=\"img\"></p>\n<p><strong>发送1000次请求，httpx 同步模式耗时18秒左右</strong></p>\n<p>异步模式</p>\n<p>运行效果如下图所示：</p>\n<p><img src=\"https://pics0.baidu.com/feed/7aec54e736d12f2e0585c540034fc964843568a5.jpeg?token=1f6bd37b4fc444498a0e7cb32ff03378&s=4018543BD15FC1CC584520DA000080B1\" alt=\"img\"></p>\n<p><strong>发送1000次请求，httpx 异步模式耗时5秒左右</strong></p>\n<p><strong>aiohttp</strong></p>\n<p>运行效果如下图所示：</p>\n<p><img src=\"https://pics7.baidu.com/feed/5366d0160924ab182be2692f7f77facb7a890b41.jpeg?token=1394197262765a9fda0b13fde6b4fbb9&s=4418643BD15FC1CC545564DA000080B2\" alt=\"img\"></p>\n<p><strong>发送1000次请求，aiohttp 耗时4秒左右</strong></p>\n<p>总结</p>\n<p>如果你只发几条请求。那么使用 requests 或者 httpx 的同步模式，代码最简单。</p>\n<p>如果你要发送很多请求，但是有些地方要发送同步请求，有些地方要发送异步请求，那么使用 httpx 最省事。</p>\n<p>如果你要发送很多请求，并且越快越好，那么使用 aiohttp 最快。</p>\n<p>这篇测评文章只是一个非常浅度的评测，只考虑了请求速度这一个角度。如果你要在生产环境使用，那么你可以做更多实验来看是不是符合你的实际使用情况。</p>\n<p>原文链接：<a href=\"https://baijiahao.baidu.com/s?id=1656736744425905392&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">https://baijiahao.baidu.com/s?id=1656736744425905392&amp;wfr=spider&amp;for=pc</a></p>"},{"title":"【测试理论】什么是Topic","abbrlink":"3457ed69","date":"2021-12-01T14:00:00.000Z","_content":"# 什么是Topic\n\nTopic是消息发布（Pub）者和订阅（Sub）者之间的传输中介。设备可通过Topic实现消息的发送和接收，从而实现服务端与设备端的通信。为方便海量设备基于Topic进行通信，简化授权操作，物联网平台定义了产品Topic类和设备Topic。本文介绍产品和设备Topic的定义、使用和分类。\n\n## Topic定义\n\n产品Topic类：产品维度的Topic，是同一产品下不同设备的Topic集合。一个Topic类对一个**ProductKey**下所有设备通用。\n\n以下是Topic类的使用说明：\n\n- 定义Topic的功能。\n\n  Topic类格式以正斜线（/）进行分层，区分每个类目。例如：`/${productKey}/${deviceName}/user/update`。\n\n  其中，${productKey}和${deviceName}两个类目为既定类目；后缀和前缀类目用于区分不同功能的消息。\n\n  - ${productKey}\n\n    表示产品的标识符\n\n    ProductKey\n\n    。\n\n    在指定产品的Topic类中，需替换为实际的**ProductKey**值。\n\n  - ${deviceName}\n\n    表示设备名称（\n\n    DeviceName\n\n    ）。\n\n    在产品Topic类中，${deviceName}是该产品下所有设备的名称变量，不需要替换为实际设备名称。\n\n- 定义Topic的操作权限。\n\n  - **发布**：产品下设备可以往该Topic发布消息。\n  - **订阅**：产品下设备可以订阅该Topic，从而获取消息。\n  - **发布和订阅**：同时具备**发布**和**订阅**的操作权限。\n\n在产品Topic类基础上，使用`${productKey}/${deviceName}`通配一个唯一的设备，与前缀、后缀类目组成的完整Topic，就是具体的设备Topic。\n\n设备Topic与产品Topic类格式一致，区别在于Topic类中的变量${deviceName}，在设备Topic中是具体的设备名称（**DeviceName**）。\n\n例如产品`a19mzPZ***`下设备`device1`和`device2`的具体Topic如下：\n\n- `/a19mzPZ****/device1/user/update`。\n- `/a19mzPZ****/device2/user/update`。\n\n产品Topic类定义的功能和操作权限，会映射到具体的设备Topic。以下是设备Topic的使用说明：\n\n- 具体的设备Topic可用于消息通信。\n\n- **注意** 在进行上下行通信调试时，请确保指定的Topic具备对应的操作权限。\n\n- 指定的设备Topic只能被指定设备用于消息通信。\n\n  例如，Topic：`/a19mzPZ****/device1/user/update`归属于设备device1，只能被设备device1用于发布或订阅消息，而不能被设备device2用于发布或订阅消息。\n\n- 您可管控单个设备的消息收发。\n\n  您可在[物联网平台控制台](https://iot.console.aliyun.com/)对应实例下的**设备列表**页面，或在服务端调用[DisableThing](https://help.aliyun.com/document_detail/69602.htm#doc-api-Iot-DisableThing)接口，禁用该设备；或在业务上管控发送给设备的消息。\n\n> 本文来源于：https://help.aliyun.com/document_detail/73731.html","source":"_posts/2021.12/【测试理论】什么是Topic.md","raw":"---\ntitle: 【测试理论】什么是Topic\ntags:\n  - MQ\nabbrlink: 3457ed69\ndate: 2021-12-01 22:00:00\n---\n# 什么是Topic\n\nTopic是消息发布（Pub）者和订阅（Sub）者之间的传输中介。设备可通过Topic实现消息的发送和接收，从而实现服务端与设备端的通信。为方便海量设备基于Topic进行通信，简化授权操作，物联网平台定义了产品Topic类和设备Topic。本文介绍产品和设备Topic的定义、使用和分类。\n\n## Topic定义\n\n产品Topic类：产品维度的Topic，是同一产品下不同设备的Topic集合。一个Topic类对一个**ProductKey**下所有设备通用。\n\n以下是Topic类的使用说明：\n\n- 定义Topic的功能。\n\n  Topic类格式以正斜线（/）进行分层，区分每个类目。例如：`/${productKey}/${deviceName}/user/update`。\n\n  其中，${productKey}和${deviceName}两个类目为既定类目；后缀和前缀类目用于区分不同功能的消息。\n\n  - ${productKey}\n\n    表示产品的标识符\n\n    ProductKey\n\n    。\n\n    在指定产品的Topic类中，需替换为实际的**ProductKey**值。\n\n  - ${deviceName}\n\n    表示设备名称（\n\n    DeviceName\n\n    ）。\n\n    在产品Topic类中，${deviceName}是该产品下所有设备的名称变量，不需要替换为实际设备名称。\n\n- 定义Topic的操作权限。\n\n  - **发布**：产品下设备可以往该Topic发布消息。\n  - **订阅**：产品下设备可以订阅该Topic，从而获取消息。\n  - **发布和订阅**：同时具备**发布**和**订阅**的操作权限。\n\n在产品Topic类基础上，使用`${productKey}/${deviceName}`通配一个唯一的设备，与前缀、后缀类目组成的完整Topic，就是具体的设备Topic。\n\n设备Topic与产品Topic类格式一致，区别在于Topic类中的变量${deviceName}，在设备Topic中是具体的设备名称（**DeviceName**）。\n\n例如产品`a19mzPZ***`下设备`device1`和`device2`的具体Topic如下：\n\n- `/a19mzPZ****/device1/user/update`。\n- `/a19mzPZ****/device2/user/update`。\n\n产品Topic类定义的功能和操作权限，会映射到具体的设备Topic。以下是设备Topic的使用说明：\n\n- 具体的设备Topic可用于消息通信。\n\n- **注意** 在进行上下行通信调试时，请确保指定的Topic具备对应的操作权限。\n\n- 指定的设备Topic只能被指定设备用于消息通信。\n\n  例如，Topic：`/a19mzPZ****/device1/user/update`归属于设备device1，只能被设备device1用于发布或订阅消息，而不能被设备device2用于发布或订阅消息。\n\n- 您可管控单个设备的消息收发。\n\n  您可在[物联网平台控制台](https://iot.console.aliyun.com/)对应实例下的**设备列表**页面，或在服务端调用[DisableThing](https://help.aliyun.com/document_detail/69602.htm#doc-api-Iot-DisableThing)接口，禁用该设备；或在业务上管控发送给设备的消息。\n\n> 本文来源于：https://help.aliyun.com/document_detail/73731.html","slug":"2021.12/【测试理论】什么是Topic","published":1,"updated":"2021-12-01T14:00:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wo000vn4epa5d33ejx","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"什么是Topic\"><a href=\"#什么是Topic\" class=\"headerlink\" title=\"什么是Topic\"></a>什么是Topic</h1><p>Topic是消息发布（Pub）者和订阅（Sub）者之间的传输中介。设备可通过Topic实现消息的发送和接收，从而实现服务端与设备端的通信。为方便海量设备基于Topic进行通信，简化授权操作，物联网平台定义了产品Topic类和设备Topic。本文介绍产品和设备Topic的定义、使用和分类。</p>\n<h2 id=\"Topic定义\"><a href=\"#Topic定义\" class=\"headerlink\" title=\"Topic定义\"></a>Topic定义</h2><p>产品Topic类：产品维度的Topic，是同一产品下不同设备的Topic集合。一个Topic类对一个<strong>ProductKey</strong>下所有设备通用。</p>\n<p>以下是Topic类的使用说明：</p>\n<ul>\n<li><p>定义Topic的功能。</p>\n<p>Topic类格式以正斜线（/）进行分层，区分每个类目。例如：<code>/${productKey}/${deviceName}/user/update</code>。</p>\n<p>其中，${productKey}和${deviceName}两个类目为既定类目；后缀和前缀类目用于区分不同功能的消息。</p>\n<ul>\n<li><p>${productKey}</p>\n<p>表示产品的标识符</p>\n<p>ProductKey</p>\n<p>。</p>\n<p>在指定产品的Topic类中，需替换为实际的<strong>ProductKey</strong>值。</p>\n</li>\n<li><p>${deviceName}</p>\n<p>表示设备名称（</p>\n<p>DeviceName</p>\n<p>）。</p>\n<p>在产品Topic类中，${deviceName}是该产品下所有设备的名称变量，不需要替换为实际设备名称。</p>\n</li>\n</ul>\n</li>\n<li><p>定义Topic的操作权限。</p>\n<ul>\n<li><strong>发布</strong>：产品下设备可以往该Topic发布消息。</li>\n<li><strong>订阅</strong>：产品下设备可以订阅该Topic，从而获取消息。</li>\n<li><strong>发布和订阅</strong>：同时具备<strong>发布</strong>和<strong>订阅</strong>的操作权限。</li>\n</ul>\n</li>\n</ul>\n<p>在产品Topic类基础上，使用<code>${productKey}/${deviceName}</code>通配一个唯一的设备，与前缀、后缀类目组成的完整Topic，就是具体的设备Topic。</p>\n<p>设备Topic与产品Topic类格式一致，区别在于Topic类中的变量${deviceName}，在设备Topic中是具体的设备名称（<strong>DeviceName</strong>）。</p>\n<p>例如产品<code>a19mzPZ***</code>下设备<code>device1</code>和<code>device2</code>的具体Topic如下：</p>\n<ul>\n<li><code>/a19mzPZ****/device1/user/update</code>。</li>\n<li><code>/a19mzPZ****/device2/user/update</code>。</li>\n</ul>\n<p>产品Topic类定义的功能和操作权限，会映射到具体的设备Topic。以下是设备Topic的使用说明：</p>\n<ul>\n<li><p>具体的设备Topic可用于消息通信。</p>\n</li>\n<li><p><strong>注意</strong> 在进行上下行通信调试时，请确保指定的Topic具备对应的操作权限。</p>\n</li>\n<li><p>指定的设备Topic只能被指定设备用于消息通信。</p>\n<p>例如，Topic：<code>/a19mzPZ****/device1/user/update</code>归属于设备device1，只能被设备device1用于发布或订阅消息，而不能被设备device2用于发布或订阅消息。</p>\n</li>\n<li><p>您可管控单个设备的消息收发。</p>\n<p>您可在<a href=\"https://iot.console.aliyun.com/\" target=\"_blank\" rel=\"noopener\">物联网平台控制台</a>对应实例下的<strong>设备列表</strong>页面，或在服务端调用<a href=\"https://help.aliyun.com/document_detail/69602.htm#doc-api-Iot-DisableThing\" target=\"_blank\" rel=\"noopener\">DisableThing</a>接口，禁用该设备；或在业务上管控发送给设备的消息。</p>\n</li>\n</ul>\n<blockquote>\n<p>本文来源于：<a href=\"https://help.aliyun.com/document_detail/73731.html\" target=\"_blank\" rel=\"noopener\">https://help.aliyun.com/document_detail/73731.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是Topic\"><a href=\"#什么是Topic\" class=\"headerlink\" title=\"什么是Topic\"></a>什么是Topic</h1><p>Topic是消息发布（Pub）者和订阅（Sub）者之间的传输中介。设备可通过Topic实现消息的发送和接收，从而实现服务端与设备端的通信。为方便海量设备基于Topic进行通信，简化授权操作，物联网平台定义了产品Topic类和设备Topic。本文介绍产品和设备Topic的定义、使用和分类。</p>\n<h2 id=\"Topic定义\"><a href=\"#Topic定义\" class=\"headerlink\" title=\"Topic定义\"></a>Topic定义</h2><p>产品Topic类：产品维度的Topic，是同一产品下不同设备的Topic集合。一个Topic类对一个<strong>ProductKey</strong>下所有设备通用。</p>\n<p>以下是Topic类的使用说明：</p>\n<ul>\n<li><p>定义Topic的功能。</p>\n<p>Topic类格式以正斜线（/）进行分层，区分每个类目。例如：<code>/${productKey}/${deviceName}/user/update</code>。</p>\n<p>其中，${productKey}和${deviceName}两个类目为既定类目；后缀和前缀类目用于区分不同功能的消息。</p>\n<ul>\n<li><p>${productKey}</p>\n<p>表示产品的标识符</p>\n<p>ProductKey</p>\n<p>。</p>\n<p>在指定产品的Topic类中，需替换为实际的<strong>ProductKey</strong>值。</p>\n</li>\n<li><p>${deviceName}</p>\n<p>表示设备名称（</p>\n<p>DeviceName</p>\n<p>）。</p>\n<p>在产品Topic类中，${deviceName}是该产品下所有设备的名称变量，不需要替换为实际设备名称。</p>\n</li>\n</ul>\n</li>\n<li><p>定义Topic的操作权限。</p>\n<ul>\n<li><strong>发布</strong>：产品下设备可以往该Topic发布消息。</li>\n<li><strong>订阅</strong>：产品下设备可以订阅该Topic，从而获取消息。</li>\n<li><strong>发布和订阅</strong>：同时具备<strong>发布</strong>和<strong>订阅</strong>的操作权限。</li>\n</ul>\n</li>\n</ul>\n<p>在产品Topic类基础上，使用<code>${productKey}/${deviceName}</code>通配一个唯一的设备，与前缀、后缀类目组成的完整Topic，就是具体的设备Topic。</p>\n<p>设备Topic与产品Topic类格式一致，区别在于Topic类中的变量${deviceName}，在设备Topic中是具体的设备名称（<strong>DeviceName</strong>）。</p>\n<p>例如产品<code>a19mzPZ***</code>下设备<code>device1</code>和<code>device2</code>的具体Topic如下：</p>\n<ul>\n<li><code>/a19mzPZ****/device1/user/update</code>。</li>\n<li><code>/a19mzPZ****/device2/user/update</code>。</li>\n</ul>\n<p>产品Topic类定义的功能和操作权限，会映射到具体的设备Topic。以下是设备Topic的使用说明：</p>\n<ul>\n<li><p>具体的设备Topic可用于消息通信。</p>\n</li>\n<li><p><strong>注意</strong> 在进行上下行通信调试时，请确保指定的Topic具备对应的操作权限。</p>\n</li>\n<li><p>指定的设备Topic只能被指定设备用于消息通信。</p>\n<p>例如，Topic：<code>/a19mzPZ****/device1/user/update</code>归属于设备device1，只能被设备device1用于发布或订阅消息，而不能被设备device2用于发布或订阅消息。</p>\n</li>\n<li><p>您可管控单个设备的消息收发。</p>\n<p>您可在<a href=\"https://iot.console.aliyun.com/\" target=\"_blank\" rel=\"noopener\">物联网平台控制台</a>对应实例下的<strong>设备列表</strong>页面，或在服务端调用<a href=\"https://help.aliyun.com/document_detail/69602.htm#doc-api-Iot-DisableThing\" target=\"_blank\" rel=\"noopener\">DisableThing</a>接口，禁用该设备；或在业务上管控发送给设备的消息。</p>\n</li>\n</ul>\n<blockquote>\n<p>本文来源于：<a href=\"https://help.aliyun.com/document_detail/73731.html\" target=\"_blank\" rel=\"noopener\">https://help.aliyun.com/document_detail/73731.html</a></p>\n</blockquote>\n"},{"title":"【测试理论】做自动化遇到的测试环境差异问题","abbrlink":"3e4105ad","date":"2021-12-02T14:11:17.000Z","_content":"\n#### 最近公司在做接口自动化测试记录一下遇到的问题:\n\n##### 测试环境差异：\n\n###### 测试环境：\n\n1、测试环境可直接调用，业务不会触发反作弊系统，不需要加白名单。\n\n2、可随意操作数据库，增删改查都可操作。\n\n###### 预发环境：\n\n1、预发环境与线上环境相差无几，除了与线上系统隔离外，有线上系统的全部能力。如果要在预发环境做接口测试，需要加各种业务的白名单。\n\n2、同时想要访问预发环境的服务，需要在被测系统&依赖服务机器上加运行自动化机器的白名单，才可正常访问预发环境的各个服务。\n\n3、预发环境的数据库一般和生产环境用一套环境，一般情况下，是不允许删除操作的，所以在预发环境最多可执行更新操作。","source":"_posts/2021.12/【测试理论】做自动化遇到的测试环境差异问题.md","raw":"---\ntitle: 【测试理论】做自动化遇到的测试环境差异问题\nabbrlink: 3e4105ad\ndate: 2021-12-02 22:11:17\ntags:\n\t- 自动化测试\n---\n\n#### 最近公司在做接口自动化测试记录一下遇到的问题:\n\n##### 测试环境差异：\n\n###### 测试环境：\n\n1、测试环境可直接调用，业务不会触发反作弊系统，不需要加白名单。\n\n2、可随意操作数据库，增删改查都可操作。\n\n###### 预发环境：\n\n1、预发环境与线上环境相差无几，除了与线上系统隔离外，有线上系统的全部能力。如果要在预发环境做接口测试，需要加各种业务的白名单。\n\n2、同时想要访问预发环境的服务，需要在被测系统&依赖服务机器上加运行自动化机器的白名单，才可正常访问预发环境的各个服务。\n\n3、预发环境的数据库一般和生产环境用一套环境，一般情况下，是不允许删除操作的，所以在预发环境最多可执行更新操作。","slug":"2021.12/【测试理论】做自动化遇到的测试环境差异问题","published":1,"updated":"2021-12-02T14:11:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wp000wn4ep4p30grm9","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h4 id=\"最近公司在做接口自动化测试记录一下遇到的问题\"><a href=\"#最近公司在做接口自动化测试记录一下遇到的问题\" class=\"headerlink\" title=\"最近公司在做接口自动化测试记录一下遇到的问题:\"></a>最近公司在做接口自动化测试记录一下遇到的问题:</h4><h5 id=\"测试环境差异：\"><a href=\"#测试环境差异：\" class=\"headerlink\" title=\"测试环境差异：\"></a>测试环境差异：</h5><h6 id=\"测试环境：\"><a href=\"#测试环境：\" class=\"headerlink\" title=\"测试环境：\"></a>测试环境：</h6><p>1、测试环境可直接调用，业务不会触发反作弊系统，不需要加白名单。</p>\n<p>2、可随意操作数据库，增删改查都可操作。</p>\n<h6 id=\"预发环境：\"><a href=\"#预发环境：\" class=\"headerlink\" title=\"预发环境：\"></a>预发环境：</h6><p>1、预发环境与线上环境相差无几，除了与线上系统隔离外，有线上系统的全部能力。如果要在预发环境做接口测试，需要加各种业务的白名单。</p>\n<p>2、同时想要访问预发环境的服务，需要在被测系统&amp;依赖服务机器上加运行自动化机器的白名单，才可正常访问预发环境的各个服务。</p>\n<p>3、预发环境的数据库一般和生产环境用一套环境，一般情况下，是不允许删除操作的，所以在预发环境最多可执行更新操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"最近公司在做接口自动化测试记录一下遇到的问题\"><a href=\"#最近公司在做接口自动化测试记录一下遇到的问题\" class=\"headerlink\" title=\"最近公司在做接口自动化测试记录一下遇到的问题:\"></a>最近公司在做接口自动化测试记录一下遇到的问题:</h4><h5 id=\"测试环境差异：\"><a href=\"#测试环境差异：\" class=\"headerlink\" title=\"测试环境差异：\"></a>测试环境差异：</h5><h6 id=\"测试环境：\"><a href=\"#测试环境：\" class=\"headerlink\" title=\"测试环境：\"></a>测试环境：</h6><p>1、测试环境可直接调用，业务不会触发反作弊系统，不需要加白名单。</p>\n<p>2、可随意操作数据库，增删改查都可操作。</p>\n<h6 id=\"预发环境：\"><a href=\"#预发环境：\" class=\"headerlink\" title=\"预发环境：\"></a>预发环境：</h6><p>1、预发环境与线上环境相差无几，除了与线上系统隔离外，有线上系统的全部能力。如果要在预发环境做接口测试，需要加各种业务的白名单。</p>\n<p>2、同时想要访问预发环境的服务，需要在被测系统&amp;依赖服务机器上加运行自动化机器的白名单，才可正常访问预发环境的各个服务。</p>\n<p>3、预发环境的数据库一般和生产环境用一套环境，一般情况下，是不允许删除操作的，所以在预发环境最多可执行更新操作。</p>\n"},{"title":"【自动化库】异步http接口调用库：httpx","abbrlink":"b4b3bf4e","cover":"https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/8.png","date":"2021-12-10T15:02:26.000Z","_content":"\n谈到http接口调用，Requests大家并不陌生，例如，robotframework-requests、HttpRunner等HTTP接口测试库/框架都是基于它开发。这里将介绍另一款http接口测试框架:httpx。 <!-- more --> \n\n它的API和Requests高度一致。\n\ngithub: https://github.com/encode/httpx\n\n安装：\n\n```shell\n> pip install httpx\n```\n\n## httpx 简单使用\n\n当然，它是不支持python2.x的。\n\n- 简单的get调用\n\n```py\nimport httpx\n\nr = httpx.get(\"http://httpbin.org/get\")\nprint(r.status_code)\nprint(r.json())\n```\n\n执行结果：\n\n```json\n200\n{'args': {}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': 'python-httpx/0.12.1', 'X-Amzn-Trace-Id': 'Root=1-5ea5b58c-e446c44392ea090809e8a4bc'}, 'origin': '113.97.33.224', 'url': 'http://httpbin.org/get'}\n```\n\n- 带参数的post调用\n\n```python\nimport httpx\n\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = httpx.post(\"http://httpbin.org/post\", data=payload)\nprint(r.json())\n```\n\n执行结果：\n\n```shell\n{'args': {}, 'data': '', 'files': {}, 'form': {'key1': 'value1', 'key2': 'value2'}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Content-Length': '23', 'Content-Type': 'application/x-www-form-urlencoded', 'Host': 'httpbin.org', 'User-Agent': 'python-httpx/0.12.1', 'X-Amzn-Trace-Id': 'Root=1-5ea5b61d-1871d10e80b8324e48ea475e'}, 'json': None, 'origin': '113.97.33.224', 'url': 'http://httpbin.org/post'}\n```\n\n你会发现这几乎和requests一模一样，只不过把requests 换成了httpx。\n\n## httpx 异步调用\n\n接下来认识httpx的异步调用：\n\n```python\nimport httpx\nimport asyncio\n\n\nasync def main():\n    async with httpx.AsyncClient() as client:\n        resp = await client.get('http://httpbin.org/get')\n        result = resp.json()\n        print(result)\n\n\nasyncio.run(main())\n```\n\n这里用到了async 、await， asyncio等，等参考我关于python异步I/O的基础介绍：https://www.cnblogs.com/fnng/p/12757395.html\n\n## 异步的调用的优势\n\n我们发现，采用异步会让接口的调用更加复杂，那为什么还要使用异步呢？当你要调用1000次接口时，那么异步调用可以让你的调用更快。接下来我们通过简单让例子进行对比。\n\n以我flask开发的简单接口为例子：\n\nhttps://github.com/defnngj/learning-API-test\n\n> 为了测试的更加准确性，我将flask服务部署在了另一台电脑，测试机与被测服务分离。\n\n- httpx 同步调用\n\n```py\n# 同步调用\nimport time\nimport httpx\n\n\ndef make_request(client):\n    resp = client.get('http://192.168.0.7:5000')\n    result = resp.json()\n    # print(result)\n    assert result[\"code\"] == 10200\n\ndef main():\n    session = httpx.Client()\n\n    # 1000 次调用\n    for _ in range(1000):\n        make_request(session)\n\n\nif __name__ == '__main__':\n    # 开始\n    start = time.time()\n    main()\n    # 结束\n    end = time.time()\n    print(f'同步：发送1000次请求，耗时：{end - start}')\n```\n\n结果：\n\n```\n...\n同步：发送1000次请求，耗时：52.948561906814575\n```\n\n- httpx 异步调用\n\n```py\n# 异步调用\nimport httpx\nimport asyncio\nimport time\n\nasync def request(client):\n    resp = await client.get('http://192.168.0.7:5000')\n    result = resp.json()\n    # print(result)\n    assert result[\"code\"] == 10200\n\n\nasync def main():\n    async with httpx.AsyncClient() as client:\n        # # 开始\n        # start = time.time()\n\n        # 1000 次调用\n        task_list = []\n        for _ in range(1000):\n            req = request(client)\n            task = asyncio.create_task(req)\n            task_list.append(task)\n        await asyncio.gather(*task_list)\n\n\nif __name__ == \"__main__\":\n    #开始\n    start = time.time()\n    asyncio.run(main())\n    # 结束\n    end = time.time()\n    print(f'异步：发送1000次请求，耗时：{end - start}')\n```\n\n结果:\n\n```\n...\n异步：发送1000次请求，耗时：3.903275728225708\n```\n\n将httpx用于请求端，同步与异步请求差距非常明显。\n\n以上的例子已经放到 learning-API-test github项目\n\n## 总结\n\n*　这里只是拿 flask 非异步框架做为接口服务端进行对比，如果如果将接口服务同样换作前面介绍的 snaic 异步框架，上面的两组测试对比并不明显（snaic的异步接口服务处理同步请求更快），在安装 snaic的时候会发现，他同样也集成了 httpx 库。\n\n*　为什么要学习异步，因为我们公司有很多接口是异步调用的，所以，我想真正搞懂这个概念，就这么简单！保持在工作中对技术的好奇心。\n\n- 异步与多线程的区别？这是我在学习 异步时候的一个疑问，我找到了一个比较形象的例子。\n\n> 以火车站购票场景为例：一个火车站为一个进程，一个窗口和售票员的组合为一个线程：\n\n> - 多线程：火车站开了N个窗口售票员，我们去买票，会有工作人员（CPU）指定我们去某个窗口买票，你被安排到某个窗口后，告诉售票员你的请求（咨询或买票），售票员执行操作，如果这个过程中发送的阻塞，也是窗口售票员的阻塞（比如查票的过程），但是因为你开了很多个窗口，其他买票的人可以被安排去另外的空闲窗口，如果所有窗口都满了，工作人员就不会给你安排了，直到有空的窗口出来；\n> - 多进程（并行）：建多个火车站售票，火车站与火车站间互不影响，看买票的自己想去哪里（这里不讨论负载均衡）；\n> - 异步：火车站只有一个窗口售票员，但是窗口前有一个登记台（事件循环），你把你想买的票告诉给登记台，并留下你的手机（回调函数），然后你就可以走了，由于登记台只是登记了你的请求，并没有做任何其他操作，所以这个耗时基本忽略不计的。之后售票员处理完了上一个任务了，就会自己去登记台取剩下的未完成的任务，直到取到你的任务，操作完后，有票没票都会通过手机通知你，如果有票还会往你的手机发车票的二维码；","source":"_posts/2021.12/【自动化库】异步http接口调用库：httpx.md","raw":"---\ntitle: 【自动化库】异步http接口调用库：httpx\nabbrlink: b4b3bf4e\ncover: https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/8.png\ndate: 2021-12-10 23:02:26\ntags:\n---\n\n谈到http接口调用，Requests大家并不陌生，例如，robotframework-requests、HttpRunner等HTTP接口测试库/框架都是基于它开发。这里将介绍另一款http接口测试框架:httpx。 <!-- more --> \n\n它的API和Requests高度一致。\n\ngithub: https://github.com/encode/httpx\n\n安装：\n\n```shell\n> pip install httpx\n```\n\n## httpx 简单使用\n\n当然，它是不支持python2.x的。\n\n- 简单的get调用\n\n```py\nimport httpx\n\nr = httpx.get(\"http://httpbin.org/get\")\nprint(r.status_code)\nprint(r.json())\n```\n\n执行结果：\n\n```json\n200\n{'args': {}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': 'python-httpx/0.12.1', 'X-Amzn-Trace-Id': 'Root=1-5ea5b58c-e446c44392ea090809e8a4bc'}, 'origin': '113.97.33.224', 'url': 'http://httpbin.org/get'}\n```\n\n- 带参数的post调用\n\n```python\nimport httpx\n\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = httpx.post(\"http://httpbin.org/post\", data=payload)\nprint(r.json())\n```\n\n执行结果：\n\n```shell\n{'args': {}, 'data': '', 'files': {}, 'form': {'key1': 'value1', 'key2': 'value2'}, 'headers': {'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Content-Length': '23', 'Content-Type': 'application/x-www-form-urlencoded', 'Host': 'httpbin.org', 'User-Agent': 'python-httpx/0.12.1', 'X-Amzn-Trace-Id': 'Root=1-5ea5b61d-1871d10e80b8324e48ea475e'}, 'json': None, 'origin': '113.97.33.224', 'url': 'http://httpbin.org/post'}\n```\n\n你会发现这几乎和requests一模一样，只不过把requests 换成了httpx。\n\n## httpx 异步调用\n\n接下来认识httpx的异步调用：\n\n```python\nimport httpx\nimport asyncio\n\n\nasync def main():\n    async with httpx.AsyncClient() as client:\n        resp = await client.get('http://httpbin.org/get')\n        result = resp.json()\n        print(result)\n\n\nasyncio.run(main())\n```\n\n这里用到了async 、await， asyncio等，等参考我关于python异步I/O的基础介绍：https://www.cnblogs.com/fnng/p/12757395.html\n\n## 异步的调用的优势\n\n我们发现，采用异步会让接口的调用更加复杂，那为什么还要使用异步呢？当你要调用1000次接口时，那么异步调用可以让你的调用更快。接下来我们通过简单让例子进行对比。\n\n以我flask开发的简单接口为例子：\n\nhttps://github.com/defnngj/learning-API-test\n\n> 为了测试的更加准确性，我将flask服务部署在了另一台电脑，测试机与被测服务分离。\n\n- httpx 同步调用\n\n```py\n# 同步调用\nimport time\nimport httpx\n\n\ndef make_request(client):\n    resp = client.get('http://192.168.0.7:5000')\n    result = resp.json()\n    # print(result)\n    assert result[\"code\"] == 10200\n\ndef main():\n    session = httpx.Client()\n\n    # 1000 次调用\n    for _ in range(1000):\n        make_request(session)\n\n\nif __name__ == '__main__':\n    # 开始\n    start = time.time()\n    main()\n    # 结束\n    end = time.time()\n    print(f'同步：发送1000次请求，耗时：{end - start}')\n```\n\n结果：\n\n```\n...\n同步：发送1000次请求，耗时：52.948561906814575\n```\n\n- httpx 异步调用\n\n```py\n# 异步调用\nimport httpx\nimport asyncio\nimport time\n\nasync def request(client):\n    resp = await client.get('http://192.168.0.7:5000')\n    result = resp.json()\n    # print(result)\n    assert result[\"code\"] == 10200\n\n\nasync def main():\n    async with httpx.AsyncClient() as client:\n        # # 开始\n        # start = time.time()\n\n        # 1000 次调用\n        task_list = []\n        for _ in range(1000):\n            req = request(client)\n            task = asyncio.create_task(req)\n            task_list.append(task)\n        await asyncio.gather(*task_list)\n\n\nif __name__ == \"__main__\":\n    #开始\n    start = time.time()\n    asyncio.run(main())\n    # 结束\n    end = time.time()\n    print(f'异步：发送1000次请求，耗时：{end - start}')\n```\n\n结果:\n\n```\n...\n异步：发送1000次请求，耗时：3.903275728225708\n```\n\n将httpx用于请求端，同步与异步请求差距非常明显。\n\n以上的例子已经放到 learning-API-test github项目\n\n## 总结\n\n*　这里只是拿 flask 非异步框架做为接口服务端进行对比，如果如果将接口服务同样换作前面介绍的 snaic 异步框架，上面的两组测试对比并不明显（snaic的异步接口服务处理同步请求更快），在安装 snaic的时候会发现，他同样也集成了 httpx 库。\n\n*　为什么要学习异步，因为我们公司有很多接口是异步调用的，所以，我想真正搞懂这个概念，就这么简单！保持在工作中对技术的好奇心。\n\n- 异步与多线程的区别？这是我在学习 异步时候的一个疑问，我找到了一个比较形象的例子。\n\n> 以火车站购票场景为例：一个火车站为一个进程，一个窗口和售票员的组合为一个线程：\n\n> - 多线程：火车站开了N个窗口售票员，我们去买票，会有工作人员（CPU）指定我们去某个窗口买票，你被安排到某个窗口后，告诉售票员你的请求（咨询或买票），售票员执行操作，如果这个过程中发送的阻塞，也是窗口售票员的阻塞（比如查票的过程），但是因为你开了很多个窗口，其他买票的人可以被安排去另外的空闲窗口，如果所有窗口都满了，工作人员就不会给你安排了，直到有空的窗口出来；\n> - 多进程（并行）：建多个火车站售票，火车站与火车站间互不影响，看买票的自己想去哪里（这里不讨论负载均衡）；\n> - 异步：火车站只有一个窗口售票员，但是窗口前有一个登记台（事件循环），你把你想买的票告诉给登记台，并留下你的手机（回调函数），然后你就可以走了，由于登记台只是登记了你的请求，并没有做任何其他操作，所以这个耗时基本忽略不计的。之后售票员处理完了上一个任务了，就会自己去登记台取剩下的未完成的任务，直到取到你的任务，操作完后，有票没票都会通过手机通知你，如果有票还会往你的手机发车票的二维码；","slug":"2021.12/【自动化库】异步http接口调用库：httpx","published":1,"updated":"2021-12-10T15:02:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wq000yn4ep82yo8mwh","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>谈到http接口调用，Requests大家并不陌生，例如，robotframework-requests、HttpRunner等HTTP接口测试库/框架都是基于它开发。这里将介绍另一款http接口测试框架:httpx。 <a id=\"more\"></a> </p>\n<p>它的API和Requests高度一致。</p>\n<p>github: <a href=\"https://github.com/encode/httpx\" target=\"_blank\" rel=\"noopener\">https://github.com/encode/httpx</a></p>\n<p>安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> pip install httpx</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"httpx-简单使用\"><a href=\"#httpx-简单使用\" class=\"headerlink\" title=\"httpx 简单使用\"></a>httpx 简单使用</h2><p>当然，它是不支持python2.x的。</p>\n<ul>\n<li>简单的get调用</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> httpx</span><br><span class=\"line\"></span><br><span class=\"line\">r = httpx.get(<span class=\"string\">\"http://httpbin.org/get\"</span>)</span><br><span class=\"line\">print(r.status_code)</span><br><span class=\"line\">print(r.json())</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span></span><br><span class=\"line\">&#123;'args': &#123;&#125;, 'headers': &#123;'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': 'python-httpx/0.12.1', 'X-Amzn-Trace-Id': 'Root=1-5ea5b58c-e446c44392ea090809e8a4bc'&#125;, 'origin': '113.97.33.224', 'url': 'http://httpbin.org/get'&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>带参数的post调用</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> httpx</span><br><span class=\"line\"></span><br><span class=\"line\">payload = &#123;<span class=\"string\">'key1'</span>: <span class=\"string\">'value1'</span>, <span class=\"string\">'key2'</span>: <span class=\"string\">'value2'</span>&#125;</span><br><span class=\"line\">r = httpx.post(<span class=\"string\">\"http://httpbin.org/post\"</span>, data=payload)</span><br><span class=\"line\">print(r.json())</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;'args': &#123;&#125;, 'data': '', 'files': &#123;&#125;, 'form': &#123;'key1': 'value1', 'key2': 'value2'&#125;, 'headers': &#123;'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Content-Length': '23', 'Content-Type': 'application/x-www-form-urlencoded', 'Host': 'httpbin.org', 'User-Agent': 'python-httpx/0.12.1', 'X-Amzn-Trace-Id': 'Root=1-5ea5b61d-1871d10e80b8324e48ea475e'&#125;, 'json': None, 'origin': '113.97.33.224', 'url': 'http://httpbin.org/post'&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你会发现这几乎和requests一模一样，只不过把requests 换成了httpx。</p>\n<h2 id=\"httpx-异步调用\"><a href=\"#httpx-异步调用\" class=\"headerlink\" title=\"httpx 异步调用\"></a>httpx 异步调用</h2><p>接下来认识httpx的异步调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> httpx</span><br><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> httpx.AsyncClient() <span class=\"keyword\">as</span> client:</span><br><span class=\"line\">        resp = <span class=\"keyword\">await</span> client.get(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br><span class=\"line\">        result = resp.json()</span><br><span class=\"line\">        print(result)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">asyncio.run(main())</span><br></pre></td></tr></table></figure>\n\n<p>这里用到了async 、await， asyncio等，等参考我关于python异步I/O的基础介绍：<a href=\"https://www.cnblogs.com/fnng/p/12757395.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/fnng/p/12757395.html</a></p>\n<h2 id=\"异步的调用的优势\"><a href=\"#异步的调用的优势\" class=\"headerlink\" title=\"异步的调用的优势\"></a>异步的调用的优势</h2><p>我们发现，采用异步会让接口的调用更加复杂，那为什么还要使用异步呢？当你要调用1000次接口时，那么异步调用可以让你的调用更快。接下来我们通过简单让例子进行对比。</p>\n<p>以我flask开发的简单接口为例子：</p>\n<p><a href=\"https://github.com/defnngj/learning-API-test\" target=\"_blank\" rel=\"noopener\">https://github.com/defnngj/learning-API-test</a></p>\n<blockquote>\n<p>为了测试的更加准确性，我将flask服务部署在了另一台电脑，测试机与被测服务分离。</p>\n</blockquote>\n<ul>\n<li>httpx 同步调用</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 同步调用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> httpx</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_request</span><span class=\"params\">(client)</span>:</span></span><br><span class=\"line\">    resp = client.get(<span class=\"string\">'http://192.168.0.7:5000'</span>)</span><br><span class=\"line\">    result = resp.json()</span><br><span class=\"line\">    <span class=\"comment\"># print(result)</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> result[<span class=\"string\">\"code\"</span>] == <span class=\"number\">10200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    session = httpx.Client()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 1000 次调用</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">1000</span>):</span><br><span class=\"line\">        make_request(session)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 开始</span></span><br><span class=\"line\">    start = time.time()</span><br><span class=\"line\">    main()</span><br><span class=\"line\">    <span class=\"comment\"># 结束</span></span><br><span class=\"line\">    end = time.time()</span><br><span class=\"line\">    print(<span class=\"string\">f'同步：发送1000次请求，耗时：<span class=\"subst\">&#123;end - start&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">同步：发送1000次请求，耗时：52.948561906814575</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>httpx 异步调用</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 异步调用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> httpx</span><br><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">request</span><span class=\"params\">(client)</span>:</span></span><br><span class=\"line\">    resp = <span class=\"keyword\">await</span> client.get(<span class=\"string\">'http://192.168.0.7:5000'</span>)</span><br><span class=\"line\">    result = resp.json()</span><br><span class=\"line\">    <span class=\"comment\"># print(result)</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> result[<span class=\"string\">\"code\"</span>] == <span class=\"number\">10200</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> httpx.AsyncClient() <span class=\"keyword\">as</span> client:</span><br><span class=\"line\">        <span class=\"comment\"># # 开始</span></span><br><span class=\"line\">        <span class=\"comment\"># start = time.time()</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 1000 次调用</span></span><br><span class=\"line\">        task_list = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">1000</span>):</span><br><span class=\"line\">            req = request(client)</span><br><span class=\"line\">            task = asyncio.create_task(req)</span><br><span class=\"line\">            task_list.append(task)</span><br><span class=\"line\">        <span class=\"keyword\">await</span> asyncio.gather(*task_list)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#开始</span></span><br><span class=\"line\">    start = time.time()</span><br><span class=\"line\">    asyncio.run(main())</span><br><span class=\"line\">    <span class=\"comment\"># 结束</span></span><br><span class=\"line\">    end = time.time()</span><br><span class=\"line\">    print(<span class=\"string\">f'异步：发送1000次请求，耗时：<span class=\"subst\">&#123;end - start&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">异步：发送1000次请求，耗时：3.903275728225708</span><br></pre></td></tr></table></figure>\n\n<p>将httpx用于请求端，同步与异步请求差距非常明显。</p>\n<p>以上的例子已经放到 learning-API-test github项目</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>*　这里只是拿 flask 非异步框架做为接口服务端进行对比，如果如果将接口服务同样换作前面介绍的 snaic 异步框架，上面的两组测试对比并不明显（snaic的异步接口服务处理同步请求更快），在安装 snaic的时候会发现，他同样也集成了 httpx 库。</p>\n<p>*　为什么要学习异步，因为我们公司有很多接口是异步调用的，所以，我想真正搞懂这个概念，就这么简单！保持在工作中对技术的好奇心。</p>\n<ul>\n<li>异步与多线程的区别？这是我在学习 异步时候的一个疑问，我找到了一个比较形象的例子。</li>\n</ul>\n<blockquote>\n<p>以火车站购票场景为例：一个火车站为一个进程，一个窗口和售票员的组合为一个线程：</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>多线程：火车站开了N个窗口售票员，我们去买票，会有工作人员（CPU）指定我们去某个窗口买票，你被安排到某个窗口后，告诉售票员你的请求（咨询或买票），售票员执行操作，如果这个过程中发送的阻塞，也是窗口售票员的阻塞（比如查票的过程），但是因为你开了很多个窗口，其他买票的人可以被安排去另外的空闲窗口，如果所有窗口都满了，工作人员就不会给你安排了，直到有空的窗口出来；</li>\n<li>多进程（并行）：建多个火车站售票，火车站与火车站间互不影响，看买票的自己想去哪里（这里不讨论负载均衡）；</li>\n<li>异步：火车站只有一个窗口售票员，但是窗口前有一个登记台（事件循环），你把你想买的票告诉给登记台，并留下你的手机（回调函数），然后你就可以走了，由于登记台只是登记了你的请求，并没有做任何其他操作，所以这个耗时基本忽略不计的。之后售票员处理完了上一个任务了，就会自己去登记台取剩下的未完成的任务，直到取到你的任务，操作完后，有票没票都会通过手机通知你，如果有票还会往你的手机发车票的二维码；</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>谈到http接口调用，Requests大家并不陌生，例如，robotframework-requests、HttpRunner等HTTP接口测试库/框架都是基于它开发。这里将介绍另一款http接口测试框架:httpx。","more":"</p>\n<p>它的API和Requests高度一致。</p>\n<p>github: <a href=\"https://github.com/encode/httpx\" target=\"_blank\" rel=\"noopener\">https://github.com/encode/httpx</a></p>\n<p>安装：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> pip install httpx</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"httpx-简单使用\"><a href=\"#httpx-简单使用\" class=\"headerlink\" title=\"httpx 简单使用\"></a>httpx 简单使用</h2><p>当然，它是不支持python2.x的。</p>\n<ul>\n<li>简单的get调用</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> httpx</span><br><span class=\"line\"></span><br><span class=\"line\">r = httpx.get(<span class=\"string\">\"http://httpbin.org/get\"</span>)</span><br><span class=\"line\">print(r.status_code)</span><br><span class=\"line\">print(r.json())</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span></span><br><span class=\"line\">&#123;'args': &#123;&#125;, 'headers': &#123;'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': 'python-httpx/0.12.1', 'X-Amzn-Trace-Id': 'Root=1-5ea5b58c-e446c44392ea090809e8a4bc'&#125;, 'origin': '113.97.33.224', 'url': 'http://httpbin.org/get'&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>带参数的post调用</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> httpx</span><br><span class=\"line\"></span><br><span class=\"line\">payload = &#123;<span class=\"string\">'key1'</span>: <span class=\"string\">'value1'</span>, <span class=\"string\">'key2'</span>: <span class=\"string\">'value2'</span>&#125;</span><br><span class=\"line\">r = httpx.post(<span class=\"string\">\"http://httpbin.org/post\"</span>, data=payload)</span><br><span class=\"line\">print(r.json())</span><br></pre></td></tr></table></figure>\n\n<p>执行结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;'args': &#123;&#125;, 'data': '', 'files': &#123;&#125;, 'form': &#123;'key1': 'value1', 'key2': 'value2'&#125;, 'headers': &#123;'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Content-Length': '23', 'Content-Type': 'application/x-www-form-urlencoded', 'Host': 'httpbin.org', 'User-Agent': 'python-httpx/0.12.1', 'X-Amzn-Trace-Id': 'Root=1-5ea5b61d-1871d10e80b8324e48ea475e'&#125;, 'json': None, 'origin': '113.97.33.224', 'url': 'http://httpbin.org/post'&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你会发现这几乎和requests一模一样，只不过把requests 换成了httpx。</p>\n<h2 id=\"httpx-异步调用\"><a href=\"#httpx-异步调用\" class=\"headerlink\" title=\"httpx 异步调用\"></a>httpx 异步调用</h2><p>接下来认识httpx的异步调用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> httpx</span><br><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> httpx.AsyncClient() <span class=\"keyword\">as</span> client:</span><br><span class=\"line\">        resp = <span class=\"keyword\">await</span> client.get(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br><span class=\"line\">        result = resp.json()</span><br><span class=\"line\">        print(result)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">asyncio.run(main())</span><br></pre></td></tr></table></figure>\n\n<p>这里用到了async 、await， asyncio等，等参考我关于python异步I/O的基础介绍：<a href=\"https://www.cnblogs.com/fnng/p/12757395.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/fnng/p/12757395.html</a></p>\n<h2 id=\"异步的调用的优势\"><a href=\"#异步的调用的优势\" class=\"headerlink\" title=\"异步的调用的优势\"></a>异步的调用的优势</h2><p>我们发现，采用异步会让接口的调用更加复杂，那为什么还要使用异步呢？当你要调用1000次接口时，那么异步调用可以让你的调用更快。接下来我们通过简单让例子进行对比。</p>\n<p>以我flask开发的简单接口为例子：</p>\n<p><a href=\"https://github.com/defnngj/learning-API-test\" target=\"_blank\" rel=\"noopener\">https://github.com/defnngj/learning-API-test</a></p>\n<blockquote>\n<p>为了测试的更加准确性，我将flask服务部署在了另一台电脑，测试机与被测服务分离。</p>\n</blockquote>\n<ul>\n<li>httpx 同步调用</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 同步调用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> httpx</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_request</span><span class=\"params\">(client)</span>:</span></span><br><span class=\"line\">    resp = client.get(<span class=\"string\">'http://192.168.0.7:5000'</span>)</span><br><span class=\"line\">    result = resp.json()</span><br><span class=\"line\">    <span class=\"comment\"># print(result)</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> result[<span class=\"string\">\"code\"</span>] == <span class=\"number\">10200</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    session = httpx.Client()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 1000 次调用</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">1000</span>):</span><br><span class=\"line\">        make_request(session)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 开始</span></span><br><span class=\"line\">    start = time.time()</span><br><span class=\"line\">    main()</span><br><span class=\"line\">    <span class=\"comment\"># 结束</span></span><br><span class=\"line\">    end = time.time()</span><br><span class=\"line\">    print(<span class=\"string\">f'同步：发送1000次请求，耗时：<span class=\"subst\">&#123;end - start&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">同步：发送1000次请求，耗时：52.948561906814575</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>httpx 异步调用</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 异步调用</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> httpx</span><br><span class=\"line\"><span class=\"keyword\">import</span> asyncio</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">request</span><span class=\"params\">(client)</span>:</span></span><br><span class=\"line\">    resp = <span class=\"keyword\">await</span> client.get(<span class=\"string\">'http://192.168.0.7:5000'</span>)</span><br><span class=\"line\">    result = resp.json()</span><br><span class=\"line\">    <span class=\"comment\"># print(result)</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> result[<span class=\"string\">\"code\"</span>] == <span class=\"number\">10200</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"keyword\">with</span> httpx.AsyncClient() <span class=\"keyword\">as</span> client:</span><br><span class=\"line\">        <span class=\"comment\"># # 开始</span></span><br><span class=\"line\">        <span class=\"comment\"># start = time.time()</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 1000 次调用</span></span><br><span class=\"line\">        task_list = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">1000</span>):</span><br><span class=\"line\">            req = request(client)</span><br><span class=\"line\">            task = asyncio.create_task(req)</span><br><span class=\"line\">            task_list.append(task)</span><br><span class=\"line\">        <span class=\"keyword\">await</span> asyncio.gather(*task_list)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#开始</span></span><br><span class=\"line\">    start = time.time()</span><br><span class=\"line\">    asyncio.run(main())</span><br><span class=\"line\">    <span class=\"comment\"># 结束</span></span><br><span class=\"line\">    end = time.time()</span><br><span class=\"line\">    print(<span class=\"string\">f'异步：发送1000次请求，耗时：<span class=\"subst\">&#123;end - start&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>结果:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">异步：发送1000次请求，耗时：3.903275728225708</span><br></pre></td></tr></table></figure>\n\n<p>将httpx用于请求端，同步与异步请求差距非常明显。</p>\n<p>以上的例子已经放到 learning-API-test github项目</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>*　这里只是拿 flask 非异步框架做为接口服务端进行对比，如果如果将接口服务同样换作前面介绍的 snaic 异步框架，上面的两组测试对比并不明显（snaic的异步接口服务处理同步请求更快），在安装 snaic的时候会发现，他同样也集成了 httpx 库。</p>\n<p>*　为什么要学习异步，因为我们公司有很多接口是异步调用的，所以，我想真正搞懂这个概念，就这么简单！保持在工作中对技术的好奇心。</p>\n<ul>\n<li>异步与多线程的区别？这是我在学习 异步时候的一个疑问，我找到了一个比较形象的例子。</li>\n</ul>\n<blockquote>\n<p>以火车站购票场景为例：一个火车站为一个进程，一个窗口和售票员的组合为一个线程：</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>多线程：火车站开了N个窗口售票员，我们去买票，会有工作人员（CPU）指定我们去某个窗口买票，你被安排到某个窗口后，告诉售票员你的请求（咨询或买票），售票员执行操作，如果这个过程中发送的阻塞，也是窗口售票员的阻塞（比如查票的过程），但是因为你开了很多个窗口，其他买票的人可以被安排去另外的空闲窗口，如果所有窗口都满了，工作人员就不会给你安排了，直到有空的窗口出来；</li>\n<li>多进程（并行）：建多个火车站售票，火车站与火车站间互不影响，看买票的自己想去哪里（这里不讨论负载均衡）；</li>\n<li>异步：火车站只有一个窗口售票员，但是窗口前有一个登记台（事件循环），你把你想买的票告诉给登记台，并留下你的手机（回调函数），然后你就可以走了，由于登记台只是登记了你的请求，并没有做任何其他操作，所以这个耗时基本忽略不计的。之后售票员处理完了上一个任务了，就会自己去登记台取剩下的未完成的任务，直到取到你的任务，操作完后，有票没票都会通过手机通知你，如果有票还会往你的手机发车票的二维码；</li>\n</ul>\n</blockquote>"},{"title":"ADB常用命令及其用法大全","abbrlink":"3447541d","date":"2021-11-28T14:33:53.000Z","_content":"## ADB常用命令及其用法大全\n#### 前言：\n> 本文主要记述ADB的常用命令，关于ADB用法大全，可参考文末链接\n\n#### ADB简介：\n\nADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。安卓调试桥 (Android Debug Bridge, adb)，是一种可以用来操作手机设备或模拟器的命令行工具。它存在于 sdk/platform-tools 目录下。虽然现在 Android Studio 已经将大部分 ADB 命令以图形化的形式实现了，但是了解一下还是有必要的。\n注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。\n\n#### 查看当前连接设备：\n> 查看当前连接设备：\n>\n> > adb devices\n\n> 查看当前设备的详细信息\n>\n> > adb devices -l\n\n> 如果发现多个设备：\n>\n> > adb -s 设备号 其他指令\n\n#### adb进程启动和终止\n> 启动服务进程\n>\n> > adb start-server\n\n> 杀死后台服务进程\n>\n> > adb kill-server\n\n#### 查看当前运行的Activity:\n> windows环境下:\n>\n> > adb shell dumpsys activity | findstr \"mFocusedActivity\"\n\n> Linux、Mac环境下：\n>\n> > adb shell dumpsys activity | grep \"mFocusedActivity\"\n\n#### 查看日志：\n>> adb logcat\n\n> 将adb日志保存到文件\n>\n> > adb logcat > 本地文件名\n\n#### 安装apk文件：\n>> adb install xxx.apk\n\n> 此安装方式，如果已经存在，无法安装；推荐使用覆盖安装：\n>\n> > adb install -r xxx.apk\n\n> 比分直接RUN出来的包是test-onlu的无法安装，推荐使用**-t**\n>\n> > adb install -r -t xxx.apk\n\n#### 卸载App:\n> adb uninstall com.zhy.app\n\n> 如果想要保留数据，则：\n>\n> > adb uninstall -k com.zhy.app\n\n#### 传递文件：\n> 往手机SDCard传递文件：\n>\n> > adb push 文件名 手机端SDCard路径\n\n> 例如：\n>\n> > adb push 帅照.jpg /sdcard/\n\n> 从手机端下载文件：\n>\n> > adb pull /sdcard/xxx.txt\n\n> 查看手机端安装的所有app包名:\n>\n> > adb shell pm list packages\n\n#### 启动Activity:\n> adb shell am start 包名/完整Activity路径\n\n> 例如：\n>\n> > adb shell am start com.zhy.aaa/com.zhy.aaa.MainActivity\n\n> 如果需要携带参数(携带一个Intent,Key 为name):\nadb shell am start com.zhy.aaa/com.zhy.aaa.MainActivity -e name zhy\n\n> 启动一个隐式的Intent:\n>\n> > adb shell am start -a \"android.intent.action,VIEW\" -d \"https://www.google.com\"\n\n#### 发送广播：\n> adb shell am broadcast -a \"broadcastactionfilter\"\n\n> 如果需要携带参数（携带一个Intent,key为name）:\n>\n> > adb shell am broadcast -a \"broadcastactionfilter\" -e name zhy\n\n#### 启动服务：\n> adb shell am startservice \"com.zhy.aaa/com.zhy.aaa.MyService\"\n\n#### 屏幕截图：\n> 可以使用screencap命令来进行手机屏幕截图，例如：\n>\n> > adb shell screencap /sdcard/screen.png\n\n#### 录制视频：\n> 可以使用screenrecord[options] filename命令来录制屏幕视频;\n> 例如：\n>\n> > adb shell screenrecord /sdcard/demo.mp4\n\n#### 远程连接adb\n> 通过 IP 地址连接设备。\n>\n> > adb connect [device-ip-address]\n\n> 断开无线连接\n>\n> > adb disconnect [device-ip-address]\n\n\n\n#### 速查 | ADB 用法大全|官方文档：\n> http://www.wanandroid.com/blog/show/2310","source":"_posts/2021.11/常用ADB命令及其用法大全.md","raw":"---\ntitle: ADB常用命令及其用法大全\ntags:\n  - 博客\nabbrlink: 3447541d\ndate: 2021-11-28 22:33:53\n---\n## ADB常用命令及其用法大全\n#### 前言：\n> 本文主要记述ADB的常用命令，关于ADB用法大全，可参考文末链接\n\n#### ADB简介：\n\nADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。安卓调试桥 (Android Debug Bridge, adb)，是一种可以用来操作手机设备或模拟器的命令行工具。它存在于 sdk/platform-tools 目录下。虽然现在 Android Studio 已经将大部分 ADB 命令以图形化的形式实现了，但是了解一下还是有必要的。\n注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。\n\n#### 查看当前连接设备：\n> 查看当前连接设备：\n>\n> > adb devices\n\n> 查看当前设备的详细信息\n>\n> > adb devices -l\n\n> 如果发现多个设备：\n>\n> > adb -s 设备号 其他指令\n\n#### adb进程启动和终止\n> 启动服务进程\n>\n> > adb start-server\n\n> 杀死后台服务进程\n>\n> > adb kill-server\n\n#### 查看当前运行的Activity:\n> windows环境下:\n>\n> > adb shell dumpsys activity | findstr \"mFocusedActivity\"\n\n> Linux、Mac环境下：\n>\n> > adb shell dumpsys activity | grep \"mFocusedActivity\"\n\n#### 查看日志：\n>> adb logcat\n\n> 将adb日志保存到文件\n>\n> > adb logcat > 本地文件名\n\n#### 安装apk文件：\n>> adb install xxx.apk\n\n> 此安装方式，如果已经存在，无法安装；推荐使用覆盖安装：\n>\n> > adb install -r xxx.apk\n\n> 比分直接RUN出来的包是test-onlu的无法安装，推荐使用**-t**\n>\n> > adb install -r -t xxx.apk\n\n#### 卸载App:\n> adb uninstall com.zhy.app\n\n> 如果想要保留数据，则：\n>\n> > adb uninstall -k com.zhy.app\n\n#### 传递文件：\n> 往手机SDCard传递文件：\n>\n> > adb push 文件名 手机端SDCard路径\n\n> 例如：\n>\n> > adb push 帅照.jpg /sdcard/\n\n> 从手机端下载文件：\n>\n> > adb pull /sdcard/xxx.txt\n\n> 查看手机端安装的所有app包名:\n>\n> > adb shell pm list packages\n\n#### 启动Activity:\n> adb shell am start 包名/完整Activity路径\n\n> 例如：\n>\n> > adb shell am start com.zhy.aaa/com.zhy.aaa.MainActivity\n\n> 如果需要携带参数(携带一个Intent,Key 为name):\nadb shell am start com.zhy.aaa/com.zhy.aaa.MainActivity -e name zhy\n\n> 启动一个隐式的Intent:\n>\n> > adb shell am start -a \"android.intent.action,VIEW\" -d \"https://www.google.com\"\n\n#### 发送广播：\n> adb shell am broadcast -a \"broadcastactionfilter\"\n\n> 如果需要携带参数（携带一个Intent,key为name）:\n>\n> > adb shell am broadcast -a \"broadcastactionfilter\" -e name zhy\n\n#### 启动服务：\n> adb shell am startservice \"com.zhy.aaa/com.zhy.aaa.MyService\"\n\n#### 屏幕截图：\n> 可以使用screencap命令来进行手机屏幕截图，例如：\n>\n> > adb shell screencap /sdcard/screen.png\n\n#### 录制视频：\n> 可以使用screenrecord[options] filename命令来录制屏幕视频;\n> 例如：\n>\n> > adb shell screenrecord /sdcard/demo.mp4\n\n#### 远程连接adb\n> 通过 IP 地址连接设备。\n>\n> > adb connect [device-ip-address]\n\n> 断开无线连接\n>\n> > adb disconnect [device-ip-address]\n\n\n\n#### 速查 | ADB 用法大全|官方文档：\n> http://www.wanandroid.com/blog/show/2310","slug":"2021.11/常用ADB命令及其用法大全","published":1,"updated":"2021-11-28T14:33:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wr000zn4epa8i9dgms","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"ADB常用命令及其用法大全\"><a href=\"#ADB常用命令及其用法大全\" class=\"headerlink\" title=\"ADB常用命令及其用法大全\"></a>ADB常用命令及其用法大全</h2><h4 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h4><blockquote>\n<p>本文主要记述ADB的常用命令，关于ADB用法大全，可参考文末链接</p>\n</blockquote>\n<h4 id=\"ADB简介：\"><a href=\"#ADB简介：\" class=\"headerlink\" title=\"ADB简介：\"></a>ADB简介：</h4><p>ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。安卓调试桥 (Android Debug Bridge, adb)，是一种可以用来操作手机设备或模拟器的命令行工具。它存在于 sdk/platform-tools 目录下。虽然现在 Android Studio 已经将大部分 ADB 命令以图形化的形式实现了，但是了解一下还是有必要的。<br>注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。</p>\n<h4 id=\"查看当前连接设备：\"><a href=\"#查看当前连接设备：\" class=\"headerlink\" title=\"查看当前连接设备：\"></a>查看当前连接设备：</h4><blockquote>\n<p>查看当前连接设备：</p>\n<blockquote>\n<p>adb devices</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>查看当前设备的详细信息</p>\n<blockquote>\n<p>adb devices -l</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>如果发现多个设备：</p>\n<blockquote>\n<p>adb -s 设备号 其他指令</p>\n</blockquote>\n</blockquote>\n<h4 id=\"adb进程启动和终止\"><a href=\"#adb进程启动和终止\" class=\"headerlink\" title=\"adb进程启动和终止\"></a>adb进程启动和终止</h4><blockquote>\n<p>启动服务进程</p>\n<blockquote>\n<p>adb start-server</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>杀死后台服务进程</p>\n<blockquote>\n<p>adb kill-server</p>\n</blockquote>\n</blockquote>\n<h4 id=\"查看当前运行的Activity\"><a href=\"#查看当前运行的Activity\" class=\"headerlink\" title=\"查看当前运行的Activity:\"></a>查看当前运行的Activity:</h4><blockquote>\n<p>windows环境下:</p>\n<blockquote>\n<p>adb shell dumpsys activity | findstr “mFocusedActivity”</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>Linux、Mac环境下：</p>\n<blockquote>\n<p>adb shell dumpsys activity | grep “mFocusedActivity”</p>\n</blockquote>\n</blockquote>\n<h4 id=\"查看日志：\"><a href=\"#查看日志：\" class=\"headerlink\" title=\"查看日志：\"></a>查看日志：</h4><blockquote>\n<blockquote>\n<p>adb logcat</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>将adb日志保存到文件</p>\n<blockquote>\n<p>adb logcat &gt; 本地文件名</p>\n</blockquote>\n</blockquote>\n<h4 id=\"安装apk文件：\"><a href=\"#安装apk文件：\" class=\"headerlink\" title=\"安装apk文件：\"></a>安装apk文件：</h4><blockquote>\n<blockquote>\n<p>adb install xxx.apk</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>此安装方式，如果已经存在，无法安装；推荐使用覆盖安装：</p>\n<blockquote>\n<p>adb install -r xxx.apk</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>比分直接RUN出来的包是test-onlu的无法安装，推荐使用<strong>-t</strong></p>\n<blockquote>\n<p>adb install -r -t xxx.apk</p>\n</blockquote>\n</blockquote>\n<h4 id=\"卸载App\"><a href=\"#卸载App\" class=\"headerlink\" title=\"卸载App:\"></a>卸载App:</h4><blockquote>\n<p>adb uninstall com.zhy.app</p>\n</blockquote>\n<blockquote>\n<p>如果想要保留数据，则：</p>\n<blockquote>\n<p>adb uninstall -k com.zhy.app</p>\n</blockquote>\n</blockquote>\n<h4 id=\"传递文件：\"><a href=\"#传递文件：\" class=\"headerlink\" title=\"传递文件：\"></a>传递文件：</h4><blockquote>\n<p>往手机SDCard传递文件：</p>\n<blockquote>\n<p>adb push 文件名 手机端SDCard路径</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>例如：</p>\n<blockquote>\n<p>adb push 帅照.jpg /sdcard/</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>从手机端下载文件：</p>\n<blockquote>\n<p>adb pull /sdcard/xxx.txt</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>查看手机端安装的所有app包名:</p>\n<blockquote>\n<p>adb shell pm list packages</p>\n</blockquote>\n</blockquote>\n<h4 id=\"启动Activity\"><a href=\"#启动Activity\" class=\"headerlink\" title=\"启动Activity:\"></a>启动Activity:</h4><blockquote>\n<p>adb shell am start 包名/完整Activity路径</p>\n</blockquote>\n<blockquote>\n<p>例如：</p>\n<blockquote>\n<p>adb shell am start com.zhy.aaa/com.zhy.aaa.MainActivity</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>如果需要携带参数(携带一个Intent,Key 为name):<br>adb shell am start com.zhy.aaa/com.zhy.aaa.MainActivity -e name zhy</p>\n</blockquote>\n<blockquote>\n<p>启动一个隐式的Intent:</p>\n<blockquote>\n<p>adb shell am start -a “android.intent.action,VIEW” -d “<a href=\"https://www.google.com&quot;\" target=\"_blank\" rel=\"noopener\">https://www.google.com&quot;</a></p>\n</blockquote>\n</blockquote>\n<h4 id=\"发送广播：\"><a href=\"#发送广播：\" class=\"headerlink\" title=\"发送广播：\"></a>发送广播：</h4><blockquote>\n<p>adb shell am broadcast -a “broadcastactionfilter”</p>\n</blockquote>\n<blockquote>\n<p>如果需要携带参数（携带一个Intent,key为name）:</p>\n<blockquote>\n<p>adb shell am broadcast -a “broadcastactionfilter” -e name zhy</p>\n</blockquote>\n</blockquote>\n<h4 id=\"启动服务：\"><a href=\"#启动服务：\" class=\"headerlink\" title=\"启动服务：\"></a>启动服务：</h4><blockquote>\n<p>adb shell am startservice “com.zhy.aaa/com.zhy.aaa.MyService”</p>\n</blockquote>\n<h4 id=\"屏幕截图：\"><a href=\"#屏幕截图：\" class=\"headerlink\" title=\"屏幕截图：\"></a>屏幕截图：</h4><blockquote>\n<p>可以使用screencap命令来进行手机屏幕截图，例如：</p>\n<blockquote>\n<p>adb shell screencap /sdcard/screen.png</p>\n</blockquote>\n</blockquote>\n<h4 id=\"录制视频：\"><a href=\"#录制视频：\" class=\"headerlink\" title=\"录制视频：\"></a>录制视频：</h4><blockquote>\n<p>可以使用screenrecord[options] filename命令来录制屏幕视频;<br>例如：</p>\n<blockquote>\n<p>adb shell screenrecord /sdcard/demo.mp4</p>\n</blockquote>\n</blockquote>\n<h4 id=\"远程连接adb\"><a href=\"#远程连接adb\" class=\"headerlink\" title=\"远程连接adb\"></a>远程连接adb</h4><blockquote>\n<p>通过 IP 地址连接设备。</p>\n<blockquote>\n<p>adb connect [device-ip-address]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>断开无线连接</p>\n<blockquote>\n<p>adb disconnect [device-ip-address]</p>\n</blockquote>\n</blockquote>\n<h4 id=\"速查-ADB-用法大全-官方文档：\"><a href=\"#速查-ADB-用法大全-官方文档：\" class=\"headerlink\" title=\"速查 | ADB 用法大全|官方文档：\"></a>速查 | ADB 用法大全|官方文档：</h4><blockquote>\n<p><a href=\"http://www.wanandroid.com/blog/show/2310\" target=\"_blank\" rel=\"noopener\">http://www.wanandroid.com/blog/show/2310</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ADB常用命令及其用法大全\"><a href=\"#ADB常用命令及其用法大全\" class=\"headerlink\" title=\"ADB常用命令及其用法大全\"></a>ADB常用命令及其用法大全</h2><h4 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h4><blockquote>\n<p>本文主要记述ADB的常用命令，关于ADB用法大全，可参考文末链接</p>\n</blockquote>\n<h4 id=\"ADB简介：\"><a href=\"#ADB简介：\" class=\"headerlink\" title=\"ADB简介：\"></a>ADB简介：</h4><p>ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。安卓调试桥 (Android Debug Bridge, adb)，是一种可以用来操作手机设备或模拟器的命令行工具。它存在于 sdk/platform-tools 目录下。虽然现在 Android Studio 已经将大部分 ADB 命令以图形化的形式实现了，但是了解一下还是有必要的。<br>注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。</p>\n<h4 id=\"查看当前连接设备：\"><a href=\"#查看当前连接设备：\" class=\"headerlink\" title=\"查看当前连接设备：\"></a>查看当前连接设备：</h4><blockquote>\n<p>查看当前连接设备：</p>\n<blockquote>\n<p>adb devices</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>查看当前设备的详细信息</p>\n<blockquote>\n<p>adb devices -l</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>如果发现多个设备：</p>\n<blockquote>\n<p>adb -s 设备号 其他指令</p>\n</blockquote>\n</blockquote>\n<h4 id=\"adb进程启动和终止\"><a href=\"#adb进程启动和终止\" class=\"headerlink\" title=\"adb进程启动和终止\"></a>adb进程启动和终止</h4><blockquote>\n<p>启动服务进程</p>\n<blockquote>\n<p>adb start-server</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>杀死后台服务进程</p>\n<blockquote>\n<p>adb kill-server</p>\n</blockquote>\n</blockquote>\n<h4 id=\"查看当前运行的Activity\"><a href=\"#查看当前运行的Activity\" class=\"headerlink\" title=\"查看当前运行的Activity:\"></a>查看当前运行的Activity:</h4><blockquote>\n<p>windows环境下:</p>\n<blockquote>\n<p>adb shell dumpsys activity | findstr “mFocusedActivity”</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>Linux、Mac环境下：</p>\n<blockquote>\n<p>adb shell dumpsys activity | grep “mFocusedActivity”</p>\n</blockquote>\n</blockquote>\n<h4 id=\"查看日志：\"><a href=\"#查看日志：\" class=\"headerlink\" title=\"查看日志：\"></a>查看日志：</h4><blockquote>\n<blockquote>\n<p>adb logcat</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>将adb日志保存到文件</p>\n<blockquote>\n<p>adb logcat &gt; 本地文件名</p>\n</blockquote>\n</blockquote>\n<h4 id=\"安装apk文件：\"><a href=\"#安装apk文件：\" class=\"headerlink\" title=\"安装apk文件：\"></a>安装apk文件：</h4><blockquote>\n<blockquote>\n<p>adb install xxx.apk</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>此安装方式，如果已经存在，无法安装；推荐使用覆盖安装：</p>\n<blockquote>\n<p>adb install -r xxx.apk</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>比分直接RUN出来的包是test-onlu的无法安装，推荐使用<strong>-t</strong></p>\n<blockquote>\n<p>adb install -r -t xxx.apk</p>\n</blockquote>\n</blockquote>\n<h4 id=\"卸载App\"><a href=\"#卸载App\" class=\"headerlink\" title=\"卸载App:\"></a>卸载App:</h4><blockquote>\n<p>adb uninstall com.zhy.app</p>\n</blockquote>\n<blockquote>\n<p>如果想要保留数据，则：</p>\n<blockquote>\n<p>adb uninstall -k com.zhy.app</p>\n</blockquote>\n</blockquote>\n<h4 id=\"传递文件：\"><a href=\"#传递文件：\" class=\"headerlink\" title=\"传递文件：\"></a>传递文件：</h4><blockquote>\n<p>往手机SDCard传递文件：</p>\n<blockquote>\n<p>adb push 文件名 手机端SDCard路径</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>例如：</p>\n<blockquote>\n<p>adb push 帅照.jpg /sdcard/</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>从手机端下载文件：</p>\n<blockquote>\n<p>adb pull /sdcard/xxx.txt</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>查看手机端安装的所有app包名:</p>\n<blockquote>\n<p>adb shell pm list packages</p>\n</blockquote>\n</blockquote>\n<h4 id=\"启动Activity\"><a href=\"#启动Activity\" class=\"headerlink\" title=\"启动Activity:\"></a>启动Activity:</h4><blockquote>\n<p>adb shell am start 包名/完整Activity路径</p>\n</blockquote>\n<blockquote>\n<p>例如：</p>\n<blockquote>\n<p>adb shell am start com.zhy.aaa/com.zhy.aaa.MainActivity</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>如果需要携带参数(携带一个Intent,Key 为name):<br>adb shell am start com.zhy.aaa/com.zhy.aaa.MainActivity -e name zhy</p>\n</blockquote>\n<blockquote>\n<p>启动一个隐式的Intent:</p>\n<blockquote>\n<p>adb shell am start -a “android.intent.action,VIEW” -d “<a href=\"https://www.google.com&quot;\" target=\"_blank\" rel=\"noopener\">https://www.google.com&quot;</a></p>\n</blockquote>\n</blockquote>\n<h4 id=\"发送广播：\"><a href=\"#发送广播：\" class=\"headerlink\" title=\"发送广播：\"></a>发送广播：</h4><blockquote>\n<p>adb shell am broadcast -a “broadcastactionfilter”</p>\n</blockquote>\n<blockquote>\n<p>如果需要携带参数（携带一个Intent,key为name）:</p>\n<blockquote>\n<p>adb shell am broadcast -a “broadcastactionfilter” -e name zhy</p>\n</blockquote>\n</blockquote>\n<h4 id=\"启动服务：\"><a href=\"#启动服务：\" class=\"headerlink\" title=\"启动服务：\"></a>启动服务：</h4><blockquote>\n<p>adb shell am startservice “com.zhy.aaa/com.zhy.aaa.MyService”</p>\n</blockquote>\n<h4 id=\"屏幕截图：\"><a href=\"#屏幕截图：\" class=\"headerlink\" title=\"屏幕截图：\"></a>屏幕截图：</h4><blockquote>\n<p>可以使用screencap命令来进行手机屏幕截图，例如：</p>\n<blockquote>\n<p>adb shell screencap /sdcard/screen.png</p>\n</blockquote>\n</blockquote>\n<h4 id=\"录制视频：\"><a href=\"#录制视频：\" class=\"headerlink\" title=\"录制视频：\"></a>录制视频：</h4><blockquote>\n<p>可以使用screenrecord[options] filename命令来录制屏幕视频;<br>例如：</p>\n<blockquote>\n<p>adb shell screenrecord /sdcard/demo.mp4</p>\n</blockquote>\n</blockquote>\n<h4 id=\"远程连接adb\"><a href=\"#远程连接adb\" class=\"headerlink\" title=\"远程连接adb\"></a>远程连接adb</h4><blockquote>\n<p>通过 IP 地址连接设备。</p>\n<blockquote>\n<p>adb connect [device-ip-address]</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>断开无线连接</p>\n<blockquote>\n<p>adb disconnect [device-ip-address]</p>\n</blockquote>\n</blockquote>\n<h4 id=\"速查-ADB-用法大全-官方文档：\"><a href=\"#速查-ADB-用法大全-官方文档：\" class=\"headerlink\" title=\"速查 | ADB 用法大全|官方文档：\"></a>速查 | ADB 用法大全|官方文档：</h4><blockquote>\n<p><a href=\"http://www.wanandroid.com/blog/show/2310\" target=\"_blank\" rel=\"noopener\">http://www.wanandroid.com/blog/show/2310</a></p>\n</blockquote>\n"},{"title":"【自动化测试】WEB自动化测试环境搭建","abbrlink":"a42e3f6d","date":"2021-12-08T15:54:16.000Z","_content":"\n一、selenium安装\n\nPython3.x安装后就默认就会有pip（pip.exe默认在python的Scripts路径下），使用pip安装selenium：\n\n在CMD命令行输入：pip install selenium \n\n二、Webdriver、geckodriver下载配置：\n\nWebdriver下载路径：http://chromedriver.storage.googleapis.com/index.html，用于驱动打开Chrome；\n\ngeckodriver下载路径：https://github.com/mozilla/geckodriver/releases，用于驱动打开Firefox；\n\n下载后放在python.exe相同目录下:\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-b0594b2a52a4034b.png?imageMogr2/auto-orient/strip|imageView2/2/w/755/format/webp)\n\n测试下：打开python自带编辑器IDLE\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-d4dc876f1a52d488.png?imageMogr2/auto-orient/strip|imageView2/2/w/472/format/webp)\n\n如果能正常运行就证明驱动安装成功\n\n三、pyCharm设置\n\n打开pyCharm,点开File-Settings加入selenium，如下图，点+搜索selenium，点Install Package\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-e1a2c5f78a16bf5c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1194/format/webp)\n\n二、mac环境搭建\n\n1.前提\n\n(1)mac系统自带python2.7，如果你要的是python3版本，需要自己下载安装。\n\n(2)安装好IDE:pycharm\n\n(3)安装好chrome浏览器\n\n(4)下载chromedriver : http://npm.taobao.org/mirrors/chromedriver/2.36/（放到user/local/bin，打开访达-前往-前往文件夹：输入/usr/local/bin）\n\n————————————————\n\n2.安装selenium操作：\n\n打开终端，输入：sudo pip3 install selenium（python2版本输入sudo pip install selenium） \n\n打开“终端”方法：\n\n在 Mac 上，请执行以下一项操作：\n\n点按程序坞中的“启动台”图标 ，在搜索栏中键入“终端”，然后点按“终端”。\n\n在“访达”中，打开“/应用程序/实用工具”文件夹，然后连按“终端”，打开。\n\n导入第三方的包，别人都有file→setting，我这怎么就是没有。也是心累。\n\n在这里记录一下，免得跟多人入坑\n\n1、PyCharm→Preferences→Project：项目名→Project Interpreter\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-ea23f8ce76a0c6fc?imageMogr2/auto-orient/strip|imageView2/2/w/1003/format/webp)\n\n2、点击这个加号可以导入新的库,点击install，这里以requests库为例\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-2407675f4ef9d068?imageMogr2/auto-orient/strip|imageView2/2/w/924/format/webp)\n\n3、查看是否已经存在\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-58d95cbcea9a5638?imageMogr2/auto-orient/strip|imageView2/2/w/1003/format/webp)\n\n库已经导入了。","source":"_posts/2021.12/【自动化测试】WEB自动化测试环境搭建.md","raw":"---\ntitle: 【自动化测试】WEB自动化测试环境搭建\nabbrlink: a42e3f6d\ndate: 2021-12-08 23:54:16\ntags:\n---\n\n一、selenium安装\n\nPython3.x安装后就默认就会有pip（pip.exe默认在python的Scripts路径下），使用pip安装selenium：\n\n在CMD命令行输入：pip install selenium \n\n二、Webdriver、geckodriver下载配置：\n\nWebdriver下载路径：http://chromedriver.storage.googleapis.com/index.html，用于驱动打开Chrome；\n\ngeckodriver下载路径：https://github.com/mozilla/geckodriver/releases，用于驱动打开Firefox；\n\n下载后放在python.exe相同目录下:\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-b0594b2a52a4034b.png?imageMogr2/auto-orient/strip|imageView2/2/w/755/format/webp)\n\n测试下：打开python自带编辑器IDLE\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-d4dc876f1a52d488.png?imageMogr2/auto-orient/strip|imageView2/2/w/472/format/webp)\n\n如果能正常运行就证明驱动安装成功\n\n三、pyCharm设置\n\n打开pyCharm,点开File-Settings加入selenium，如下图，点+搜索selenium，点Install Package\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-e1a2c5f78a16bf5c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1194/format/webp)\n\n二、mac环境搭建\n\n1.前提\n\n(1)mac系统自带python2.7，如果你要的是python3版本，需要自己下载安装。\n\n(2)安装好IDE:pycharm\n\n(3)安装好chrome浏览器\n\n(4)下载chromedriver : http://npm.taobao.org/mirrors/chromedriver/2.36/（放到user/local/bin，打开访达-前往-前往文件夹：输入/usr/local/bin）\n\n————————————————\n\n2.安装selenium操作：\n\n打开终端，输入：sudo pip3 install selenium（python2版本输入sudo pip install selenium） \n\n打开“终端”方法：\n\n在 Mac 上，请执行以下一项操作：\n\n点按程序坞中的“启动台”图标 ，在搜索栏中键入“终端”，然后点按“终端”。\n\n在“访达”中，打开“/应用程序/实用工具”文件夹，然后连按“终端”，打开。\n\n导入第三方的包，别人都有file→setting，我这怎么就是没有。也是心累。\n\n在这里记录一下，免得跟多人入坑\n\n1、PyCharm→Preferences→Project：项目名→Project Interpreter\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-ea23f8ce76a0c6fc?imageMogr2/auto-orient/strip|imageView2/2/w/1003/format/webp)\n\n2、点击这个加号可以导入新的库,点击install，这里以requests库为例\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-2407675f4ef9d068?imageMogr2/auto-orient/strip|imageView2/2/w/924/format/webp)\n\n3、查看是否已经存在\n\n![img](https:////upload-images.jianshu.io/upload_images/17223368-58d95cbcea9a5638?imageMogr2/auto-orient/strip|imageView2/2/w/1003/format/webp)\n\n库已经导入了。","slug":"2021.12/【自动化测试】WEB自动化测试环境搭建","published":1,"updated":"2021-12-08T15:54:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3ws0010n4epezwm3jnh","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>一、selenium安装</p>\n<p>Python3.x安装后就默认就会有pip（pip.exe默认在python的Scripts路径下），使用pip安装selenium：</p>\n<p>在CMD命令行输入：pip install selenium </p>\n<p>二、Webdriver、geckodriver下载配置：</p>\n<p>Webdriver下载路径：<a href=\"http://chromedriver.storage.googleapis.com/index.html，用于驱动打开Chrome；\" target=\"_blank\" rel=\"noopener\">http://chromedriver.storage.googleapis.com/index.html，用于驱动打开Chrome；</a></p>\n<p>geckodriver下载路径：<a href=\"https://github.com/mozilla/geckodriver/releases，用于驱动打开Firefox；\" target=\"_blank\" rel=\"noopener\">https://github.com/mozilla/geckodriver/releases，用于驱动打开Firefox；</a></p>\n<p>下载后放在python.exe相同目录下:</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-b0594b2a52a4034b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/755/format/webp\" alt=\"img\"></p>\n<p>测试下：打开python自带编辑器IDLE</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-d4dc876f1a52d488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/472/format/webp\" alt=\"img\"></p>\n<p>如果能正常运行就证明驱动安装成功</p>\n<p>三、pyCharm设置</p>\n<p>打开pyCharm,点开File-Settings加入selenium，如下图，点+搜索selenium，点Install Package</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-e1a2c5f78a16bf5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1194/format/webp\" alt=\"img\"></p>\n<p>二、mac环境搭建</p>\n<p>1.前提</p>\n<p>(1)mac系统自带python2.7，如果你要的是python3版本，需要自己下载安装。</p>\n<p>(2)安装好IDE:pycharm</p>\n<p>(3)安装好chrome浏览器</p>\n<p>(4)下载chromedriver : <a href=\"http://npm.taobao.org/mirrors/chromedriver/2.36/（放到user/local/bin，打开访达-前往-前往文件夹：输入/usr/local/bin）\" target=\"_blank\" rel=\"noopener\">http://npm.taobao.org/mirrors/chromedriver/2.36/（放到user/local/bin，打开访达-前往-前往文件夹：输入/usr/local/bin）</a></p>\n<p>————————————————</p>\n<p>2.安装selenium操作：</p>\n<p>打开终端，输入：sudo pip3 install selenium（python2版本输入sudo pip install selenium） </p>\n<p>打开“终端”方法：</p>\n<p>在 Mac 上，请执行以下一项操作：</p>\n<p>点按程序坞中的“启动台”图标 ，在搜索栏中键入“终端”，然后点按“终端”。</p>\n<p>在“访达”中，打开“/应用程序/实用工具”文件夹，然后连按“终端”，打开。</p>\n<p>导入第三方的包，别人都有file→setting，我这怎么就是没有。也是心累。</p>\n<p>在这里记录一下，免得跟多人入坑</p>\n<p>1、PyCharm→Preferences→Project：项目名→Project Interpreter</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-ea23f8ce76a0c6fc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1003/format/webp\" alt=\"img\"></p>\n<p>2、点击这个加号可以导入新的库,点击install，这里以requests库为例</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-2407675f4ef9d068?imageMogr2/auto-orient/strip%7CimageView2/2/w/924/format/webp\" alt=\"img\"></p>\n<p>3、查看是否已经存在</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-58d95cbcea9a5638?imageMogr2/auto-orient/strip%7CimageView2/2/w/1003/format/webp\" alt=\"img\"></p>\n<p>库已经导入了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一、selenium安装</p>\n<p>Python3.x安装后就默认就会有pip（pip.exe默认在python的Scripts路径下），使用pip安装selenium：</p>\n<p>在CMD命令行输入：pip install selenium </p>\n<p>二、Webdriver、geckodriver下载配置：</p>\n<p>Webdriver下载路径：<a href=\"http://chromedriver.storage.googleapis.com/index.html，用于驱动打开Chrome；\" target=\"_blank\" rel=\"noopener\">http://chromedriver.storage.googleapis.com/index.html，用于驱动打开Chrome；</a></p>\n<p>geckodriver下载路径：<a href=\"https://github.com/mozilla/geckodriver/releases，用于驱动打开Firefox；\" target=\"_blank\" rel=\"noopener\">https://github.com/mozilla/geckodriver/releases，用于驱动打开Firefox；</a></p>\n<p>下载后放在python.exe相同目录下:</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-b0594b2a52a4034b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/755/format/webp\" alt=\"img\"></p>\n<p>测试下：打开python自带编辑器IDLE</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-d4dc876f1a52d488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/472/format/webp\" alt=\"img\"></p>\n<p>如果能正常运行就证明驱动安装成功</p>\n<p>三、pyCharm设置</p>\n<p>打开pyCharm,点开File-Settings加入selenium，如下图，点+搜索selenium，点Install Package</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-e1a2c5f78a16bf5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1194/format/webp\" alt=\"img\"></p>\n<p>二、mac环境搭建</p>\n<p>1.前提</p>\n<p>(1)mac系统自带python2.7，如果你要的是python3版本，需要自己下载安装。</p>\n<p>(2)安装好IDE:pycharm</p>\n<p>(3)安装好chrome浏览器</p>\n<p>(4)下载chromedriver : <a href=\"http://npm.taobao.org/mirrors/chromedriver/2.36/（放到user/local/bin，打开访达-前往-前往文件夹：输入/usr/local/bin）\" target=\"_blank\" rel=\"noopener\">http://npm.taobao.org/mirrors/chromedriver/2.36/（放到user/local/bin，打开访达-前往-前往文件夹：输入/usr/local/bin）</a></p>\n<p>————————————————</p>\n<p>2.安装selenium操作：</p>\n<p>打开终端，输入：sudo pip3 install selenium（python2版本输入sudo pip install selenium） </p>\n<p>打开“终端”方法：</p>\n<p>在 Mac 上，请执行以下一项操作：</p>\n<p>点按程序坞中的“启动台”图标 ，在搜索栏中键入“终端”，然后点按“终端”。</p>\n<p>在“访达”中，打开“/应用程序/实用工具”文件夹，然后连按“终端”，打开。</p>\n<p>导入第三方的包，别人都有file→setting，我这怎么就是没有。也是心累。</p>\n<p>在这里记录一下，免得跟多人入坑</p>\n<p>1、PyCharm→Preferences→Project：项目名→Project Interpreter</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-ea23f8ce76a0c6fc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1003/format/webp\" alt=\"img\"></p>\n<p>2、点击这个加号可以导入新的库,点击install，这里以requests库为例</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-2407675f4ef9d068?imageMogr2/auto-orient/strip%7CimageView2/2/w/924/format/webp\" alt=\"img\"></p>\n<p>3、查看是否已经存在</p>\n<p><img src=\"https:////upload-images.jianshu.io/upload_images/17223368-58d95cbcea9a5638?imageMogr2/auto-orient/strip%7CimageView2/2/w/1003/format/webp\" alt=\"img\"></p>\n<p>库已经导入了。</p>\n"},{"layout":"selenium","title":"【自动化测试】python自动化测试环境搭建","date":"2021-12-07T10:18:21.000Z","_content":"\nhttp://www.testclass.net/ 测试教程网，专业的selenium 学习网站。\n\n \n\nselenium 是一个web的自动化测试工具，不少学习功能自动化的同学开始首选selenium ，相因为它相比QTP有诸多有点：\n\n\\* 免费，也不用再为破解QTP而大伤脑筋\n\n\\* 小巧，对于不同的语言它只是一个包而已，而QTP需要下载安装1个多G 的程序。\n\n\\* 这也是最重要的一点，不管你以前更熟悉C、 java、ruby、python、或都是C# ，你都可以通过selenium完成自动化测试，而QTP只支持VBS \n\n\\* 支持多平台：windows、linux、MAC ，支持多浏览器：ie、ff、safari、opera、chrome\n\n\\* 支持分布式测试用例的执行，可以把测试用例分布到不同的测试机器的执行，相当于分发机的功能。\n\n \n\n关于selenium的基础知识与java平台的结合，我之前写过一个《菜鸟学习自动化测试》系列，最近学python，所以想尝试一下selenium的在python平台如何搭建；还好这方法的文章很容易，在此将搭建步骤整理分享。\n\n \n\n搭建平台windows \n\n准备工具如下：\n\n\\-------------------------------------------------------------\n\n下载python\n\nhttps://www.python.org/\n\n\\-------------------------------------------------------------\n\n如果你是新学python，哪果你没有要用的包是必须依赖于pyhton2.x 的，那么请毫不犹豫的选择python3.5吧！\n\n \n\n \n\n**window安装步骤：**\n\n \n\n　　1、下载python安装。\n\n　　https://www.python.org/downloads/release/python-351/\n\n![img](https://images2015.cnblogs.com/blog/311516/201606/311516-20160624115021578-1069073897.png)\n\n \n\n根据自己的操作系统32/64 位，选择相应的版本。\n\n安装过程我就没必要描述，我的安装目录为：C:\\Python35\n\n \n\n 2、进入cmd(windows命令提示符)下面输入\"python\"命令。\n\n（如果提示python不是内部或外部命令！别急，去配置一下环境变量吧）\n\n\n\n \n\n3、安装selenium\n\n3.1、通过pip 安装\n\nC:\\Users\\fnngj>python3 -m pip install selenium \n\n3.2、通过下载包安装\n\n或者直接下载selenium包：\n\nhttps://pypi.python.org/pypi/selenium\n\n解压，cmd进入目录:\n\nC:\\selenium\\selenium2.53.5> python3 setup.py install\n\n \n\n \n\n===============================================\n\n \n\n \n\n**ubuntu 下安装方式：**\n\n \n\n1、安装：setuptools\n\nroot@fnngj-H24X:~# apt-get install python-setuptools\n\n2、安装pip\n\nroot@fnngj-H24X:/home/fnngj/python# tar -zxvf pip-1.4.1.tar.gz\n\nroot@fnngj-H24X:/home/fnngj/python# cd pip-1.4.1/\n\nroot@fnngj-H24X:/home/fnngj/python# python setup.py install\n\n3、安装selenium\n\nroot@fnngj-H24X:/home/fnngj/python/pip-1.4.1# pip install -U selenium\n\n \n\n恭喜~！ 你前期工作已经做了，上面的步骤确实有些繁琐，但是并不难，不过我们已经完成成了，下面体验一下成果吧！ 拿python网站上的例子：\n\n \n\n\n\n```\nfrom selenium import webdriver\nfrom selenium.common.exceptions import NoSuchElementException\nfrom selenium.webdriver.common.keys import Keys\nimport time\n\nbrowser = webdriver.Firefox() # Get local session of firefox\nbrowser.get(\"http://www.yahoo.com\") # Load page\nassert \"Yahoo!\" in browser.title\nelem = browser.find_element_by_name(\"p\") # Find the query box\nelem.send_keys(\"seleniumhq\" + Keys.RETURN)\ntime.sleep(0.2) # Let the page load, will be added to the API\ntry:\n    browser.find_element_by_xpath(\"//a[contains(@href,'http://seleniumhq.org')]\")\nexcept NoSuchElementException:\n    assert 0, \"can't find seleniumhq\"\nbrowser.close()\n```\n\n\n\n \n\n（运行过程中如果出现错误： \n\nWebDriverException: Message: u'Unexpected error launching Internet Explorer.\n\n Protected Mode settings are not the same for all zones. Enable Protected Mo\n\nde must be set to the same value (enabled or disabled) for all zones.' \n\n更改IE的internet选项->安全，将Internet/本地Internet/受信任的站定/受限制的站点中的启用保护模式全部去 掉勾，或者全部勾上。）\n\n \n\n\\-----------------------------------------\n\nselenium + python的一份不错文档\n\nhttp://selenium.googlecode.com/git/docs/api/py/index.html\n\n \n\n===========================如果想通过其它浏览器（IE Chrome）运行脚本=================================\n\n \n\n**安装Chrome driver**\n\nchrome driver的下载地址在[这里](https://code.google.com/p/chromedriver/downloads/list)。\n\n　　1. 下载解压，你会得到一个chromedriver.exe文件（我点开，运行提示started no prot 9515 ，这是干嘛的？端口9515被占了？中间折腾了半天），后来才知道需要把这家伙放到chrome的安装目录下...\\Google\\Chrome\\Application\\ ,然后设置path环境变量，把chrome的安装目录（我的：C:\\Program Files\\Google\\Chrome\\Application），然后再调用运行：\n\n\n\n```\n# coding = utf-8\n\nfrom selenium import webdriver\n\ndriver = webdriver.Chrome()\n\ndriver.get('http://radar.kuaibo.com')\n\nprint driver.title\n\ndriver.quit()\n```\n\n\n\n又报了个错：\n\nChrome version must be >= 27.0.1453.0\\n (Driver info: chromedriver=2.0,platform=Windows NT 5.1 SP3 x86)\n\n说我chrome的版本没有大于27.0.1453.0 ，这个好办，更新到最新版本即可。\n\n \n\n**安装IE driver**\n\n在新版本的webdriver中，只有安装了ie driver使用ie进行测试工作。\n\nie driver的下载地址在[这里](https://code.google.com/p/selenium/downloads/list)，记得根据自己机器的操作系统版本来下载相应的driver。\n\n暂时还没尝试，应该和chrome的安装方式类似。\n\n \n\n**记得配置IE的保护模式**\n\n如果要使用webdriver启动IE的话，那么就需要配置IE的保护模式了。\n\n把IE里的保护模式都选上或都勾掉就可以了。\n\n \n\n \n\n 乙醇的安装方式：\n\n http://easonhan007.github.io/python/2013/05/07/setup-env/\n\n5分钟安装好selenium webdriver + python 环境：\n\nhttp://v.youku.com/v_show/id_XNjQ1MDI5Nzc2.html?qq-pf-to=pcqq.group","source":"_posts/2021.12/【自动化测试】python自动化测试环境搭建.md","raw":"---\nlayout: selenium\ntitle: 【自动化测试】python自动化测试环境搭建\ndate: 2021-12-07 18:18:21\ntags:\n---\n\nhttp://www.testclass.net/ 测试教程网，专业的selenium 学习网站。\n\n \n\nselenium 是一个web的自动化测试工具，不少学习功能自动化的同学开始首选selenium ，相因为它相比QTP有诸多有点：\n\n\\* 免费，也不用再为破解QTP而大伤脑筋\n\n\\* 小巧，对于不同的语言它只是一个包而已，而QTP需要下载安装1个多G 的程序。\n\n\\* 这也是最重要的一点，不管你以前更熟悉C、 java、ruby、python、或都是C# ，你都可以通过selenium完成自动化测试，而QTP只支持VBS \n\n\\* 支持多平台：windows、linux、MAC ，支持多浏览器：ie、ff、safari、opera、chrome\n\n\\* 支持分布式测试用例的执行，可以把测试用例分布到不同的测试机器的执行，相当于分发机的功能。\n\n \n\n关于selenium的基础知识与java平台的结合，我之前写过一个《菜鸟学习自动化测试》系列，最近学python，所以想尝试一下selenium的在python平台如何搭建；还好这方法的文章很容易，在此将搭建步骤整理分享。\n\n \n\n搭建平台windows \n\n准备工具如下：\n\n\\-------------------------------------------------------------\n\n下载python\n\nhttps://www.python.org/\n\n\\-------------------------------------------------------------\n\n如果你是新学python，哪果你没有要用的包是必须依赖于pyhton2.x 的，那么请毫不犹豫的选择python3.5吧！\n\n \n\n \n\n**window安装步骤：**\n\n \n\n　　1、下载python安装。\n\n　　https://www.python.org/downloads/release/python-351/\n\n![img](https://images2015.cnblogs.com/blog/311516/201606/311516-20160624115021578-1069073897.png)\n\n \n\n根据自己的操作系统32/64 位，选择相应的版本。\n\n安装过程我就没必要描述，我的安装目录为：C:\\Python35\n\n \n\n 2、进入cmd(windows命令提示符)下面输入\"python\"命令。\n\n（如果提示python不是内部或外部命令！别急，去配置一下环境变量吧）\n\n\n\n \n\n3、安装selenium\n\n3.1、通过pip 安装\n\nC:\\Users\\fnngj>python3 -m pip install selenium \n\n3.2、通过下载包安装\n\n或者直接下载selenium包：\n\nhttps://pypi.python.org/pypi/selenium\n\n解压，cmd进入目录:\n\nC:\\selenium\\selenium2.53.5> python3 setup.py install\n\n \n\n \n\n===============================================\n\n \n\n \n\n**ubuntu 下安装方式：**\n\n \n\n1、安装：setuptools\n\nroot@fnngj-H24X:~# apt-get install python-setuptools\n\n2、安装pip\n\nroot@fnngj-H24X:/home/fnngj/python# tar -zxvf pip-1.4.1.tar.gz\n\nroot@fnngj-H24X:/home/fnngj/python# cd pip-1.4.1/\n\nroot@fnngj-H24X:/home/fnngj/python# python setup.py install\n\n3、安装selenium\n\nroot@fnngj-H24X:/home/fnngj/python/pip-1.4.1# pip install -U selenium\n\n \n\n恭喜~！ 你前期工作已经做了，上面的步骤确实有些繁琐，但是并不难，不过我们已经完成成了，下面体验一下成果吧！ 拿python网站上的例子：\n\n \n\n\n\n```\nfrom selenium import webdriver\nfrom selenium.common.exceptions import NoSuchElementException\nfrom selenium.webdriver.common.keys import Keys\nimport time\n\nbrowser = webdriver.Firefox() # Get local session of firefox\nbrowser.get(\"http://www.yahoo.com\") # Load page\nassert \"Yahoo!\" in browser.title\nelem = browser.find_element_by_name(\"p\") # Find the query box\nelem.send_keys(\"seleniumhq\" + Keys.RETURN)\ntime.sleep(0.2) # Let the page load, will be added to the API\ntry:\n    browser.find_element_by_xpath(\"//a[contains(@href,'http://seleniumhq.org')]\")\nexcept NoSuchElementException:\n    assert 0, \"can't find seleniumhq\"\nbrowser.close()\n```\n\n\n\n \n\n（运行过程中如果出现错误： \n\nWebDriverException: Message: u'Unexpected error launching Internet Explorer.\n\n Protected Mode settings are not the same for all zones. Enable Protected Mo\n\nde must be set to the same value (enabled or disabled) for all zones.' \n\n更改IE的internet选项->安全，将Internet/本地Internet/受信任的站定/受限制的站点中的启用保护模式全部去 掉勾，或者全部勾上。）\n\n \n\n\\-----------------------------------------\n\nselenium + python的一份不错文档\n\nhttp://selenium.googlecode.com/git/docs/api/py/index.html\n\n \n\n===========================如果想通过其它浏览器（IE Chrome）运行脚本=================================\n\n \n\n**安装Chrome driver**\n\nchrome driver的下载地址在[这里](https://code.google.com/p/chromedriver/downloads/list)。\n\n　　1. 下载解压，你会得到一个chromedriver.exe文件（我点开，运行提示started no prot 9515 ，这是干嘛的？端口9515被占了？中间折腾了半天），后来才知道需要把这家伙放到chrome的安装目录下...\\Google\\Chrome\\Application\\ ,然后设置path环境变量，把chrome的安装目录（我的：C:\\Program Files\\Google\\Chrome\\Application），然后再调用运行：\n\n\n\n```\n# coding = utf-8\n\nfrom selenium import webdriver\n\ndriver = webdriver.Chrome()\n\ndriver.get('http://radar.kuaibo.com')\n\nprint driver.title\n\ndriver.quit()\n```\n\n\n\n又报了个错：\n\nChrome version must be >= 27.0.1453.0\\n (Driver info: chromedriver=2.0,platform=Windows NT 5.1 SP3 x86)\n\n说我chrome的版本没有大于27.0.1453.0 ，这个好办，更新到最新版本即可。\n\n \n\n**安装IE driver**\n\n在新版本的webdriver中，只有安装了ie driver使用ie进行测试工作。\n\nie driver的下载地址在[这里](https://code.google.com/p/selenium/downloads/list)，记得根据自己机器的操作系统版本来下载相应的driver。\n\n暂时还没尝试，应该和chrome的安装方式类似。\n\n \n\n**记得配置IE的保护模式**\n\n如果要使用webdriver启动IE的话，那么就需要配置IE的保护模式了。\n\n把IE里的保护模式都选上或都勾掉就可以了。\n\n \n\n \n\n 乙醇的安装方式：\n\n http://easonhan007.github.io/python/2013/05/07/setup-env/\n\n5分钟安装好selenium webdriver + python 环境：\n\nhttp://v.youku.com/v_show/id_XNjQ1MDI5Nzc2.html?qq-pf-to=pcqq.group","slug":"2021.12/【自动化测试】python自动化测试环境搭建","published":1,"updated":"2021-12-07T10:18:21.000Z","comments":1,"photos":[],"link":"","_id":"cl2y4l3wt0013n4ep4st9g40k","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p><a href=\"http://www.testclass.net/\" target=\"_blank\" rel=\"noopener\">http://www.testclass.net/</a> 测试教程网，专业的selenium 学习网站。</p>\n<p>selenium 是一个web的自动化测试工具，不少学习功能自动化的同学开始首选selenium ，相因为它相比QTP有诸多有点：</p>\n<p>* 免费，也不用再为破解QTP而大伤脑筋</p>\n<p>* 小巧，对于不同的语言它只是一个包而已，而QTP需要下载安装1个多G 的程序。</p>\n<p>* 这也是最重要的一点，不管你以前更熟悉C、 java、ruby、python、或都是C# ，你都可以通过selenium完成自动化测试，而QTP只支持VBS </p>\n<p>* 支持多平台：windows、linux、MAC ，支持多浏览器：ie、ff、safari、opera、chrome</p>\n<p>* 支持分布式测试用例的执行，可以把测试用例分布到不同的测试机器的执行，相当于分发机的功能。</p>\n<p>关于selenium的基础知识与java平台的结合，我之前写过一个《菜鸟学习自动化测试》系列，最近学python，所以想尝试一下selenium的在python平台如何搭建；还好这方法的文章很容易，在此将搭建步骤整理分享。</p>\n<p>搭建平台windows </p>\n<p>准备工具如下：</p>\n<p>-————————————————————</p>\n<p>下载python</p>\n<p><a href=\"https://www.python.org/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/</a></p>\n<p>-————————————————————</p>\n<p>如果你是新学python，哪果你没有要用的包是必须依赖于pyhton2.x 的，那么请毫不犹豫的选择python3.5吧！</p>\n<p><strong>window安装步骤：</strong></p>\n<p>　　1、下载python安装。</p>\n<p>　　<a href=\"https://www.python.org/downloads/release/python-351/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/downloads/release/python-351/</a></p>\n<p><img src=\"https://images2015.cnblogs.com/blog/311516/201606/311516-20160624115021578-1069073897.png\" alt=\"img\"></p>\n<p>根据自己的操作系统32/64 位，选择相应的版本。</p>\n<p>安装过程我就没必要描述，我的安装目录为：C:\\Python35</p>\n<p> 2、进入cmd(windows命令提示符)下面输入”python”命令。</p>\n<p>（如果提示python不是内部或外部命令！别急，去配置一下环境变量吧）</p>\n<p>3、安装selenium</p>\n<p>3.1、通过pip 安装</p>\n<p>C:\\Users\\fnngj&gt;python3 -m pip install selenium </p>\n<p>3.2、通过下载包安装</p>\n<p>或者直接下载selenium包：</p>\n<p><a href=\"https://pypi.python.org/pypi/selenium\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/selenium</a></p>\n<p>解压，cmd进入目录:</p>\n<p>C:\\selenium\\selenium2.53.5&gt; python3 setup.py install</p>\n<p>===============================================</p>\n<p><strong>ubuntu 下安装方式：</strong></p>\n<p>1、安装：setuptools</p>\n<p>root@fnngj-H24X:~# apt-get install python-setuptools</p>\n<p>2、安装pip</p>\n<p>root@fnngj-H24X:/home/fnngj/python# tar -zxvf pip-1.4.1.tar.gz</p>\n<p>root@fnngj-H24X:/home/fnngj/python# cd pip-1.4.1/</p>\n<p>root@fnngj-H24X:/home/fnngj/python# python setup.py install</p>\n<p>3、安装selenium</p>\n<p>root@fnngj-H24X:/home/fnngj/python/pip-1.4.1# pip install -U selenium</p>\n<p>恭喜~！ 你前期工作已经做了，上面的步骤确实有些繁琐，但是并不难，不过我们已经完成成了，下面体验一下成果吧！ 拿python网站上的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from selenium import webdriver</span><br><span class=\"line\">from selenium.common.exceptions import NoSuchElementException</span><br><span class=\"line\">from selenium.webdriver.common.keys import Keys</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">browser &#x3D; webdriver.Firefox() # Get local session of firefox</span><br><span class=\"line\">browser.get(&quot;http:&#x2F;&#x2F;www.yahoo.com&quot;) # Load page</span><br><span class=\"line\">assert &quot;Yahoo!&quot; in browser.title</span><br><span class=\"line\">elem &#x3D; browser.find_element_by_name(&quot;p&quot;) # Find the query box</span><br><span class=\"line\">elem.send_keys(&quot;seleniumhq&quot; + Keys.RETURN)</span><br><span class=\"line\">time.sleep(0.2) # Let the page load, will be added to the API</span><br><span class=\"line\">try:</span><br><span class=\"line\">    browser.find_element_by_xpath(&quot;&#x2F;&#x2F;a[contains(@href,&#39;http:&#x2F;&#x2F;seleniumhq.org&#39;)]&quot;)</span><br><span class=\"line\">except NoSuchElementException:</span><br><span class=\"line\">    assert 0, &quot;can&#39;t find seleniumhq&quot;</span><br><span class=\"line\">browser.close()</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>（运行过程中如果出现错误： </p>\n<p>WebDriverException: Message: u’Unexpected error launching Internet Explorer.</p>\n<p> Protected Mode settings are not the same for all zones. Enable Protected Mo</p>\n<p>de must be set to the same value (enabled or disabled) for all zones.’ </p>\n<p>更改IE的internet选项-&gt;安全，将Internet/本地Internet/受信任的站定/受限制的站点中的启用保护模式全部去 掉勾，或者全部勾上。）</p>\n<p>-—————————————-</p>\n<p>selenium + python的一份不错文档</p>\n<p><a href=\"http://selenium.googlecode.com/git/docs/api/py/index.html\" target=\"_blank\" rel=\"noopener\">http://selenium.googlecode.com/git/docs/api/py/index.html</a></p>\n<p>===========================如果想通过其它浏览器（IE Chrome）运行脚本=================================</p>\n<p><strong>安装Chrome driver</strong></p>\n<p>chrome driver的下载地址在<a href=\"https://code.google.com/p/chromedriver/downloads/list\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>　　1. 下载解压，你会得到一个chromedriver.exe文件（我点开，运行提示started no prot 9515 ，这是干嘛的？端口9515被占了？中间折腾了半天），后来才知道需要把这家伙放到chrome的安装目录下…\\Google\\Chrome\\Application\\ ,然后设置path环境变量，把chrome的安装目录（我的：C:\\Program Files\\Google\\Chrome\\Application），然后再调用运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># coding &#x3D; utf-8</span><br><span class=\"line\"></span><br><span class=\"line\">from selenium import webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">driver &#x3D; webdriver.Chrome()</span><br><span class=\"line\"></span><br><span class=\"line\">driver.get(&#39;http:&#x2F;&#x2F;radar.kuaibo.com&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">print driver.title</span><br><span class=\"line\"></span><br><span class=\"line\">driver.quit()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>又报了个错：</p>\n<p>Chrome version must be &gt;= 27.0.1453.0\\n (Driver info: chromedriver=2.0,platform=Windows NT 5.1 SP3 x86)</p>\n<p>说我chrome的版本没有大于27.0.1453.0 ，这个好办，更新到最新版本即可。</p>\n<p><strong>安装IE driver</strong></p>\n<p>在新版本的webdriver中，只有安装了ie driver使用ie进行测试工作。</p>\n<p>ie driver的下载地址在<a href=\"https://code.google.com/p/selenium/downloads/list\" target=\"_blank\" rel=\"noopener\">这里</a>，记得根据自己机器的操作系统版本来下载相应的driver。</p>\n<p>暂时还没尝试，应该和chrome的安装方式类似。</p>\n<p><strong>记得配置IE的保护模式</strong></p>\n<p>如果要使用webdriver启动IE的话，那么就需要配置IE的保护模式了。</p>\n<p>把IE里的保护模式都选上或都勾掉就可以了。</p>\n<p> 乙醇的安装方式：</p>\n<p> <a href=\"http://easonhan007.github.io/python/2013/05/07/setup-env/\" target=\"_blank\" rel=\"noopener\">http://easonhan007.github.io/python/2013/05/07/setup-env/</a></p>\n<p>5分钟安装好selenium webdriver + python 环境：</p>\n<p><a href=\"http://v.youku.com/v_show/id_XNjQ1MDI5Nzc2.html?qq-pf-to=pcqq.group\" target=\"_blank\" rel=\"noopener\">http://v.youku.com/v_show/id_XNjQ1MDI5Nzc2.html?qq-pf-to=pcqq.group</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.testclass.net/\" target=\"_blank\" rel=\"noopener\">http://www.testclass.net/</a> 测试教程网，专业的selenium 学习网站。</p>\n<p>selenium 是一个web的自动化测试工具，不少学习功能自动化的同学开始首选selenium ，相因为它相比QTP有诸多有点：</p>\n<p>* 免费，也不用再为破解QTP而大伤脑筋</p>\n<p>* 小巧，对于不同的语言它只是一个包而已，而QTP需要下载安装1个多G 的程序。</p>\n<p>* 这也是最重要的一点，不管你以前更熟悉C、 java、ruby、python、或都是C# ，你都可以通过selenium完成自动化测试，而QTP只支持VBS </p>\n<p>* 支持多平台：windows、linux、MAC ，支持多浏览器：ie、ff、safari、opera、chrome</p>\n<p>* 支持分布式测试用例的执行，可以把测试用例分布到不同的测试机器的执行，相当于分发机的功能。</p>\n<p>关于selenium的基础知识与java平台的结合，我之前写过一个《菜鸟学习自动化测试》系列，最近学python，所以想尝试一下selenium的在python平台如何搭建；还好这方法的文章很容易，在此将搭建步骤整理分享。</p>\n<p>搭建平台windows </p>\n<p>准备工具如下：</p>\n<p>-————————————————————</p>\n<p>下载python</p>\n<p><a href=\"https://www.python.org/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/</a></p>\n<p>-————————————————————</p>\n<p>如果你是新学python，哪果你没有要用的包是必须依赖于pyhton2.x 的，那么请毫不犹豫的选择python3.5吧！</p>\n<p><strong>window安装步骤：</strong></p>\n<p>　　1、下载python安装。</p>\n<p>　　<a href=\"https://www.python.org/downloads/release/python-351/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/downloads/release/python-351/</a></p>\n<p><img src=\"https://images2015.cnblogs.com/blog/311516/201606/311516-20160624115021578-1069073897.png\" alt=\"img\"></p>\n<p>根据自己的操作系统32/64 位，选择相应的版本。</p>\n<p>安装过程我就没必要描述，我的安装目录为：C:\\Python35</p>\n<p> 2、进入cmd(windows命令提示符)下面输入”python”命令。</p>\n<p>（如果提示python不是内部或外部命令！别急，去配置一下环境变量吧）</p>\n<p>3、安装selenium</p>\n<p>3.1、通过pip 安装</p>\n<p>C:\\Users\\fnngj&gt;python3 -m pip install selenium </p>\n<p>3.2、通过下载包安装</p>\n<p>或者直接下载selenium包：</p>\n<p><a href=\"https://pypi.python.org/pypi/selenium\" target=\"_blank\" rel=\"noopener\">https://pypi.python.org/pypi/selenium</a></p>\n<p>解压，cmd进入目录:</p>\n<p>C:\\selenium\\selenium2.53.5&gt; python3 setup.py install</p>\n<p>===============================================</p>\n<p><strong>ubuntu 下安装方式：</strong></p>\n<p>1、安装：setuptools</p>\n<p>root@fnngj-H24X:~# apt-get install python-setuptools</p>\n<p>2、安装pip</p>\n<p>root@fnngj-H24X:/home/fnngj/python# tar -zxvf pip-1.4.1.tar.gz</p>\n<p>root@fnngj-H24X:/home/fnngj/python# cd pip-1.4.1/</p>\n<p>root@fnngj-H24X:/home/fnngj/python# python setup.py install</p>\n<p>3、安装selenium</p>\n<p>root@fnngj-H24X:/home/fnngj/python/pip-1.4.1# pip install -U selenium</p>\n<p>恭喜~！ 你前期工作已经做了，上面的步骤确实有些繁琐，但是并不难，不过我们已经完成成了，下面体验一下成果吧！ 拿python网站上的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from selenium import webdriver</span><br><span class=\"line\">from selenium.common.exceptions import NoSuchElementException</span><br><span class=\"line\">from selenium.webdriver.common.keys import Keys</span><br><span class=\"line\">import time</span><br><span class=\"line\"></span><br><span class=\"line\">browser &#x3D; webdriver.Firefox() # Get local session of firefox</span><br><span class=\"line\">browser.get(&quot;http:&#x2F;&#x2F;www.yahoo.com&quot;) # Load page</span><br><span class=\"line\">assert &quot;Yahoo!&quot; in browser.title</span><br><span class=\"line\">elem &#x3D; browser.find_element_by_name(&quot;p&quot;) # Find the query box</span><br><span class=\"line\">elem.send_keys(&quot;seleniumhq&quot; + Keys.RETURN)</span><br><span class=\"line\">time.sleep(0.2) # Let the page load, will be added to the API</span><br><span class=\"line\">try:</span><br><span class=\"line\">    browser.find_element_by_xpath(&quot;&#x2F;&#x2F;a[contains(@href,&#39;http:&#x2F;&#x2F;seleniumhq.org&#39;)]&quot;)</span><br><span class=\"line\">except NoSuchElementException:</span><br><span class=\"line\">    assert 0, &quot;can&#39;t find seleniumhq&quot;</span><br><span class=\"line\">browser.close()</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p>（运行过程中如果出现错误： </p>\n<p>WebDriverException: Message: u’Unexpected error launching Internet Explorer.</p>\n<p> Protected Mode settings are not the same for all zones. Enable Protected Mo</p>\n<p>de must be set to the same value (enabled or disabled) for all zones.’ </p>\n<p>更改IE的internet选项-&gt;安全，将Internet/本地Internet/受信任的站定/受限制的站点中的启用保护模式全部去 掉勾，或者全部勾上。）</p>\n<p>-—————————————-</p>\n<p>selenium + python的一份不错文档</p>\n<p><a href=\"http://selenium.googlecode.com/git/docs/api/py/index.html\" target=\"_blank\" rel=\"noopener\">http://selenium.googlecode.com/git/docs/api/py/index.html</a></p>\n<p>===========================如果想通过其它浏览器（IE Chrome）运行脚本=================================</p>\n<p><strong>安装Chrome driver</strong></p>\n<p>chrome driver的下载地址在<a href=\"https://code.google.com/p/chromedriver/downloads/list\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>　　1. 下载解压，你会得到一个chromedriver.exe文件（我点开，运行提示started no prot 9515 ，这是干嘛的？端口9515被占了？中间折腾了半天），后来才知道需要把这家伙放到chrome的安装目录下…\\Google\\Chrome\\Application\\ ,然后设置path环境变量，把chrome的安装目录（我的：C:\\Program Files\\Google\\Chrome\\Application），然后再调用运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># coding &#x3D; utf-8</span><br><span class=\"line\"></span><br><span class=\"line\">from selenium import webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">driver &#x3D; webdriver.Chrome()</span><br><span class=\"line\"></span><br><span class=\"line\">driver.get(&#39;http:&#x2F;&#x2F;radar.kuaibo.com&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">print driver.title</span><br><span class=\"line\"></span><br><span class=\"line\">driver.quit()</span><br></pre></td></tr></table></figure>\n\n\n\n<p>又报了个错：</p>\n<p>Chrome version must be &gt;= 27.0.1453.0\\n (Driver info: chromedriver=2.0,platform=Windows NT 5.1 SP3 x86)</p>\n<p>说我chrome的版本没有大于27.0.1453.0 ，这个好办，更新到最新版本即可。</p>\n<p><strong>安装IE driver</strong></p>\n<p>在新版本的webdriver中，只有安装了ie driver使用ie进行测试工作。</p>\n<p>ie driver的下载地址在<a href=\"https://code.google.com/p/selenium/downloads/list\" target=\"_blank\" rel=\"noopener\">这里</a>，记得根据自己机器的操作系统版本来下载相应的driver。</p>\n<p>暂时还没尝试，应该和chrome的安装方式类似。</p>\n<p><strong>记得配置IE的保护模式</strong></p>\n<p>如果要使用webdriver启动IE的话，那么就需要配置IE的保护模式了。</p>\n<p>把IE里的保护模式都选上或都勾掉就可以了。</p>\n<p> 乙醇的安装方式：</p>\n<p> <a href=\"http://easonhan007.github.io/python/2013/05/07/setup-env/\" target=\"_blank\" rel=\"noopener\">http://easonhan007.github.io/python/2013/05/07/setup-env/</a></p>\n<p>5分钟安装好selenium webdriver + python 环境：</p>\n<p><a href=\"http://v.youku.com/v_show/id_XNjQ1MDI5Nzc2.html?qq-pf-to=pcqq.group\" target=\"_blank\" rel=\"noopener\">http://v.youku.com/v_show/id_XNjQ1MDI5Nzc2.html?qq-pf-to=pcqq.group</a></p>\n"},{"title":"App自动化测试（一）之环境搭建","banner_img":"https://cdn.magdeleine.co/wp-content/uploads/2021/06/isorepublic-coffee-thanks-1-1400x933.jpg","cover":"https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/3.png","abbrlink":"baaef441","date":"2021-12-26T06:28:25.000Z","_content":"\n## App自动化测试环境搭建\n\n##  <!-- more --> 一、准备jdk环境\n\n[jdk安装和配置环境变量](http://mypeng.site/post/54eecc7d.html)\n\n## 二、准备SDK环境\n\n#### 1、 [ADT Bundle下载](https://www.androiddevtools.cn/)\n\nADT Bundle包含了Eclipse、ADT插件和SDK Tools，是已经集成好的IDE，只需安装好Jdk即可开始开发，推荐初学者下载ADT Bundle，不用再折腾开发环境。\n\n下载adt-bundle-windows-x64.zip\n\n链接：https://pan.baidu.com/s/1ZHKmPcbV4NVvZwoDzdAKpg\n提取码：2gf7\n\n#### 2、ADT Bundle安装\n\n把下载好的 adt-bundle-windows-x86_64-20140702.zip 解压即可。\n\n ![img](/img/environment/1895590-20200229210636360-1610818154.png)  \n\n#### 3、配置环境变量\n\n1. ##### 点击此电脑右击-->>点击属性\n\n![img](/img/environment/1895590-20200229210702614-864284209.png)\n\n2. ##### 配置SDK环境变量\n\n变量名：ANDROID_HOME\n\n变量值：D:\\Program Files (x86)\\adt-bundle-windows-x86_64-20140702\\sdk（要填写你自己的地址）\n\n![img](/img/environment/1895590-20200229210742813-1698355068.png)\n\n3. ##### 在path中添加变量\n\n```\n%ANDROID_HOME%\\platform-tools\n%ANDROID_HOME%\\tools\n%ANDROID_HOME%\\build-tools\\28.0.3\n```\n#### 4、验证环境变量是否配置成功\n\n在cmd窗口输入，adb 和 aapt验证环境变量是否配置成功。（** *注意：如果环境变量配置确定无误，但是输入命令出不来，就重启下电脑*）\n\n![img](/img/environment/1895590-20200229210909009-805568491.png)\n\n![img](/img/environment/1895590-20200229210835166-2050290710.png)\n\n## 三、安装Appium\nappium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web应用和混合应用。\n\n#### 1、[Appium下载](https://github.com/appium/appium-desktop/releases/tag/v1.13.0)\n\n百度云下载：\n链接：https://pan.baidu.com/s/1Di8Qh5NEYeSmQoVFqH6crQ\n提取码：huiq\n\n#### 2、Appium安装\n\n![img](/img/environment/1895590-20200229211000223-187798199.png)\n\n1. 点击Appium-windows-1.13.0.exe进行安装。\n   ![img](/img/environment/1895590-20200229211032271-1280305583.png)\n\n2. 选择 仅为我安装，点击安装。\n\n![img](/img/environment/1895590-20200229211014622-396878393.png)\n\n3. 安装完成后打开后，可能会提示更新，切记莫更新！！\n\n## 四、安装模拟器，或者使用真机\n\n##### 模拟器推荐：\n\n [【雷电】](https://www.ldmnq.com/)\n\n [【夜神】](https://www.yeshen.com/)\n\n## 五、安装Appium-Python-Client库\n\n```python\nCopypip install appium-python-client\n# 下载不成功可以加上国内镜像\n\"\"\"\n镜像：\n（1）阿里云 http://mirrors.aliyun.com/pypi/simple/\n（2）豆瓣http://pypi.douban.com/simple/\n（3）清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/\n（4）中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/\n（5）华中科技大学http://pypi.hustunique.com/\n\"\"\"\npip install appium-python-client -i \"https://pypi.doubanio.com/simple/\" \n```\n\n### 至此，环境搭建已完成。","source":"_posts/Appium/App自动化测试（一）之环境搭建.md","raw":"---\ntitle: App自动化测试（一）之环境搭建\nbanner_img: https://cdn.magdeleine.co/wp-content/uploads/2021/06/isorepublic-coffee-thanks-1-1400x933.jpg\ncover: https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/3.png\nabbrlink: baaef441\ndate: 2021-12-26 14:28:25\ntags:\n\t- Appium\ncategories:\n\t- Appium\n---\n\n## App自动化测试环境搭建\n\n##  <!-- more --> 一、准备jdk环境\n\n[jdk安装和配置环境变量](http://mypeng.site/post/54eecc7d.html)\n\n## 二、准备SDK环境\n\n#### 1、 [ADT Bundle下载](https://www.androiddevtools.cn/)\n\nADT Bundle包含了Eclipse、ADT插件和SDK Tools，是已经集成好的IDE，只需安装好Jdk即可开始开发，推荐初学者下载ADT Bundle，不用再折腾开发环境。\n\n下载adt-bundle-windows-x64.zip\n\n链接：https://pan.baidu.com/s/1ZHKmPcbV4NVvZwoDzdAKpg\n提取码：2gf7\n\n#### 2、ADT Bundle安装\n\n把下载好的 adt-bundle-windows-x86_64-20140702.zip 解压即可。\n\n ![img](/img/environment/1895590-20200229210636360-1610818154.png)  \n\n#### 3、配置环境变量\n\n1. ##### 点击此电脑右击-->>点击属性\n\n![img](/img/environment/1895590-20200229210702614-864284209.png)\n\n2. ##### 配置SDK环境变量\n\n变量名：ANDROID_HOME\n\n变量值：D:\\Program Files (x86)\\adt-bundle-windows-x86_64-20140702\\sdk（要填写你自己的地址）\n\n![img](/img/environment/1895590-20200229210742813-1698355068.png)\n\n3. ##### 在path中添加变量\n\n```\n%ANDROID_HOME%\\platform-tools\n%ANDROID_HOME%\\tools\n%ANDROID_HOME%\\build-tools\\28.0.3\n```\n#### 4、验证环境变量是否配置成功\n\n在cmd窗口输入，adb 和 aapt验证环境变量是否配置成功。（** *注意：如果环境变量配置确定无误，但是输入命令出不来，就重启下电脑*）\n\n![img](/img/environment/1895590-20200229210909009-805568491.png)\n\n![img](/img/environment/1895590-20200229210835166-2050290710.png)\n\n## 三、安装Appium\nappium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web应用和混合应用。\n\n#### 1、[Appium下载](https://github.com/appium/appium-desktop/releases/tag/v1.13.0)\n\n百度云下载：\n链接：https://pan.baidu.com/s/1Di8Qh5NEYeSmQoVFqH6crQ\n提取码：huiq\n\n#### 2、Appium安装\n\n![img](/img/environment/1895590-20200229211000223-187798199.png)\n\n1. 点击Appium-windows-1.13.0.exe进行安装。\n   ![img](/img/environment/1895590-20200229211032271-1280305583.png)\n\n2. 选择 仅为我安装，点击安装。\n\n![img](/img/environment/1895590-20200229211014622-396878393.png)\n\n3. 安装完成后打开后，可能会提示更新，切记莫更新！！\n\n## 四、安装模拟器，或者使用真机\n\n##### 模拟器推荐：\n\n [【雷电】](https://www.ldmnq.com/)\n\n [【夜神】](https://www.yeshen.com/)\n\n## 五、安装Appium-Python-Client库\n\n```python\nCopypip install appium-python-client\n# 下载不成功可以加上国内镜像\n\"\"\"\n镜像：\n（1）阿里云 http://mirrors.aliyun.com/pypi/simple/\n（2）豆瓣http://pypi.douban.com/simple/\n（3）清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/\n（4）中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/\n（5）华中科技大学http://pypi.hustunique.com/\n\"\"\"\npip install appium-python-client -i \"https://pypi.doubanio.com/simple/\" \n```\n\n### 至此，环境搭建已完成。","slug":"Appium/App自动化测试（一）之环境搭建","published":1,"updated":"2021-12-26T06:28:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wu0015n4ep95o6e5c6","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"App自动化测试环境搭建\"><a href=\"#App自动化测试环境搭建\" class=\"headerlink\" title=\"App自动化测试环境搭建\"></a>App自动化测试环境搭建</h2><h2 id=\"一、准备jdk环境\"><a href=\"#一、准备jdk环境\" class=\"headerlink\" title=\" 一、准备jdk环境\"></a><a id=\"more\"></a> 一、准备jdk环境</h2><p><a href=\"http://mypeng.site/post/54eecc7d.html\" target=\"_blank\" rel=\"noopener\">jdk安装和配置环境变量</a></p>\n<h2 id=\"二、准备SDK环境\"><a href=\"#二、准备SDK环境\" class=\"headerlink\" title=\"二、准备SDK环境\"></a>二、准备SDK环境</h2><h4 id=\"1、-ADT-Bundle下载\"><a href=\"#1、-ADT-Bundle下载\" class=\"headerlink\" title=\"1、 ADT Bundle下载\"></a>1、 <a href=\"https://www.androiddevtools.cn/\" target=\"_blank\" rel=\"noopener\">ADT Bundle下载</a></h4><p>ADT Bundle包含了Eclipse、ADT插件和SDK Tools，是已经集成好的IDE，只需安装好Jdk即可开始开发，推荐初学者下载ADT Bundle，不用再折腾开发环境。</p>\n<p>下载adt-bundle-windows-x64.zip</p>\n<p>链接：<a href=\"https://pan.baidu.com/s/1ZHKmPcbV4NVvZwoDzdAKpg\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1ZHKmPcbV4NVvZwoDzdAKpg</a><br>提取码：2gf7</p>\n<h4 id=\"2、ADT-Bundle安装\"><a href=\"#2、ADT-Bundle安装\" class=\"headerlink\" title=\"2、ADT Bundle安装\"></a>2、ADT Bundle安装</h4><p>把下载好的 adt-bundle-windows-x86_64-20140702.zip 解压即可。</p>\n<p> <img src=\"/img/environment/1895590-20200229210636360-1610818154.png\" alt=\"img\">  </p>\n<h4 id=\"3、配置环境变量\"><a href=\"#3、配置环境变量\" class=\"headerlink\" title=\"3、配置环境变量\"></a>3、配置环境变量</h4><ol>\n<li><h5 id=\"点击此电脑右击–-gt-gt-点击属性\"><a href=\"#点击此电脑右击–-gt-gt-点击属性\" class=\"headerlink\" title=\"点击此电脑右击–&gt;&gt;点击属性\"></a>点击此电脑右击–&gt;&gt;点击属性</h5></li>\n</ol>\n<p><img src=\"/img/environment/1895590-20200229210702614-864284209.png\" alt=\"img\"></p>\n<ol start=\"2\">\n<li><h5 id=\"配置SDK环境变量\"><a href=\"#配置SDK环境变量\" class=\"headerlink\" title=\"配置SDK环境变量\"></a>配置SDK环境变量</h5></li>\n</ol>\n<p>变量名：ANDROID_HOME</p>\n<p>变量值：D:\\Program Files (x86)\\adt-bundle-windows-x86_64-20140702\\sdk（要填写你自己的地址）</p>\n<p><img src=\"/img/environment/1895590-20200229210742813-1698355068.png\" alt=\"img\"></p>\n<ol start=\"3\">\n<li><h5 id=\"在path中添加变量\"><a href=\"#在path中添加变量\" class=\"headerlink\" title=\"在path中添加变量\"></a>在path中添加变量</h5></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%ANDROID_HOME%\\platform-tools</span><br><span class=\"line\">%ANDROID_HOME%\\tools</span><br><span class=\"line\">%ANDROID_HOME%\\build-tools\\28.0.3</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、验证环境变量是否配置成功\"><a href=\"#4、验证环境变量是否配置成功\" class=\"headerlink\" title=\"4、验证环境变量是否配置成功\"></a>4、验证环境变量是否配置成功</h4><p>在cmd窗口输入，adb 和 aapt验证环境变量是否配置成功。（** <em>注意：如果环境变量配置确定无误，但是输入命令出不来，就重启下电脑</em>）</p>\n<p><img src=\"/img/environment/1895590-20200229210909009-805568491.png\" alt=\"img\"></p>\n<p><img src=\"/img/environment/1895590-20200229210835166-2050290710.png\" alt=\"img\"></p>\n<h2 id=\"三、安装Appium\"><a href=\"#三、安装Appium\" class=\"headerlink\" title=\"三、安装Appium\"></a>三、安装Appium</h2><p>appium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web应用和混合应用。</p>\n<h4 id=\"1、Appium下载\"><a href=\"#1、Appium下载\" class=\"headerlink\" title=\"1、Appium下载\"></a>1、<a href=\"https://github.com/appium/appium-desktop/releases/tag/v1.13.0\" target=\"_blank\" rel=\"noopener\">Appium下载</a></h4><p>百度云下载：<br>链接：<a href=\"https://pan.baidu.com/s/1Di8Qh5NEYeSmQoVFqH6crQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1Di8Qh5NEYeSmQoVFqH6crQ</a><br>提取码：huiq</p>\n<h4 id=\"2、Appium安装\"><a href=\"#2、Appium安装\" class=\"headerlink\" title=\"2、Appium安装\"></a>2、Appium安装</h4><p><img src=\"/img/environment/1895590-20200229211000223-187798199.png\" alt=\"img\"></p>\n<ol>\n<li><p>点击Appium-windows-1.13.0.exe进行安装。<br><img src=\"/img/environment/1895590-20200229211032271-1280305583.png\" alt=\"img\"></p>\n</li>\n<li><p>选择 仅为我安装，点击安装。</p>\n</li>\n</ol>\n<p><img src=\"/img/environment/1895590-20200229211014622-396878393.png\" alt=\"img\"></p>\n<ol start=\"3\">\n<li>安装完成后打开后，可能会提示更新，切记莫更新！！</li>\n</ol>\n<h2 id=\"四、安装模拟器，或者使用真机\"><a href=\"#四、安装模拟器，或者使用真机\" class=\"headerlink\" title=\"四、安装模拟器，或者使用真机\"></a>四、安装模拟器，或者使用真机</h2><h5 id=\"模拟器推荐：\"><a href=\"#模拟器推荐：\" class=\"headerlink\" title=\"模拟器推荐：\"></a>模拟器推荐：</h5><p> <a href=\"https://www.ldmnq.com/\" target=\"_blank\" rel=\"noopener\">【雷电】</a></p>\n<p> <a href=\"https://www.yeshen.com/\" target=\"_blank\" rel=\"noopener\">【夜神】</a></p>\n<h2 id=\"五、安装Appium-Python-Client库\"><a href=\"#五、安装Appium-Python-Client库\" class=\"headerlink\" title=\"五、安装Appium-Python-Client库\"></a>五、安装Appium-Python-Client库</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copypip install appium-python-client</span><br><span class=\"line\"><span class=\"comment\"># 下载不成功可以加上国内镜像</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">镜像：</span></span><br><span class=\"line\"><span class=\"string\">（1）阿里云 http://mirrors.aliyun.com/pypi/simple/</span></span><br><span class=\"line\"><span class=\"string\">（2）豆瓣http://pypi.douban.com/simple/</span></span><br><span class=\"line\"><span class=\"string\">（3）清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span></span><br><span class=\"line\"><span class=\"string\">（4）中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</span></span><br><span class=\"line\"><span class=\"string\">（5）华中科技大学http://pypi.hustunique.com/</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\">pip install appium-python-client -i <span class=\"string\">\"https://pypi.doubanio.com/simple/\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"至此，环境搭建已完成。\"><a href=\"#至此，环境搭建已完成。\" class=\"headerlink\" title=\"至此，环境搭建已完成。\"></a>至此，环境搭建已完成。</h3>","site":{"data":{}},"excerpt":"<h2 id=\"App自动化测试环境搭建\"><a href=\"#App自动化测试环境搭建\" class=\"headerlink\" title=\"App自动化测试环境搭建\"></a>App自动化测试环境搭建</h2><h2 id=\"一、准备jdk环境\"><a href=\"#一、准备jdk环境\" class=\"headerlink\" title=\" 一、准备jdk环境\"></a>","more":"一、准备jdk环境</h2><p><a href=\"http://mypeng.site/post/54eecc7d.html\" target=\"_blank\" rel=\"noopener\">jdk安装和配置环境变量</a></p>\n<h2 id=\"二、准备SDK环境\"><a href=\"#二、准备SDK环境\" class=\"headerlink\" title=\"二、准备SDK环境\"></a>二、准备SDK环境</h2><h4 id=\"1、-ADT-Bundle下载\"><a href=\"#1、-ADT-Bundle下载\" class=\"headerlink\" title=\"1、 ADT Bundle下载\"></a>1、 <a href=\"https://www.androiddevtools.cn/\" target=\"_blank\" rel=\"noopener\">ADT Bundle下载</a></h4><p>ADT Bundle包含了Eclipse、ADT插件和SDK Tools，是已经集成好的IDE，只需安装好Jdk即可开始开发，推荐初学者下载ADT Bundle，不用再折腾开发环境。</p>\n<p>下载adt-bundle-windows-x64.zip</p>\n<p>链接：<a href=\"https://pan.baidu.com/s/1ZHKmPcbV4NVvZwoDzdAKpg\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1ZHKmPcbV4NVvZwoDzdAKpg</a><br>提取码：2gf7</p>\n<h4 id=\"2、ADT-Bundle安装\"><a href=\"#2、ADT-Bundle安装\" class=\"headerlink\" title=\"2、ADT Bundle安装\"></a>2、ADT Bundle安装</h4><p>把下载好的 adt-bundle-windows-x86_64-20140702.zip 解压即可。</p>\n<p> <img src=\"/img/environment/1895590-20200229210636360-1610818154.png\" alt=\"img\">  </p>\n<h4 id=\"3、配置环境变量\"><a href=\"#3、配置环境变量\" class=\"headerlink\" title=\"3、配置环境变量\"></a>3、配置环境变量</h4><ol>\n<li><h5 id=\"点击此电脑右击–-gt-gt-点击属性\"><a href=\"#点击此电脑右击–-gt-gt-点击属性\" class=\"headerlink\" title=\"点击此电脑右击–&gt;&gt;点击属性\"></a>点击此电脑右击–&gt;&gt;点击属性</h5></li>\n</ol>\n<p><img src=\"/img/environment/1895590-20200229210702614-864284209.png\" alt=\"img\"></p>\n<ol start=\"2\">\n<li><h5 id=\"配置SDK环境变量\"><a href=\"#配置SDK环境变量\" class=\"headerlink\" title=\"配置SDK环境变量\"></a>配置SDK环境变量</h5></li>\n</ol>\n<p>变量名：ANDROID_HOME</p>\n<p>变量值：D:\\Program Files (x86)\\adt-bundle-windows-x86_64-20140702\\sdk（要填写你自己的地址）</p>\n<p><img src=\"/img/environment/1895590-20200229210742813-1698355068.png\" alt=\"img\"></p>\n<ol start=\"3\">\n<li><h5 id=\"在path中添加变量\"><a href=\"#在path中添加变量\" class=\"headerlink\" title=\"在path中添加变量\"></a>在path中添加变量</h5></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%ANDROID_HOME%\\platform-tools</span><br><span class=\"line\">%ANDROID_HOME%\\tools</span><br><span class=\"line\">%ANDROID_HOME%\\build-tools\\28.0.3</span><br></pre></td></tr></table></figure>\n<h4 id=\"4、验证环境变量是否配置成功\"><a href=\"#4、验证环境变量是否配置成功\" class=\"headerlink\" title=\"4、验证环境变量是否配置成功\"></a>4、验证环境变量是否配置成功</h4><p>在cmd窗口输入，adb 和 aapt验证环境变量是否配置成功。（** <em>注意：如果环境变量配置确定无误，但是输入命令出不来，就重启下电脑</em>）</p>\n<p><img src=\"/img/environment/1895590-20200229210909009-805568491.png\" alt=\"img\"></p>\n<p><img src=\"/img/environment/1895590-20200229210835166-2050290710.png\" alt=\"img\"></p>\n<h2 id=\"三、安装Appium\"><a href=\"#三、安装Appium\" class=\"headerlink\" title=\"三、安装Appium\"></a>三、安装Appium</h2><p>appium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web应用和混合应用。</p>\n<h4 id=\"1、Appium下载\"><a href=\"#1、Appium下载\" class=\"headerlink\" title=\"1、Appium下载\"></a>1、<a href=\"https://github.com/appium/appium-desktop/releases/tag/v1.13.0\" target=\"_blank\" rel=\"noopener\">Appium下载</a></h4><p>百度云下载：<br>链接：<a href=\"https://pan.baidu.com/s/1Di8Qh5NEYeSmQoVFqH6crQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1Di8Qh5NEYeSmQoVFqH6crQ</a><br>提取码：huiq</p>\n<h4 id=\"2、Appium安装\"><a href=\"#2、Appium安装\" class=\"headerlink\" title=\"2、Appium安装\"></a>2、Appium安装</h4><p><img src=\"/img/environment/1895590-20200229211000223-187798199.png\" alt=\"img\"></p>\n<ol>\n<li><p>点击Appium-windows-1.13.0.exe进行安装。<br><img src=\"/img/environment/1895590-20200229211032271-1280305583.png\" alt=\"img\"></p>\n</li>\n<li><p>选择 仅为我安装，点击安装。</p>\n</li>\n</ol>\n<p><img src=\"/img/environment/1895590-20200229211014622-396878393.png\" alt=\"img\"></p>\n<ol start=\"3\">\n<li>安装完成后打开后，可能会提示更新，切记莫更新！！</li>\n</ol>\n<h2 id=\"四、安装模拟器，或者使用真机\"><a href=\"#四、安装模拟器，或者使用真机\" class=\"headerlink\" title=\"四、安装模拟器，或者使用真机\"></a>四、安装模拟器，或者使用真机</h2><h5 id=\"模拟器推荐：\"><a href=\"#模拟器推荐：\" class=\"headerlink\" title=\"模拟器推荐：\"></a>模拟器推荐：</h5><p> <a href=\"https://www.ldmnq.com/\" target=\"_blank\" rel=\"noopener\">【雷电】</a></p>\n<p> <a href=\"https://www.yeshen.com/\" target=\"_blank\" rel=\"noopener\">【夜神】</a></p>\n<h2 id=\"五、安装Appium-Python-Client库\"><a href=\"#五、安装Appium-Python-Client库\" class=\"headerlink\" title=\"五、安装Appium-Python-Client库\"></a>五、安装Appium-Python-Client库</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copypip install appium-python-client</span><br><span class=\"line\"><span class=\"comment\"># 下载不成功可以加上国内镜像</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">镜像：</span></span><br><span class=\"line\"><span class=\"string\">（1）阿里云 http://mirrors.aliyun.com/pypi/simple/</span></span><br><span class=\"line\"><span class=\"string\">（2）豆瓣http://pypi.douban.com/simple/</span></span><br><span class=\"line\"><span class=\"string\">（3）清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span></span><br><span class=\"line\"><span class=\"string\">（4）中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</span></span><br><span class=\"line\"><span class=\"string\">（5）华中科技大学http://pypi.hustunique.com/</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\">pip install appium-python-client -i <span class=\"string\">\"https://pypi.doubanio.com/simple/\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"至此，环境搭建已完成。\"><a href=\"#至此，环境搭建已完成。\" class=\"headerlink\" title=\"至此，环境搭建已完成。\"></a>至此，环境搭建已完成。</h3>"},{"title":"【测试工具】Charles破解","author":"夏见°","abbrlink":"ea42950b","date":"2022-01-01T14:50:55.000Z","cover":"https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/1.png","_content":"##  <!-- more --> Charles破解\n\nhttp://www.charles.ren\n\n##### 进入上面的网站，随意输入一个Registered Name，点击「生成」\n\n如：admin123则生成 772CD45F2C5839B6D3\n\n ![img](/img/charles_20220101225450.png) \n\n##### 打开charles-help-register，输入刚刚生成的，然后就激活成功啦\n\n ![img](/img/8B2FEFE6-9051-432B-BAED-7B76EFA85FE1.png) \n\n ![img](/img/1EE1E433-AB1C-436F-95B0-EFDA18C2BE82.png) ","source":"_posts/Charles/【测试工具】Charles破解.md","raw":"---\ntitle: 【测试工具】Charles破解\nauthor: 夏见°\nabbrlink: ea42950b\ndate: 2022-01-01 22:50:55\ncover: https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/1.png\ntags:\n  - Charles\ncategories:\n  - Charles\n---\n##  <!-- more --> Charles破解\n\nhttp://www.charles.ren\n\n##### 进入上面的网站，随意输入一个Registered Name，点击「生成」\n\n如：admin123则生成 772CD45F2C5839B6D3\n\n ![img](/img/charles_20220101225450.png) \n\n##### 打开charles-help-register，输入刚刚生成的，然后就激活成功啦\n\n ![img](/img/8B2FEFE6-9051-432B-BAED-7B76EFA85FE1.png) \n\n ![img](/img/1EE1E433-AB1C-436F-95B0-EFDA18C2BE82.png) ","slug":"Charles/【测试工具】Charles破解","published":1,"updated":"2022-01-01T14:50:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wv0016n4epb83i8x4k","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"Charles破解\"><a href=\"#Charles破解\" class=\"headerlink\" title=\" Charles破解\"></a><a id=\"more\"></a> Charles破解</h2><p><a href=\"http://www.charles.ren\" target=\"_blank\" rel=\"noopener\">http://www.charles.ren</a></p>\n<h5 id=\"进入上面的网站，随意输入一个Registered-Name，点击「生成」\"><a href=\"#进入上面的网站，随意输入一个Registered-Name，点击「生成」\" class=\"headerlink\" title=\"进入上面的网站，随意输入一个Registered Name，点击「生成」\"></a>进入上面的网站，随意输入一个Registered Name，点击「生成」</h5><p>如：admin123则生成 772CD45F2C5839B6D3</p>\n<p> <img src=\"/img/charles_20220101225450.png\" alt=\"img\"> </p>\n<h5 id=\"打开charles-help-register，输入刚刚生成的，然后就激活成功啦\"><a href=\"#打开charles-help-register，输入刚刚生成的，然后就激活成功啦\" class=\"headerlink\" title=\"打开charles-help-register，输入刚刚生成的，然后就激活成功啦\"></a>打开charles-help-register，输入刚刚生成的，然后就激活成功啦</h5><p> <img src=\"/img/8B2FEFE6-9051-432B-BAED-7B76EFA85FE1.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/1EE1E433-AB1C-436F-95B0-EFDA18C2BE82.png\" alt=\"img\"> </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Charles破解\"><a href=\"#Charles破解\" class=\"headerlink\" title=\" Charles破解\"></a>","more":"Charles破解</h2><p><a href=\"http://www.charles.ren\" target=\"_blank\" rel=\"noopener\">http://www.charles.ren</a></p>\n<h5 id=\"进入上面的网站，随意输入一个Registered-Name，点击「生成」\"><a href=\"#进入上面的网站，随意输入一个Registered-Name，点击「生成」\" class=\"headerlink\" title=\"进入上面的网站，随意输入一个Registered Name，点击「生成」\"></a>进入上面的网站，随意输入一个Registered Name，点击「生成」</h5><p>如：admin123则生成 772CD45F2C5839B6D3</p>\n<p> <img src=\"/img/charles_20220101225450.png\" alt=\"img\"> </p>\n<h5 id=\"打开charles-help-register，输入刚刚生成的，然后就激活成功啦\"><a href=\"#打开charles-help-register，输入刚刚生成的，然后就激活成功啦\" class=\"headerlink\" title=\"打开charles-help-register，输入刚刚生成的，然后就激活成功啦\"></a>打开charles-help-register，输入刚刚生成的，然后就激活成功啦</h5><p> <img src=\"/img/8B2FEFE6-9051-432B-BAED-7B76EFA85FE1.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/1EE1E433-AB1C-436F-95B0-EFDA18C2BE82.png\" alt=\"img\"> </p>"},{"title":"Hexo博客备份—妈妈再也不用担心你使用hexo写博客","cover":"https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/2.png","author":"夏见°","abbrlink":"a3886b70","date":"2022-01-01T09:09:02.000Z","_content":"今天搜了下hexo博客备份，发现好多都是用git命令备份的，于是推荐款好用的hexo备份插件：\n\n[hexo-git-backup](https://github.com/coneycode/hexo-git-backup) <!-- more --> \n\n## **git-backup使用说明(翻译至README)：**\n\n### **安装**\n\n如果您的hexo版本是2.xx，则应安装如下：\n\n```cmd\n\n$ npm install hexo-git-backup@0.0.91 --save\n\n```\n\n如果版本是3.xx，你应该安装如下：\n\n```cmd\n\n$ npm install hexo-git-backup --save\n\n```\n\n### **更新**\n\n(windows不需要$符)\n\n如果使用--save进行安装，则在更新时必须先删除。\n\n```cmd\n\n$ npm remove hexo-git-backup\n\n$ npm install hexo-git-backup --save\n\n```\n\n### **配置**\n\n你应该配置这个文件_config.yml如下。\n\n```\n\nbackup:\n\n    type: git\n\n    repository:\n\n      github: git@github.com:xxx/xxx.git,branchName\n\n      gitcafe: git@github.com:xxx/xxx.git,branchName\n\n```\n\n比如博主就新建了个backup分支用于备份\n\n博主的配置如下\n\n```cmd\n\nbackup:\n\n  type: git\n\n  message: backup my blog of https://honjun.github.io/\n\n  repository:\n\n    github: https://github.com/honjun/honjun.github.io.git,backup\n\n```\n\n### **使用**\n\n```cmd\n\nhexo backup\n\n```\n\nor\n\n```cmd\n\nhexo b\n\n```\n\nOptions\n\n如果你要备份你的主题，只需添加theme: your theme name,your theme name在_config.yml。\n\n```yml\n\nbackup:\n\n    type: git\n\n    theme: coney,landscape,xxx\n\n    repository:\n\n      github: git@github.com:xxx/xxx.git,branchName\n\n      gitcafe: git@github.com:xxx/xxx.git,branchName\n\n```\n\n**注意：如果您按照上述方式操作，themes/coney/.git则会删除目录**\n\n如果你想DIY提交消息，只需添加“消息：更新xxx”。\n\n```yml\n\nbackup:\n\n    type: git\n\n    message: update xxx\n\n    repository:\n\n      github: git@github.com:xxx/xxx.git,branchName\n\n      gitcafe: git@github.com:xxx/xxx.git,branchName\n\n```\n\n现在你可以备份所有的博客！\n\n### **问题**\n\n您的计算机许可可能会造成一些麻烦。\n\n**错误：EISDIR，打开是由权限引起的。只要做'sudo hexo b'**\n\n```cmd\n\nsudo hexo b\n\n```\n\n参考[hexo 的备份插件](https://www.v2ex.com/t/143022)","source":"_posts/Hexo/Hexo博客备份—妈妈再也不用担心你使用hexo写博客.md","raw":"---\ntitle: Hexo博客备份—妈妈再也不用担心你使用hexo写博客\ntags:\n  - Hexo\ncategories:\n  - Hexo\ncover: https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/cover-01/2.png\nauthor: 夏见°\nabbrlink: a3886b70\ndate: 2022-01-01 17:09:02\n---\n今天搜了下hexo博客备份，发现好多都是用git命令备份的，于是推荐款好用的hexo备份插件：\n\n[hexo-git-backup](https://github.com/coneycode/hexo-git-backup) <!-- more --> \n\n## **git-backup使用说明(翻译至README)：**\n\n### **安装**\n\n如果您的hexo版本是2.xx，则应安装如下：\n\n```cmd\n\n$ npm install hexo-git-backup@0.0.91 --save\n\n```\n\n如果版本是3.xx，你应该安装如下：\n\n```cmd\n\n$ npm install hexo-git-backup --save\n\n```\n\n### **更新**\n\n(windows不需要$符)\n\n如果使用--save进行安装，则在更新时必须先删除。\n\n```cmd\n\n$ npm remove hexo-git-backup\n\n$ npm install hexo-git-backup --save\n\n```\n\n### **配置**\n\n你应该配置这个文件_config.yml如下。\n\n```\n\nbackup:\n\n    type: git\n\n    repository:\n\n      github: git@github.com:xxx/xxx.git,branchName\n\n      gitcafe: git@github.com:xxx/xxx.git,branchName\n\n```\n\n比如博主就新建了个backup分支用于备份\n\n博主的配置如下\n\n```cmd\n\nbackup:\n\n  type: git\n\n  message: backup my blog of https://honjun.github.io/\n\n  repository:\n\n    github: https://github.com/honjun/honjun.github.io.git,backup\n\n```\n\n### **使用**\n\n```cmd\n\nhexo backup\n\n```\n\nor\n\n```cmd\n\nhexo b\n\n```\n\nOptions\n\n如果你要备份你的主题，只需添加theme: your theme name,your theme name在_config.yml。\n\n```yml\n\nbackup:\n\n    type: git\n\n    theme: coney,landscape,xxx\n\n    repository:\n\n      github: git@github.com:xxx/xxx.git,branchName\n\n      gitcafe: git@github.com:xxx/xxx.git,branchName\n\n```\n\n**注意：如果您按照上述方式操作，themes/coney/.git则会删除目录**\n\n如果你想DIY提交消息，只需添加“消息：更新xxx”。\n\n```yml\n\nbackup:\n\n    type: git\n\n    message: update xxx\n\n    repository:\n\n      github: git@github.com:xxx/xxx.git,branchName\n\n      gitcafe: git@github.com:xxx/xxx.git,branchName\n\n```\n\n现在你可以备份所有的博客！\n\n### **问题**\n\n您的计算机许可可能会造成一些麻烦。\n\n**错误：EISDIR，打开是由权限引起的。只要做'sudo hexo b'**\n\n```cmd\n\nsudo hexo b\n\n```\n\n参考[hexo 的备份插件](https://www.v2ex.com/t/143022)","slug":"Hexo/Hexo博客备份—妈妈再也不用担心你使用hexo写博客","published":1,"updated":"2022-01-01T09:09:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3ww001an4ep0mxz4xdw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>今天搜了下hexo博客备份，发现好多都是用git命令备份的，于是推荐款好用的hexo备份插件：</p>\n<p><a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"noopener\">hexo-git-backup</a> <a id=\"more\"></a> </p>\n<h2 id=\"git-backup使用说明-翻译至README-：\"><a href=\"#git-backup使用说明-翻译至README-：\" class=\"headerlink\" title=\"git-backup使用说明(翻译至README)：\"></a><strong>git-backup使用说明(翻译至README)：</strong></h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a><strong>安装</strong></h3><p>如果您的hexo版本是2.xx，则应安装如下：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ npm install hexo-git-backup@<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">91</span> --save</span><br></pre></td></tr></table></figure>\n\n<p>如果版本是3.xx，你应该安装如下：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a><strong>更新</strong></h3><p>(windows不需要$符)</p>\n<p>如果使用–save进行安装，则在更新时必须先删除。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ npm remove hexo-git-backup</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a><strong>配置</strong></h3><p>你应该配置这个文件_config.yml如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">backup:</span><br><span class=\"line\"></span><br><span class=\"line\">    type: git</span><br><span class=\"line\"></span><br><span class=\"line\">    repository:</span><br><span class=\"line\"></span><br><span class=\"line\">      github: git@github.com:xxx&#x2F;xxx.git,branchName</span><br><span class=\"line\"></span><br><span class=\"line\">      gitcafe: git@github.com:xxx&#x2F;xxx.git,branchName</span><br></pre></td></tr></table></figure>\n\n<p>比如博主就新建了个backup分支用于备份</p>\n<p>博主的配置如下</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">backup:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">type</span>: <span class=\"title\">git</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">message</span>: <span class=\"title\">backup</span> <span class=\"title\">my</span> <span class=\"title\">blog</span> <span class=\"title\">of</span> <span class=\"title\">https</span>://<span class=\"title\">honjun.github.io</span>/</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">repository</span>:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">github</span>: <span class=\"title\">https</span>://<span class=\"title\">github.com</span>/<span class=\"title\">honjun</span>/<span class=\"title\">honjun.github.io.git</span>,<span class=\"title\">backup</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h3><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">hexo backup</span><br></pre></td></tr></table></figure>\n\n<p>or</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">hexo b</span><br></pre></td></tr></table></figure>\n\n<p>Options</p>\n<p>如果你要备份你的主题，只需添加theme: your theme name,your theme name在_config.yml。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">backup:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">theme:</span> <span class=\"string\">coney,landscape,xxx</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">repository:</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">github:</span> <span class=\"string\">git@github.com:xxx/xxx.git,branchName</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">gitcafe:</span> <span class=\"string\">git@github.com:xxx/xxx.git,branchName</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：如果您按照上述方式操作，themes/coney/.git则会删除目录</strong></p>\n<p>如果你想DIY提交消息，只需添加“消息：更新xxx”。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">backup:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">message:</span> <span class=\"string\">update</span> <span class=\"string\">xxx</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">repository:</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">github:</span> <span class=\"string\">git@github.com:xxx/xxx.git,branchName</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">gitcafe:</span> <span class=\"string\">git@github.com:xxx/xxx.git,branchName</span></span><br></pre></td></tr></table></figure>\n\n<p>现在你可以备份所有的博客！</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a><strong>问题</strong></h3><p>您的计算机许可可能会造成一些麻烦。</p>\n<p><strong>错误：EISDIR，打开是由权限引起的。只要做’sudo hexo b’</strong></p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sudo hexo b</span><br></pre></td></tr></table></figure>\n\n<p>参考<a href=\"https://www.v2ex.com/t/143022\" target=\"_blank\" rel=\"noopener\">hexo 的备份插件</a></p>\n","site":{"data":{}},"excerpt":"<p>今天搜了下hexo博客备份，发现好多都是用git命令备份的，于是推荐款好用的hexo备份插件：</p>\n<p><a href=\"https://github.com/coneycode/hexo-git-backup\" target=\"_blank\" rel=\"noopener\">hexo-git-backup</a>","more":"</p>\n<h2 id=\"git-backup使用说明-翻译至README-：\"><a href=\"#git-backup使用说明-翻译至README-：\" class=\"headerlink\" title=\"git-backup使用说明(翻译至README)：\"></a><strong>git-backup使用说明(翻译至README)：</strong></h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a><strong>安装</strong></h3><p>如果您的hexo版本是2.xx，则应安装如下：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ npm install hexo-git-backup@<span class=\"number\">0</span>.<span class=\"number\">0</span>.<span class=\"number\">91</span> --save</span><br></pre></td></tr></table></figure>\n\n<p>如果版本是3.xx，你应该安装如下：</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a><strong>更新</strong></h3><p>(windows不需要$符)</p>\n<p>如果使用–save进行安装，则在更新时必须先删除。</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ npm remove hexo-git-backup</span><br><span class=\"line\"></span><br><span class=\"line\">$ npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a><strong>配置</strong></h3><p>你应该配置这个文件_config.yml如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">backup:</span><br><span class=\"line\"></span><br><span class=\"line\">    type: git</span><br><span class=\"line\"></span><br><span class=\"line\">    repository:</span><br><span class=\"line\"></span><br><span class=\"line\">      github: git@github.com:xxx&#x2F;xxx.git,branchName</span><br><span class=\"line\"></span><br><span class=\"line\">      gitcafe: git@github.com:xxx&#x2F;xxx.git,branchName</span><br></pre></td></tr></table></figure>\n\n<p>比如博主就新建了个backup分支用于备份</p>\n<p>博主的配置如下</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">backup:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">type</span>: <span class=\"title\">git</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">message</span>: <span class=\"title\">backup</span> <span class=\"title\">my</span> <span class=\"title\">blog</span> <span class=\"title\">of</span> <span class=\"title\">https</span>://<span class=\"title\">honjun.github.io</span>/</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">repository</span>:</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">github</span>: <span class=\"title\">https</span>://<span class=\"title\">github.com</span>/<span class=\"title\">honjun</span>/<span class=\"title\">honjun.github.io.git</span>,<span class=\"title\">backup</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a><strong>使用</strong></h3><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">hexo backup</span><br></pre></td></tr></table></figure>\n\n<p>or</p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">hexo b</span><br></pre></td></tr></table></figure>\n\n<p>Options</p>\n<p>如果你要备份你的主题，只需添加theme: your theme name,your theme name在_config.yml。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">backup:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">theme:</span> <span class=\"string\">coney,landscape,xxx</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">repository:</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">github:</span> <span class=\"string\">git@github.com:xxx/xxx.git,branchName</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">gitcafe:</span> <span class=\"string\">git@github.com:xxx/xxx.git,branchName</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：如果您按照上述方式操作，themes/coney/.git则会删除目录</strong></p>\n<p>如果你想DIY提交消息，只需添加“消息：更新xxx”。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">backup:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">message:</span> <span class=\"string\">update</span> <span class=\"string\">xxx</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">repository:</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">github:</span> <span class=\"string\">git@github.com:xxx/xxx.git,branchName</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"attr\">gitcafe:</span> <span class=\"string\">git@github.com:xxx/xxx.git,branchName</span></span><br></pre></td></tr></table></figure>\n\n<p>现在你可以备份所有的博客！</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a><strong>问题</strong></h3><p>您的计算机许可可能会造成一些麻烦。</p>\n<p><strong>错误：EISDIR，打开是由权限引起的。只要做’sudo hexo b’</strong></p>\n<figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sudo hexo b</span><br></pre></td></tr></table></figure>\n\n<p>参考<a href=\"https://www.v2ex.com/t/143022\" target=\"_blank\" rel=\"noopener\">hexo 的备份插件</a></p>"},{"title":"博客美化——Silence主题皮肤","top_img":"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile@master/top-img/3.jpg","abbrlink":"3ba53770","date":"2020-08-30T12:08:31.000Z","_content":"\n##  <!-- more --> 介绍\n&emsp;&emsp;一款专注阅读的博客园主题，主要面向于经常混迹 博客园 的朋友。其追求大道至简的终极真理，界面追求简洁、运行追求高效、部署追求简单。\n* [博客皮肤源码地址](https://github.com/glassy-sky-lisong/SilenceSkin)\n* [预览地址](https://www.cnblogs.com/esofar)\n* [如何部署、使用皮肤](https://github.com/esofar/cnblogs-theme-silence/blob/master/docs/deploy.md)\n* [Silence作者的友链](https://www.cnblogs.com/esofar/p/cnblogs-theme-silence.html)\n\n## 特点\n* 简洁优雅、精致漂亮的 UI 设计\n* 提供多种风格主题以便适应各类用户的偏好\n* 响应式设计，兼容手机端浏览器\n* 提供事无巨细的部署文档\n* 源码结构清晰并且注释完整，方便扩展\n\n## 开发\n&emsp;&emsp;请先确保您正在使用的机器已经安装 Node.js 和 Git 客户端。\n\n     git clone https://github.com/esofar/cnblogs-theme-silence.git   # 克隆源码\n     cd cnblogs-theme-silence                                        # 进入项目\n     npm install                                                     # 安装依赖\n     npm run build\n\n&emsp;&emsp;如果没有安装node。js或者不会使用的童鞋可以在我的GitHub，也就是博客皮肤源码地址中。\n\n## 部署\n&emsp;&emsp;重点部署之前使用博客园的cutorm皮肤，具体部署细节请详见'如何部署、使用皮肤'，如果又不会的话可以看一看我的配置作为参考（仅作为参考，找不回来别哭鼻子）\n***CSS***\n\n    <!-- 溢出隐藏设置（放置在管理--> 设置--> css模块中） -->\n    #topics, #mainContent {\n        overflow: visible;\n    }\n    .cnblogs-markdown .hljs{\n        display:block;\n        color:#333;\n        overflow-x:auto;\n        background:#F2F4F5!important;\n        border:none!important;\n        font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace!important;\n        padding:1em!important;\n        font-size:14px!important\n        }\n\n***侧边栏公告***\n\n    <!-- 在管理--> 设置-> 侧边栏公告(支持js代码、支持html代码) -->\n    <script src=\"https://blog-static.cnblogs.com/files/glassysky/silence.min.js\"></script>\n    <script type=\"text/javascript\">\n        $.silence({\n            profile: {\n                enable: true,\n                avatar: 'https://gitee.com/glassyskyforgame/glassysky/blob/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg',\n                favicon: 'https://gitee.com/glassyskyforgame/glassysky/raw/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg',\n            },\n            catalog: {\n                enable: true,\n                move: true,\n                index: true,\n                level1: 'h2',\n                level2: 'h3',\n                level3: 'h4',\n            },\n            signature: {\n                enable: true,\n                home: 'https://www.cnblogs.com/glassysky/',\n                license: '署名 4.0 国际',\n                link: 'https://creativecommons.org/licenses/by/4.0'\n            },\n            reward: {\n                enable: true,\n                title: '感谢小可爱投食',\n                wechat: 'https://images.cnblogs.com/cnblogs_com/esofar/972540/o_wechat.png',\n                alipay: 'https://images.cnblogs.com/cnblogs_com/esofar/972540/o_alipay.png'\n            },\n            github: {\n                enable: true,\n                color: '#fff',\n                fill: null,\n                link: 'https://github.com/glassy-sky-lisong'\n            }\n        });\n    </script>\n    <!--外置主题css补丁-->\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://blog-static.cnblogs.com/files/glassysky/sli.css\"/>\n\n***会动的title***\n\n    <!-- 动态titlejs -->\n    <script> var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if                 \n    (document.hidden) { document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); } else { document.title = '(ฅ>ω<*ฅ) 噫又    \n    好了~' + OriginTitle; titleTime = setTimeout(function () { document.title = OriginTitle; }, 2000); } }); </script>\n\n***图片放大功能***\n\n    <!--图片放大的zoomcss和js-->\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://blog-static.cnblogs.com/files/glassysky/zoom.css\"/>\n    <script src=\"https://blog-static.cnblogs.com/files/glassysky/zoom.js\"></script>\n    <!-- Bootstrap 的 transition.js cdn（过渡动画插件）-->\n    <script type=\"text/javascript\">$('#cnblogs_post_body img').attr('data-action', 'zoom');</script>\n\n## 博客的皮肤风格\n* 简约·蓝\n  ![img1](https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_default.png) \n* 暗黑·绿\n  ![img2](https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_dark.png)\n* 女神·粉\n  ![img3](https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_goddess.png)  \n","source":"_posts/Hexo/博客美化——Silence主题皮肤.md","raw":"---\ntitle: 博客美化——Silence主题皮肤\ntags:\n  - Hexo\ncategories:\n  - Hexo\ntop_img: 'https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile@master/top-img/3.jpg'\nabbrlink: 3ba53770\ndate: 2020-08-30 20:08:31\n---\n\n##  <!-- more --> 介绍\n&emsp;&emsp;一款专注阅读的博客园主题，主要面向于经常混迹 博客园 的朋友。其追求大道至简的终极真理，界面追求简洁、运行追求高效、部署追求简单。\n* [博客皮肤源码地址](https://github.com/glassy-sky-lisong/SilenceSkin)\n* [预览地址](https://www.cnblogs.com/esofar)\n* [如何部署、使用皮肤](https://github.com/esofar/cnblogs-theme-silence/blob/master/docs/deploy.md)\n* [Silence作者的友链](https://www.cnblogs.com/esofar/p/cnblogs-theme-silence.html)\n\n## 特点\n* 简洁优雅、精致漂亮的 UI 设计\n* 提供多种风格主题以便适应各类用户的偏好\n* 响应式设计，兼容手机端浏览器\n* 提供事无巨细的部署文档\n* 源码结构清晰并且注释完整，方便扩展\n\n## 开发\n&emsp;&emsp;请先确保您正在使用的机器已经安装 Node.js 和 Git 客户端。\n\n     git clone https://github.com/esofar/cnblogs-theme-silence.git   # 克隆源码\n     cd cnblogs-theme-silence                                        # 进入项目\n     npm install                                                     # 安装依赖\n     npm run build\n\n&emsp;&emsp;如果没有安装node。js或者不会使用的童鞋可以在我的GitHub，也就是博客皮肤源码地址中。\n\n## 部署\n&emsp;&emsp;重点部署之前使用博客园的cutorm皮肤，具体部署细节请详见'如何部署、使用皮肤'，如果又不会的话可以看一看我的配置作为参考（仅作为参考，找不回来别哭鼻子）\n***CSS***\n\n    <!-- 溢出隐藏设置（放置在管理--> 设置--> css模块中） -->\n    #topics, #mainContent {\n        overflow: visible;\n    }\n    .cnblogs-markdown .hljs{\n        display:block;\n        color:#333;\n        overflow-x:auto;\n        background:#F2F4F5!important;\n        border:none!important;\n        font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace!important;\n        padding:1em!important;\n        font-size:14px!important\n        }\n\n***侧边栏公告***\n\n    <!-- 在管理--> 设置-> 侧边栏公告(支持js代码、支持html代码) -->\n    <script src=\"https://blog-static.cnblogs.com/files/glassysky/silence.min.js\"></script>\n    <script type=\"text/javascript\">\n        $.silence({\n            profile: {\n                enable: true,\n                avatar: 'https://gitee.com/glassyskyforgame/glassysky/blob/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg',\n                favicon: 'https://gitee.com/glassyskyforgame/glassysky/raw/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg',\n            },\n            catalog: {\n                enable: true,\n                move: true,\n                index: true,\n                level1: 'h2',\n                level2: 'h3',\n                level3: 'h4',\n            },\n            signature: {\n                enable: true,\n                home: 'https://www.cnblogs.com/glassysky/',\n                license: '署名 4.0 国际',\n                link: 'https://creativecommons.org/licenses/by/4.0'\n            },\n            reward: {\n                enable: true,\n                title: '感谢小可爱投食',\n                wechat: 'https://images.cnblogs.com/cnblogs_com/esofar/972540/o_wechat.png',\n                alipay: 'https://images.cnblogs.com/cnblogs_com/esofar/972540/o_alipay.png'\n            },\n            github: {\n                enable: true,\n                color: '#fff',\n                fill: null,\n                link: 'https://github.com/glassy-sky-lisong'\n            }\n        });\n    </script>\n    <!--外置主题css补丁-->\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://blog-static.cnblogs.com/files/glassysky/sli.css\"/>\n\n***会动的title***\n\n    <!-- 动态titlejs -->\n    <script> var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if                 \n    (document.hidden) { document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); } else { document.title = '(ฅ>ω<*ฅ) 噫又    \n    好了~' + OriginTitle; titleTime = setTimeout(function () { document.title = OriginTitle; }, 2000); } }); </script>\n\n***图片放大功能***\n\n    <!--图片放大的zoomcss和js-->\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"https://blog-static.cnblogs.com/files/glassysky/zoom.css\"/>\n    <script src=\"https://blog-static.cnblogs.com/files/glassysky/zoom.js\"></script>\n    <!-- Bootstrap 的 transition.js cdn（过渡动画插件）-->\n    <script type=\"text/javascript\">$('#cnblogs_post_body img').attr('data-action', 'zoom');</script>\n\n## 博客的皮肤风格\n* 简约·蓝\n  ![img1](https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_default.png) \n* 暗黑·绿\n  ![img2](https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_dark.png)\n* 女神·粉\n  ![img3](https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_goddess.png)  \n","slug":"Hexo/博客美化——Silence主题皮肤","published":1,"updated":"2020-08-30T12:08:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wx001bn4epel0odarj","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\" 介绍\"></a><a id=\"more\"></a> 介绍</h2><p>&emsp;&emsp;一款专注阅读的博客园主题，主要面向于经常混迹 博客园 的朋友。其追求大道至简的终极真理，界面追求简洁、运行追求高效、部署追求简单。</p>\n<ul>\n<li><a href=\"https://github.com/glassy-sky-lisong/SilenceSkin\" target=\"_blank\" rel=\"noopener\">博客皮肤源码地址</a></li>\n<li><a href=\"https://www.cnblogs.com/esofar\" target=\"_blank\" rel=\"noopener\">预览地址</a></li>\n<li><a href=\"https://github.com/esofar/cnblogs-theme-silence/blob/master/docs/deploy.md\" target=\"_blank\" rel=\"noopener\">如何部署、使用皮肤</a></li>\n<li><a href=\"https://www.cnblogs.com/esofar/p/cnblogs-theme-silence.html\" target=\"_blank\" rel=\"noopener\">Silence作者的友链</a></li>\n</ul>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>简洁优雅、精致漂亮的 UI 设计</li>\n<li>提供多种风格主题以便适应各类用户的偏好</li>\n<li>响应式设计，兼容手机端浏览器</li>\n<li>提供事无巨细的部署文档</li>\n<li>源码结构清晰并且注释完整，方便扩展</li>\n</ul>\n<h2 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h2><p>&emsp;&emsp;请先确保您正在使用的机器已经安装 Node.js 和 Git 客户端。</p>\n<pre><code>git clone https://github.com/esofar/cnblogs-theme-silence.git   # 克隆源码\ncd cnblogs-theme-silence                                        # 进入项目\nnpm install                                                     # 安装依赖\nnpm run build</code></pre><p>&emsp;&emsp;如果没有安装node。js或者不会使用的童鞋可以在我的GitHub，也就是博客皮肤源码地址中。</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>&emsp;&emsp;重点部署之前使用博客园的cutorm皮肤，具体部署细节请详见’如何部署、使用皮肤’，如果又不会的话可以看一看我的配置作为参考（仅作为参考，找不回来别哭鼻子）<br><strong><em>CSS</em></strong></p>\n<pre><code>&lt;!-- 溢出隐藏设置（放置在管理--&gt; 设置--&gt; css模块中） --&gt;\n#topics, #mainContent {\n    overflow: visible;\n}\n.cnblogs-markdown .hljs{\n    display:block;\n    color:#333;\n    overflow-x:auto;\n    background:#F2F4F5!important;\n    border:none!important;\n    font-family:Consolas,Monaco,&apos;Andale Mono&apos;,&apos;Ubuntu Mono&apos;,monospace!important;\n    padding:1em!important;\n    font-size:14px!important\n    }</code></pre><p><strong><em>侧边栏公告</em></strong></p>\n<pre><code>&lt;!-- 在管理--&gt; 设置-&gt; 侧边栏公告(支持js代码、支持html代码) --&gt;\n&lt;script src=&quot;https://blog-static.cnblogs.com/files/glassysky/silence.min.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $.silence({\n        profile: {\n            enable: true,\n            avatar: &apos;https://gitee.com/glassyskyforgame/glassysky/blob/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg&apos;,\n            favicon: &apos;https://gitee.com/glassyskyforgame/glassysky/raw/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg&apos;,\n        },\n        catalog: {\n            enable: true,\n            move: true,\n            index: true,\n            level1: &apos;h2&apos;,\n            level2: &apos;h3&apos;,\n            level3: &apos;h4&apos;,\n        },\n        signature: {\n            enable: true,\n            home: &apos;https://www.cnblogs.com/glassysky/&apos;,\n            license: &apos;署名 4.0 国际&apos;,\n            link: &apos;https://creativecommons.org/licenses/by/4.0&apos;\n        },\n        reward: {\n            enable: true,\n            title: &apos;感谢小可爱投食&apos;,\n            wechat: &apos;https://images.cnblogs.com/cnblogs_com/esofar/972540/o_wechat.png&apos;,\n            alipay: &apos;https://images.cnblogs.com/cnblogs_com/esofar/972540/o_alipay.png&apos;\n        },\n        github: {\n            enable: true,\n            color: &apos;#fff&apos;,\n            fill: null,\n            link: &apos;https://github.com/glassy-sky-lisong&apos;\n        }\n    });\n&lt;/script&gt;\n&lt;!--外置主题css补丁--&gt;\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://blog-static.cnblogs.com/files/glassysky/sli.css&quot;/&gt;</code></pre><p><strong><em>会动的title</em></strong></p>\n<pre><code>&lt;!-- 动态titlejs --&gt;\n&lt;script&gt; var OriginTitle = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () { if                 \n(document.hidden) { document.title = &apos;╭(°A°`)╮ 页面崩溃啦 ~&apos;; clearTimeout(titleTime); } else { document.title = &apos;(ฅ&gt;ω&lt;*ฅ) 噫又    \n好了~&apos; + OriginTitle; titleTime = setTimeout(function () { document.title = OriginTitle; }, 2000); } }); &lt;/script&gt;</code></pre><p><strong><em>图片放大功能</em></strong></p>\n<pre><code>&lt;!--图片放大的zoomcss和js--&gt;\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://blog-static.cnblogs.com/files/glassysky/zoom.css&quot;/&gt;\n&lt;script src=&quot;https://blog-static.cnblogs.com/files/glassysky/zoom.js&quot;&gt;&lt;/script&gt;\n&lt;!-- Bootstrap 的 transition.js cdn（过渡动画插件）--&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;$(&apos;#cnblogs_post_body img&apos;).attr(&apos;data-action&apos;, &apos;zoom&apos;);&lt;/script&gt;</code></pre><h2 id=\"博客的皮肤风格\"><a href=\"#博客的皮肤风格\" class=\"headerlink\" title=\"博客的皮肤风格\"></a>博客的皮肤风格</h2><ul>\n<li>简约·蓝<br><img src=\"https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_default.png\" alt=\"img1\"> </li>\n<li>暗黑·绿<br><img src=\"https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_dark.png\" alt=\"img2\"></li>\n<li>女神·粉<br><img src=\"https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_goddess.png\" alt=\"img3\">  </li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\" 介绍\"></a>","more":"介绍</h2><p>&emsp;&emsp;一款专注阅读的博客园主题，主要面向于经常混迹 博客园 的朋友。其追求大道至简的终极真理，界面追求简洁、运行追求高效、部署追求简单。</p>\n<ul>\n<li><a href=\"https://github.com/glassy-sky-lisong/SilenceSkin\" target=\"_blank\" rel=\"noopener\">博客皮肤源码地址</a></li>\n<li><a href=\"https://www.cnblogs.com/esofar\" target=\"_blank\" rel=\"noopener\">预览地址</a></li>\n<li><a href=\"https://github.com/esofar/cnblogs-theme-silence/blob/master/docs/deploy.md\" target=\"_blank\" rel=\"noopener\">如何部署、使用皮肤</a></li>\n<li><a href=\"https://www.cnblogs.com/esofar/p/cnblogs-theme-silence.html\" target=\"_blank\" rel=\"noopener\">Silence作者的友链</a></li>\n</ul>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li>简洁优雅、精致漂亮的 UI 设计</li>\n<li>提供多种风格主题以便适应各类用户的偏好</li>\n<li>响应式设计，兼容手机端浏览器</li>\n<li>提供事无巨细的部署文档</li>\n<li>源码结构清晰并且注释完整，方便扩展</li>\n</ul>\n<h2 id=\"开发\"><a href=\"#开发\" class=\"headerlink\" title=\"开发\"></a>开发</h2><p>&emsp;&emsp;请先确保您正在使用的机器已经安装 Node.js 和 Git 客户端。</p>\n<pre><code>git clone https://github.com/esofar/cnblogs-theme-silence.git   # 克隆源码\ncd cnblogs-theme-silence                                        # 进入项目\nnpm install                                                     # 安装依赖\nnpm run build</code></pre><p>&emsp;&emsp;如果没有安装node。js或者不会使用的童鞋可以在我的GitHub，也就是博客皮肤源码地址中。</p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>&emsp;&emsp;重点部署之前使用博客园的cutorm皮肤，具体部署细节请详见’如何部署、使用皮肤’，如果又不会的话可以看一看我的配置作为参考（仅作为参考，找不回来别哭鼻子）<br><strong><em>CSS</em></strong></p>\n<pre><code>&lt;!-- 溢出隐藏设置（放置在管理--&gt; 设置--&gt; css模块中） --&gt;\n#topics, #mainContent {\n    overflow: visible;\n}\n.cnblogs-markdown .hljs{\n    display:block;\n    color:#333;\n    overflow-x:auto;\n    background:#F2F4F5!important;\n    border:none!important;\n    font-family:Consolas,Monaco,&apos;Andale Mono&apos;,&apos;Ubuntu Mono&apos;,monospace!important;\n    padding:1em!important;\n    font-size:14px!important\n    }</code></pre><p><strong><em>侧边栏公告</em></strong></p>\n<pre><code>&lt;!-- 在管理--&gt; 设置-&gt; 侧边栏公告(支持js代码、支持html代码) --&gt;\n&lt;script src=&quot;https://blog-static.cnblogs.com/files/glassysky/silence.min.js&quot;&gt;&lt;/script&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;\n    $.silence({\n        profile: {\n            enable: true,\n            avatar: &apos;https://gitee.com/glassyskyforgame/glassysky/blob/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg&apos;,\n            favicon: &apos;https://gitee.com/glassyskyforgame/glassysky/raw/master/4c67d1a20cf431ade2873e284836acaf2fdd989e.jpg&apos;,\n        },\n        catalog: {\n            enable: true,\n            move: true,\n            index: true,\n            level1: &apos;h2&apos;,\n            level2: &apos;h3&apos;,\n            level3: &apos;h4&apos;,\n        },\n        signature: {\n            enable: true,\n            home: &apos;https://www.cnblogs.com/glassysky/&apos;,\n            license: &apos;署名 4.0 国际&apos;,\n            link: &apos;https://creativecommons.org/licenses/by/4.0&apos;\n        },\n        reward: {\n            enable: true,\n            title: &apos;感谢小可爱投食&apos;,\n            wechat: &apos;https://images.cnblogs.com/cnblogs_com/esofar/972540/o_wechat.png&apos;,\n            alipay: &apos;https://images.cnblogs.com/cnblogs_com/esofar/972540/o_alipay.png&apos;\n        },\n        github: {\n            enable: true,\n            color: &apos;#fff&apos;,\n            fill: null,\n            link: &apos;https://github.com/glassy-sky-lisong&apos;\n        }\n    });\n&lt;/script&gt;\n&lt;!--外置主题css补丁--&gt;\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://blog-static.cnblogs.com/files/glassysky/sli.css&quot;/&gt;</code></pre><p><strong><em>会动的title</em></strong></p>\n<pre><code>&lt;!-- 动态titlejs --&gt;\n&lt;script&gt; var OriginTitle = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () { if                 \n(document.hidden) { document.title = &apos;╭(°A°`)╮ 页面崩溃啦 ~&apos;; clearTimeout(titleTime); } else { document.title = &apos;(ฅ&gt;ω&lt;*ฅ) 噫又    \n好了~&apos; + OriginTitle; titleTime = setTimeout(function () { document.title = OriginTitle; }, 2000); } }); &lt;/script&gt;</code></pre><p><strong><em>图片放大功能</em></strong></p>\n<pre><code>&lt;!--图片放大的zoomcss和js--&gt;\n&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://blog-static.cnblogs.com/files/glassysky/zoom.css&quot;/&gt;\n&lt;script src=&quot;https://blog-static.cnblogs.com/files/glassysky/zoom.js&quot;&gt;&lt;/script&gt;\n&lt;!-- Bootstrap 的 transition.js cdn（过渡动画插件）--&gt;\n&lt;script type=&quot;text/javascript&quot;&gt;$(&apos;#cnblogs_post_body img&apos;).attr(&apos;data-action&apos;, &apos;zoom&apos;);&lt;/script&gt;</code></pre><h2 id=\"博客的皮肤风格\"><a href=\"#博客的皮肤风格\" class=\"headerlink\" title=\"博客的皮肤风格\"></a>博客的皮肤风格</h2><ul>\n<li>简约·蓝<br><img src=\"https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_default.png\" alt=\"img1\"> </li>\n<li>暗黑·绿<br><img src=\"https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_dark.png\" alt=\"img2\"></li>\n<li>女神·粉<br><img src=\"https://github.com/esofar/cnblogs-theme-silence/raw/master/docs/theme_goddess.png\" alt=\"img3\">  </li>\n</ul>"},{"title":"超实用的SQL语句之嵌套查询","top_img":"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/top-img/1.jpg","cover":"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post-cover/2.png","abbrlink":"f3908263","date":"2020-08-31T11:40:33.000Z","_content":"\n<h2>嵌套查询</h2>\n<h3>什么是嵌套查询</h3>.\n 　　嵌套查询的意思是，一个查询语句(select-from-where)查询语句块可以嵌套在另外一个查询块的where子句中，称为嵌套查询。其中外层查询也称为父查询，主查询。内层查询也称子查询，从查询。 <!-- more --> \n<h3>嵌套查询的工作方式</h3>\n 　　先处理内查询，由内向外处理，外层查询利用内层查询的结果嵌套查询不仅仅可以用于父查询select语句使用。还可以用于insert、update、delete语句或其他子查询中。\n\n<h2>子查询的组成</h2>\n 1、包含标准选择列表组件的标准select查询。\n\n 2、包含一个或多个表或者视图名称的标准from子句。\n\n 3、可选的where子句。\n\n 4、可选的group by子句。\n\n 5、可选的having子句。\n<h2>子查询的语法规则</h2>\n 1、子查询的select查询总是使用圆括号括起来。\n\n 2、不能包括compute或for.browse子句。\n\n 3、如果同时指定top子句，则可能只包括order by子句。\n\n 4、子查询最多可以嵌套到32层。个别查询可能会不支持32层嵌套。\n\n 5、任何可以使用表达式的地方都可以使用子查询，只要它返回的是单个值。\n\n 6、如果某个表只出现在子查询中二不出现在外部查询中，那么该表的列就无法包含在输出中。\n<h2>简单子查询</h2>\n<strong>示例：</strong>\n\n\n    select name,age from person \n    where age > \n        (\n            select age from person \n            where name = '孙权'\n        )\n\n<strong>输出结果为：</strong>\n<img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/4.jpg\" alt=\"1\">\n<h2>in嵌套查询</h2>\n 　　in关键字用于where子句中用来判断查询的表达式是否在多个值的列表中。返回满足in列表中的满足条件的记录。\n\n<strong>示例：</strong>\n\n    select name from person \n    where countryid in \n    (\n    select countryid from country\n    where countryname = '魏国'\n    )\n\n<strong>输出结果为：</strong>\n\n<img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/3.jpg\" alt=\"2\">\n<h2>some嵌套查询</h2>\n<h3>语法</h3>\n 　　some在sql中的逻辑运算符号，如果在一系列比较中，有些值为True，那么结果就为True。some的语法是：\n\n    <表达式>{ =|<>|!=|>|>=|!>|<|<=|!<}some(子查询)\n\n<strong>示例：</strong>\n\n    select name from person \n    where countryid = some 　　　　　　--用等号和以下查询到的值比较，如果与其中一个相等，就返回\n    (\n    select countryid from country\n    where countryname = '魏国'\n    )\n\n<strong>输出结果为：</strong>\n<img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/2.jpg\" alt=\"3\">\n<h2>all嵌套查询</h2>\n 　　all是sql中的逻辑运算符好，如果一系列的比较都为true，那么结果才能为true。\n<h3>语法</h3>\n    <表达式>{ =|<>|!=|>|>=|!>|<|<=|!<}all(子查询)\n\n<strong>示例：</strong>\n\n    select name from person \n    where countryid > all　　 --当countryid大于以下返回的所有id，此结果才为True，此结果才返回\n    (\n    select countryid from country\n    where countryname = '魏国'\n    )\n\n<strong>输出结果为：</strong>\n<img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/1.jpg\" alt=\"4\">\n<h2>exists嵌套查询</h2>\n<h3>语法</h3>\n 　　exists是sql中的逻辑运算符号。如果子查询有结果集返回，那么就为True。exists代表“存在”的意义，它只查找满足条件的那些记录。<span style=\"color:red\">一旦找到第一个匹配的记录后，就马上停止查找。</span>\n\n    exists　子查询\n\n 　　其中子查询是一个首先的select语句，不允许有compute子句和into关键字。\nexists 的意思是，子查询是否有结果集返回。\n<strong>例如：</strong>\n\n    SELECT * FROM Person\n    WHERE exists\n    (\n    SELECT 1      --SELECT 0  SELECT NULL 返回结果都一样，因为这三个子查询都有结果集返回，因此总是True  SELECT * FROM Person照常执行\n    )\n\n 　　但是如果子查询中因为加了条件而没有结果集返回，则主语句就不执行了：\n\n    SELECT * FROM Person\n    WHERE exists\n    (\n    SELECT * FROM Person \n    WHERE Person_Id = 100    --如果不存在Person_Id的记录，则子查询没有结果集返回，主语句不执行\n    )\n\n最后感谢<a href=\"https://www.cnblogs.com/kissdodog/archive/2013/06/03/3116284.html\">不玩博客了！</a>同学的分享，么么哒！\n","source":"_posts/Mysql/超实用的SQL语句之嵌套查询.md","raw":"---\ntitle: 超实用的SQL语句之嵌套查询\ntags:\n  - MySQL\ncategories:\n  - MySQL\ntop_img: 'https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/top-img/1.jpg'\ncover: >-\n  https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post-cover/2.png\nabbrlink: f3908263\ndate: 2020-08-31 19:40:33\n---\n\n<h2>嵌套查询</h2>\n<h3>什么是嵌套查询</h3>.\n 　　嵌套查询的意思是，一个查询语句(select-from-where)查询语句块可以嵌套在另外一个查询块的where子句中，称为嵌套查询。其中外层查询也称为父查询，主查询。内层查询也称子查询，从查询。 <!-- more --> \n<h3>嵌套查询的工作方式</h3>\n 　　先处理内查询，由内向外处理，外层查询利用内层查询的结果嵌套查询不仅仅可以用于父查询select语句使用。还可以用于insert、update、delete语句或其他子查询中。\n\n<h2>子查询的组成</h2>\n 1、包含标准选择列表组件的标准select查询。\n\n 2、包含一个或多个表或者视图名称的标准from子句。\n\n 3、可选的where子句。\n\n 4、可选的group by子句。\n\n 5、可选的having子句。\n<h2>子查询的语法规则</h2>\n 1、子查询的select查询总是使用圆括号括起来。\n\n 2、不能包括compute或for.browse子句。\n\n 3、如果同时指定top子句，则可能只包括order by子句。\n\n 4、子查询最多可以嵌套到32层。个别查询可能会不支持32层嵌套。\n\n 5、任何可以使用表达式的地方都可以使用子查询，只要它返回的是单个值。\n\n 6、如果某个表只出现在子查询中二不出现在外部查询中，那么该表的列就无法包含在输出中。\n<h2>简单子查询</h2>\n<strong>示例：</strong>\n\n\n    select name,age from person \n    where age > \n        (\n            select age from person \n            where name = '孙权'\n        )\n\n<strong>输出结果为：</strong>\n<img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/4.jpg\" alt=\"1\">\n<h2>in嵌套查询</h2>\n 　　in关键字用于where子句中用来判断查询的表达式是否在多个值的列表中。返回满足in列表中的满足条件的记录。\n\n<strong>示例：</strong>\n\n    select name from person \n    where countryid in \n    (\n    select countryid from country\n    where countryname = '魏国'\n    )\n\n<strong>输出结果为：</strong>\n\n<img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/3.jpg\" alt=\"2\">\n<h2>some嵌套查询</h2>\n<h3>语法</h3>\n 　　some在sql中的逻辑运算符号，如果在一系列比较中，有些值为True，那么结果就为True。some的语法是：\n\n    <表达式>{ =|<>|!=|>|>=|!>|<|<=|!<}some(子查询)\n\n<strong>示例：</strong>\n\n    select name from person \n    where countryid = some 　　　　　　--用等号和以下查询到的值比较，如果与其中一个相等，就返回\n    (\n    select countryid from country\n    where countryname = '魏国'\n    )\n\n<strong>输出结果为：</strong>\n<img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/2.jpg\" alt=\"3\">\n<h2>all嵌套查询</h2>\n 　　all是sql中的逻辑运算符好，如果一系列的比较都为true，那么结果才能为true。\n<h3>语法</h3>\n    <表达式>{ =|<>|!=|>|>=|!>|<|<=|!<}all(子查询)\n\n<strong>示例：</strong>\n\n    select name from person \n    where countryid > all　　 --当countryid大于以下返回的所有id，此结果才为True，此结果才返回\n    (\n    select countryid from country\n    where countryname = '魏国'\n    )\n\n<strong>输出结果为：</strong>\n<img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/1.jpg\" alt=\"4\">\n<h2>exists嵌套查询</h2>\n<h3>语法</h3>\n 　　exists是sql中的逻辑运算符号。如果子查询有结果集返回，那么就为True。exists代表“存在”的意义，它只查找满足条件的那些记录。<span style=\"color:red\">一旦找到第一个匹配的记录后，就马上停止查找。</span>\n\n    exists　子查询\n\n 　　其中子查询是一个首先的select语句，不允许有compute子句和into关键字。\nexists 的意思是，子查询是否有结果集返回。\n<strong>例如：</strong>\n\n    SELECT * FROM Person\n    WHERE exists\n    (\n    SELECT 1      --SELECT 0  SELECT NULL 返回结果都一样，因为这三个子查询都有结果集返回，因此总是True  SELECT * FROM Person照常执行\n    )\n\n 　　但是如果子查询中因为加了条件而没有结果集返回，则主语句就不执行了：\n\n    SELECT * FROM Person\n    WHERE exists\n    (\n    SELECT * FROM Person \n    WHERE Person_Id = 100    --如果不存在Person_Id的记录，则子查询没有结果集返回，主语句不执行\n    )\n\n最后感谢<a href=\"https://www.cnblogs.com/kissdodog/archive/2013/06/03/3116284.html\">不玩博客了！</a>同学的分享，么么哒！\n","slug":"Mysql/超实用的SQL语句之嵌套查询","published":1,"updated":"2020-08-31T11:40:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3wy001cn4epgaibeshz","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2>嵌套查询</h2>\n<h3>什么是嵌套查询</h3>.\n 　　嵌套查询的意思是，一个查询语句(select-from-where)查询语句块可以嵌套在另外一个查询块的where子句中，称为嵌套查询。其中外层查询也称为父查询，主查询。内层查询也称子查询，从查询。 <a id=\"more\"></a> \n<h3>嵌套查询的工作方式</h3>\n 　　先处理内查询，由内向外处理，外层查询利用内层查询的结果嵌套查询不仅仅可以用于父查询select语句使用。还可以用于insert、update、delete语句或其他子查询中。\n\n<h2>子查询的组成</h2>\n 1、包含标准选择列表组件的标准select查询。\n\n<p> 2、包含一个或多个表或者视图名称的标准from子句。</p>\n<p> 3、可选的where子句。</p>\n<p> 4、可选的group by子句。</p>\n<p> 5、可选的having子句。</p>\n<h2>子查询的语法规则</h2>\n 1、子查询的select查询总是使用圆括号括起来。\n\n<p> 2、不能包括compute或for.browse子句。</p>\n<p> 3、如果同时指定top子句，则可能只包括order by子句。</p>\n<p> 4、子查询最多可以嵌套到32层。个别查询可能会不支持32层嵌套。</p>\n<p> 5、任何可以使用表达式的地方都可以使用子查询，只要它返回的是单个值。</p>\n<p> 6、如果某个表只出现在子查询中二不出现在外部查询中，那么该表的列就无法包含在输出中。</p>\n<h2>简单子查询</h2>\n<strong>示例：</strong>\n\n\n<pre><code>select name,age from person \nwhere age &gt; \n    (\n        select age from person \n        where name = &apos;孙权&apos;\n    )</code></pre><p><strong>输出结果为：</strong><br><img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/4.jpg\" alt=\"1\"></p>\n<h2>in嵌套查询</h2>\n 　　in关键字用于where子句中用来判断查询的表达式是否在多个值的列表中。返回满足in列表中的满足条件的记录。\n\n<p><strong>示例：</strong></p>\n<pre><code>select name from person \nwhere countryid in \n(\nselect countryid from country\nwhere countryname = &apos;魏国&apos;\n)</code></pre><p><strong>输出结果为：</strong></p>\n<img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/3.jpg\" alt=\"2\">\n<h2>some嵌套查询</h2>\n<h3>语法</h3>\n 　　some在sql中的逻辑运算符号，如果在一系列比较中，有些值为True，那么结果就为True。some的语法是：\n\n<pre><code>&lt;表达式&gt;{ =|&lt;&gt;|!=|&gt;|&gt;=|!&gt;|&lt;|&lt;=|!&lt;}some(子查询)</code></pre><p><strong>示例：</strong></p>\n<pre><code>select name from person \nwhere countryid = some 　　　　　　--用等号和以下查询到的值比较，如果与其中一个相等，就返回\n(\nselect countryid from country\nwhere countryname = &apos;魏国&apos;\n)</code></pre><p><strong>输出结果为：</strong><br><img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/2.jpg\" alt=\"3\"></p>\n<h2>all嵌套查询</h2>\n 　　all是sql中的逻辑运算符好，如果一系列的比较都为true，那么结果才能为true。\n<h3>语法</h3>\n    <表达式>{ =|<>|!=|>|>=|!>|<|<=|!<}all(子查询)\n\n<p><strong>示例：</strong></p>\n<pre><code>select name from person \nwhere countryid &gt; all　　 --当countryid大于以下返回的所有id，此结果才为True，此结果才返回\n(\nselect countryid from country\nwhere countryname = &apos;魏国&apos;\n)</code></pre><p><strong>输出结果为：</strong><br><img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/1.jpg\" alt=\"4\"></p>\n<h2>exists嵌套查询</h2>\n<h3>语法</h3>\n 　　exists是sql中的逻辑运算符号。如果子查询有结果集返回，那么就为True。exists代表“存在”的意义，它只查找满足条件的那些记录。<span style=\"color:red\">一旦找到第一个匹配的记录后，就马上停止查找。</span>\n\n<pre><code>exists　子查询</code></pre><p> 　　其中子查询是一个首先的select语句，不允许有compute子句和into关键字。<br>exists 的意思是，子查询是否有结果集返回。<br><strong>例如：</strong></p>\n<pre><code>SELECT * FROM Person\nWHERE exists\n(\nSELECT 1      --SELECT 0  SELECT NULL 返回结果都一样，因为这三个子查询都有结果集返回，因此总是True  SELECT * FROM Person照常执行\n)</code></pre><p> 　　但是如果子查询中因为加了条件而没有结果集返回，则主语句就不执行了：</p>\n<pre><code>SELECT * FROM Person\nWHERE exists\n(\nSELECT * FROM Person \nWHERE Person_Id = 100    --如果不存在Person_Id的记录，则子查询没有结果集返回，主语句不执行\n)</code></pre><p>最后感谢<a href=\"https://www.cnblogs.com/kissdodog/archive/2013/06/03/3116284.html\" target=\"_blank\" rel=\"noopener\">不玩博客了！</a>同学的分享，么么哒！</p>\n","site":{"data":{}},"excerpt":"<h2>嵌套查询</h2>\n<h3>什么是嵌套查询</h3>.\n 　　嵌套查询的意思是，一个查询语句(select-from-where)查询语句块可以嵌套在另外一个查询块的where子句中，称为嵌套查询。其中外层查询也称为父查询，主查询。内层查询也称子查询，从查询。","more":"<h3>嵌套查询的工作方式</h3>\n 　　先处理内查询，由内向外处理，外层查询利用内层查询的结果嵌套查询不仅仅可以用于父查询select语句使用。还可以用于insert、update、delete语句或其他子查询中。\n\n<h2>子查询的组成</h2>\n 1、包含标准选择列表组件的标准select查询。\n\n<p> 2、包含一个或多个表或者视图名称的标准from子句。</p>\n<p> 3、可选的where子句。</p>\n<p> 4、可选的group by子句。</p>\n<p> 5、可选的having子句。</p>\n<h2>子查询的语法规则</h2>\n 1、子查询的select查询总是使用圆括号括起来。\n\n<p> 2、不能包括compute或for.browse子句。</p>\n<p> 3、如果同时指定top子句，则可能只包括order by子句。</p>\n<p> 4、子查询最多可以嵌套到32层。个别查询可能会不支持32层嵌套。</p>\n<p> 5、任何可以使用表达式的地方都可以使用子查询，只要它返回的是单个值。</p>\n<p> 6、如果某个表只出现在子查询中二不出现在外部查询中，那么该表的列就无法包含在输出中。</p>\n<h2>简单子查询</h2>\n<strong>示例：</strong>\n\n\n<pre><code>select name,age from person \nwhere age &gt; \n    (\n        select age from person \n        where name = &apos;孙权&apos;\n    )</code></pre><p><strong>输出结果为：</strong><br><img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/4.jpg\" alt=\"1\"></p>\n<h2>in嵌套查询</h2>\n 　　in关键字用于where子句中用来判断查询的表达式是否在多个值的列表中。返回满足in列表中的满足条件的记录。\n\n<p><strong>示例：</strong></p>\n<pre><code>select name from person \nwhere countryid in \n(\nselect countryid from country\nwhere countryname = &apos;魏国&apos;\n)</code></pre><p><strong>输出结果为：</strong></p>\n<img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/3.jpg\" alt=\"2\">\n<h2>some嵌套查询</h2>\n<h3>语法</h3>\n 　　some在sql中的逻辑运算符号，如果在一系列比较中，有些值为True，那么结果就为True。some的语法是：\n\n<pre><code>&lt;表达式&gt;{ =|&lt;&gt;|!=|&gt;|&gt;=|!&gt;|&lt;|&lt;=|!&lt;}some(子查询)</code></pre><p><strong>示例：</strong></p>\n<pre><code>select name from person \nwhere countryid = some 　　　　　　--用等号和以下查询到的值比较，如果与其中一个相等，就返回\n(\nselect countryid from country\nwhere countryname = &apos;魏国&apos;\n)</code></pre><p><strong>输出结果为：</strong><br><img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/2.jpg\" alt=\"3\"></p>\n<h2>all嵌套查询</h2>\n 　　all是sql中的逻辑运算符好，如果一系列的比较都为true，那么结果才能为true。\n<h3>语法</h3>\n    <表达式>{ =|<>|!=|>|>=|!>|<|<=|!<}all(子查询)\n\n<p><strong>示例：</strong></p>\n<pre><code>select name from person \nwhere countryid &gt; all　　 --当countryid大于以下返回的所有id，此结果才为True，此结果才返回\n(\nselect countryid from country\nwhere countryname = &apos;魏国&apos;\n)</code></pre><p><strong>输出结果为：</strong><br><img src=\"https://cdn.jsdelivr.net/gh/glassy-sky-lisong/StaticFile1@master/post/1.jpg\" alt=\"4\"></p>\n<h2>exists嵌套查询</h2>\n<h3>语法</h3>\n 　　exists是sql中的逻辑运算符号。如果子查询有结果集返回，那么就为True。exists代表“存在”的意义，它只查找满足条件的那些记录。<span style=\"color:red\">一旦找到第一个匹配的记录后，就马上停止查找。</span>\n\n<pre><code>exists　子查询</code></pre><p> 　　其中子查询是一个首先的select语句，不允许有compute子句和into关键字。<br>exists 的意思是，子查询是否有结果集返回。<br><strong>例如：</strong></p>\n<pre><code>SELECT * FROM Person\nWHERE exists\n(\nSELECT 1      --SELECT 0  SELECT NULL 返回结果都一样，因为这三个子查询都有结果集返回，因此总是True  SELECT * FROM Person照常执行\n)</code></pre><p> 　　但是如果子查询中因为加了条件而没有结果集返回，则主语句就不执行了：</p>\n<pre><code>SELECT * FROM Person\nWHERE exists\n(\nSELECT * FROM Person \nWHERE Person_Id = 100    --如果不存在Person_Id的记录，则子查询没有结果集返回，主语句不执行\n)</code></pre><p>最后感谢<a href=\"https://www.cnblogs.com/kissdodog/archive/2013/06/03/3116284.html\" target=\"_blank\" rel=\"noopener\">不玩博客了！</a>同学的分享，么么哒！</p>"},{"title":"jdk安装和配置环境变量","abbrlink":"54eecc7d","date":"2021-05-26T12:51:29.000Z","_content":"\n> 学习JAVA，必须得安装一下JDK(java development kit java开发工具包)，配置一下环境就可以学习JAVA了，下面是下载和安装JDK的教程： <!-- more --> \n\n## 1.JDK下载地址：\n\nhttp://www.oracle.com/technetwork/java/javase/downloads/index.html\n\n点开链接你应该看到如下图所示的界面：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIxODE2ODgy?x-oss-process=image/format,png) \n\n## 2.点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示：\n\n### 3.双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：\n\n#### （1）双击进行安装界面如下所示：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIyMDI3NzMy?x-oss-process=image/format,png) \n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMTM2NDcy?x-oss-process=image/format,png)\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMTQ5MzQ3?x-oss-process=image/format,png)\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjAwMDgy?x-oss-process=image/format,png)\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjEyMjM3?x-oss-process=image/format,png) \n\n  ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjIyNTY1?x-oss-process=image/format,png)\n\n## 4.安装完成后，需要进行环境变量的配置，右键我的电脑—属性----高级系统设置就会看到下面的界面：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIyODUzMTEy?x-oss-process=image/format,png) \n\n## 5.点击上图中的环境变量，然后开始环境变量的配置：\n\n##### （1）点击系统变量下面的新建按钮，变量名JAVA_HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。\n\n  ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzMDE5ODAw?x-oss-process=image/format,png) \n\n##### （2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzMjAxMjM4?x-oss-process=image/format,png) \n\n此处需要注意：最前面有一个英文状态下的小圆点。。。。很多初学者在配置环境变量的时候就会跌倒在这个坑里。\n\n##### （3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码：\n\n> %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n\n此时你应该在你原有的值域后面追加，记得在原有的值域后面记得添加一个英文状态下的分号。\n最后点击确定，此时JDK的环境变量配置就完成了。\n\n## 6.测试自己所配置的环境变量是否正确\n\n（1）WINDOWS+R键，输入cmd，进入命令行界面，如下所示：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzNzM1MTAw?x-oss-process=image/format,png) \n\n（2）输入java -version命令，可以出现如下图的提示，你可以看你安装的JDK版本。\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzOTAxNTA3?x-oss-process=image/format,png) \n\n（3）输入javac命令可以出现如下的提示：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0MDA1ODgy?x-oss-process=image/format,png) \n\n（4）输入java命令就会出现如下图所示的结果\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0MTMwMjI2?x-oss-process=image/format,png) \n\n## 7.写一段代码可以验证一下\n\n##### （1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava.java，此时需要注意，你的文件名字后缀一定是.java\n\n##### （2）你需要在你的文件里面写下面的代码：\n```\npublic class TestJava{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"I am a  java new learner!\");\n\t}\n}\n```\n##### （3）继续windows+r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0OTQxNzc4?x-oss-process=image/format,png) \n\n此处一定要注意：必须进入文件所在的目录；其次使用javac命令 文件的名字的后面一定要跟着.java的文件后缀；使用java命令时.java后缀可以不用写。\n当你执行完javac命令如果没有错误提示，说明通过了编译，就会在你的文件目录下生成一个同名的.class文件。\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI1MjAxNjI5?x-oss-process=image/format,png) \n\n如果你完成了以上的所有，并且结果显示正确，那么说明你的JDK安装和环境配置都很成功，此时你就可以开始你的JAVA学习了。\nJDK1.8 API链接：\nhttp://docs.oracle.com/javase/8/docs/api/\nJAVA tutorials:\nhttp://docs.oracle.com/javase/tutorial/","source":"_posts/Java/jdk安装和配置环境变量.md","raw":"---\ntitle: jdk安装和配置环境变量\nabbrlink: 54eecc7d\ndate: 2021-05-26 20:51:29\ntags:\n---\n\n> 学习JAVA，必须得安装一下JDK(java development kit java开发工具包)，配置一下环境就可以学习JAVA了，下面是下载和安装JDK的教程： <!-- more --> \n\n## 1.JDK下载地址：\n\nhttp://www.oracle.com/technetwork/java/javase/downloads/index.html\n\n点开链接你应该看到如下图所示的界面：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIxODE2ODgy?x-oss-process=image/format,png) \n\n## 2.点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示：\n\n### 3.双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：\n\n#### （1）双击进行安装界面如下所示：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIyMDI3NzMy?x-oss-process=image/format,png) \n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMTM2NDcy?x-oss-process=image/format,png)\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMTQ5MzQ3?x-oss-process=image/format,png)\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjAwMDgy?x-oss-process=image/format,png)\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjEyMjM3?x-oss-process=image/format,png) \n\n  ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjIyNTY1?x-oss-process=image/format,png)\n\n## 4.安装完成后，需要进行环境变量的配置，右键我的电脑—属性----高级系统设置就会看到下面的界面：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIyODUzMTEy?x-oss-process=image/format,png) \n\n## 5.点击上图中的环境变量，然后开始环境变量的配置：\n\n##### （1）点击系统变量下面的新建按钮，变量名JAVA_HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。\n\n  ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzMDE5ODAw?x-oss-process=image/format,png) \n\n##### （2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzMjAxMjM4?x-oss-process=image/format,png) \n\n此处需要注意：最前面有一个英文状态下的小圆点。。。。很多初学者在配置环境变量的时候就会跌倒在这个坑里。\n\n##### （3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码：\n\n> %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;\n\n此时你应该在你原有的值域后面追加，记得在原有的值域后面记得添加一个英文状态下的分号。\n最后点击确定，此时JDK的环境变量配置就完成了。\n\n## 6.测试自己所配置的环境变量是否正确\n\n（1）WINDOWS+R键，输入cmd，进入命令行界面，如下所示：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzNzM1MTAw?x-oss-process=image/format,png) \n\n（2）输入java -version命令，可以出现如下图的提示，你可以看你安装的JDK版本。\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzOTAxNTA3?x-oss-process=image/format,png) \n\n（3）输入javac命令可以出现如下的提示：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0MDA1ODgy?x-oss-process=image/format,png) \n\n（4）输入java命令就会出现如下图所示的结果\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0MTMwMjI2?x-oss-process=image/format,png) \n\n## 7.写一段代码可以验证一下\n\n##### （1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava.java，此时需要注意，你的文件名字后缀一定是.java\n\n##### （2）你需要在你的文件里面写下面的代码：\n```\npublic class TestJava{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"I am a  java new learner!\");\n\t}\n}\n```\n##### （3）继续windows+r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样：\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0OTQxNzc4?x-oss-process=image/format,png) \n\n此处一定要注意：必须进入文件所在的目录；其次使用javac命令 文件的名字的后面一定要跟着.java的文件后缀；使用java命令时.java后缀可以不用写。\n当你执行完javac命令如果没有错误提示，说明通过了编译，就会在你的文件目录下生成一个同名的.class文件。\n\n ![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI1MjAxNjI5?x-oss-process=image/format,png) \n\n如果你完成了以上的所有，并且结果显示正确，那么说明你的JDK安装和环境配置都很成功，此时你就可以开始你的JAVA学习了。\nJDK1.8 API链接：\nhttp://docs.oracle.com/javase/8/docs/api/\nJAVA tutorials:\nhttp://docs.oracle.com/javase/tutorial/","slug":"Java/jdk安装和配置环境变量","published":1,"updated":"2021-05-26T12:51:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3x1001gn4epaykihn9a","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>学习JAVA，必须得安装一下JDK(java development kit java开发工具包)，配置一下环境就可以学习JAVA了，下面是下载和安装JDK的教程： <a id=\"more\"></a> </p>\n</blockquote>\n<h2 id=\"1-JDK下载地址：\"><a href=\"#1-JDK下载地址：\" class=\"headerlink\" title=\"1.JDK下载地址：\"></a>1.JDK下载地址：</h2><p><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>\n<p>点开链接你应该看到如下图所示的界面：</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIxODE2ODgy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<h2 id=\"2-点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示：\"><a href=\"#2-点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示：\" class=\"headerlink\" title=\"2.点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示：\"></a>2.点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示：</h2><h3 id=\"3-双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：\"><a href=\"#3-双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：\" class=\"headerlink\" title=\"3.双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：\"></a>3.双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：</h3><h4 id=\"（1）双击进行安装界面如下所示：\"><a href=\"#（1）双击进行安装界面如下所示：\" class=\"headerlink\" title=\"（1）双击进行安装界面如下所示：\"></a>（1）双击进行安装界面如下所示：</h4><p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIyMDI3NzMy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMTM2NDcy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMTQ5MzQ3?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjAwMDgy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjEyMjM3?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>  <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjIyNTY1?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<h2 id=\"4-安装完成后，需要进行环境变量的配置，右键我的电脑—属性—-高级系统设置就会看到下面的界面：\"><a href=\"#4-安装完成后，需要进行环境变量的配置，右键我的电脑—属性—-高级系统设置就会看到下面的界面：\" class=\"headerlink\" title=\"4.安装完成后，需要进行环境变量的配置，右键我的电脑—属性—-高级系统设置就会看到下面的界面：\"></a>4.安装完成后，需要进行环境变量的配置，右键我的电脑—属性—-高级系统设置就会看到下面的界面：</h2><p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIyODUzMTEy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<h2 id=\"5-点击上图中的环境变量，然后开始环境变量的配置：\"><a href=\"#5-点击上图中的环境变量，然后开始环境变量的配置：\" class=\"headerlink\" title=\"5.点击上图中的环境变量，然后开始环境变量的配置：\"></a>5.点击上图中的环境变量，然后开始环境变量的配置：</h2><h5 id=\"（1）点击系统变量下面的新建按钮，变量名JAVA-HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。\"><a href=\"#（1）点击系统变量下面的新建按钮，变量名JAVA-HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。\" class=\"headerlink\" title=\"（1）点击系统变量下面的新建按钮，变量名JAVA_HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。\"></a>（1）点击系统变量下面的新建按钮，变量名JAVA_HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。</h5><p>  <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzMDE5ODAw?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<h5 id=\"（2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示：\"><a href=\"#（2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示：\" class=\"headerlink\" title=\"（2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示：\"></a>（2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示：</h5><p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzMjAxMjM4?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>此处需要注意：最前面有一个英文状态下的小圆点。。。。很多初学者在配置环境变量的时候就会跌倒在这个坑里。</p>\n<h5 id=\"（3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码：\"><a href=\"#（3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码：\" class=\"headerlink\" title=\"（3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码：\"></a>（3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码：</h5><blockquote>\n<p>%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;</p>\n</blockquote>\n<p>此时你应该在你原有的值域后面追加，记得在原有的值域后面记得添加一个英文状态下的分号。<br>最后点击确定，此时JDK的环境变量配置就完成了。</p>\n<h2 id=\"6-测试自己所配置的环境变量是否正确\"><a href=\"#6-测试自己所配置的环境变量是否正确\" class=\"headerlink\" title=\"6.测试自己所配置的环境变量是否正确\"></a>6.测试自己所配置的环境变量是否正确</h2><p>（1）WINDOWS+R键，输入cmd，进入命令行界面，如下所示：</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzNzM1MTAw?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>（2）输入java -version命令，可以出现如下图的提示，你可以看你安装的JDK版本。</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzOTAxNTA3?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>（3）输入javac命令可以出现如下的提示：</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0MDA1ODgy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>（4）输入java命令就会出现如下图所示的结果</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0MTMwMjI2?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<h2 id=\"7-写一段代码可以验证一下\"><a href=\"#7-写一段代码可以验证一下\" class=\"headerlink\" title=\"7.写一段代码可以验证一下\"></a>7.写一段代码可以验证一下</h2><h5 id=\"（1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava-java，此时需要注意，你的文件名字后缀一定是-java\"><a href=\"#（1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava-java，此时需要注意，你的文件名字后缀一定是-java\" class=\"headerlink\" title=\"（1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava.java，此时需要注意，你的文件名字后缀一定是.java\"></a>（1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava.java，此时需要注意，你的文件名字后缀一定是.java</h5><h5 id=\"（2）你需要在你的文件里面写下面的代码：\"><a href=\"#（2）你需要在你的文件里面写下面的代码：\" class=\"headerlink\" title=\"（2）你需要在你的文件里面写下面的代码：\"></a>（2）你需要在你的文件里面写下面的代码：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestJava&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;I am a  java new learner!&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"（3）继续windows-r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样：\"><a href=\"#（3）继续windows-r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样：\" class=\"headerlink\" title=\"（3）继续windows+r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样：\"></a>（3）继续windows+r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样：</h5><p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0OTQxNzc4?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>此处一定要注意：必须进入文件所在的目录；其次使用javac命令 文件的名字的后面一定要跟着.java的文件后缀；使用java命令时.java后缀可以不用写。<br>当你执行完javac命令如果没有错误提示，说明通过了编译，就会在你的文件目录下生成一个同名的.class文件。</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI1MjAxNjI5?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>如果你完成了以上的所有，并且结果显示正确，那么说明你的JDK安装和环境配置都很成功，此时你就可以开始你的JAVA学习了。<br>JDK1.8 API链接：<br><a href=\"http://docs.oracle.com/javase/8/docs/api/\" target=\"_blank\" rel=\"noopener\">http://docs.oracle.com/javase/8/docs/api/</a><br>JAVA tutorials:<br><a href=\"http://docs.oracle.com/javase/tutorial/\" target=\"_blank\" rel=\"noopener\">http://docs.oracle.com/javase/tutorial/</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>学习JAVA，必须得安装一下JDK(java development kit java开发工具包)，配置一下环境就可以学习JAVA了，下面是下载和安装JDK的教程：","more":"</p>\n</blockquote>\n<h2 id=\"1-JDK下载地址：\"><a href=\"#1-JDK下载地址：\" class=\"headerlink\" title=\"1.JDK下载地址：\"></a>1.JDK下载地址：</h2><p><a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p>\n<p>点开链接你应该看到如下图所示的界面：</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIxODE2ODgy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<h2 id=\"2-点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示：\"><a href=\"#2-点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示：\" class=\"headerlink\" title=\"2.点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示：\"></a>2.点击上图中箭头所指的地方，会出现下面的这个界面，此时你需要根据你的电脑系统来进行对应的版本进行选择，在选择版本和下载之前你需要首先接收协议，具体界面如下图所示：</h2><h3 id=\"3-双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：\"><a href=\"#3-双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：\" class=\"headerlink\" title=\"3.双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：\"></a>3.双击以后进行JDK的安装（记得按照第二幅图修改一下安装路径，不要什么东西都安装到系统盘。。。）：</h3><h4 id=\"（1）双击进行安装界面如下所示：\"><a href=\"#（1）双击进行安装界面如下所示：\" class=\"headerlink\" title=\"（1）双击进行安装界面如下所示：\"></a>（1）双击进行安装界面如下所示：</h4><p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIyMDI3NzMy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMTM2NDcy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMTQ5MzQ3?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjAwMDgy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjEyMjM3?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>  <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjMwMjIyNTY1?x-oss-process=image/format,png\" alt=\"这里写图片描述\"></p>\n<h2 id=\"4-安装完成后，需要进行环境变量的配置，右键我的电脑—属性—-高级系统设置就会看到下面的界面：\"><a href=\"#4-安装完成后，需要进行环境变量的配置，右键我的电脑—属性—-高级系统设置就会看到下面的界面：\" class=\"headerlink\" title=\"4.安装完成后，需要进行环境变量的配置，右键我的电脑—属性—-高级系统设置就会看到下面的界面：\"></a>4.安装完成后，需要进行环境变量的配置，右键我的电脑—属性—-高级系统设置就会看到下面的界面：</h2><p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIyODUzMTEy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<h2 id=\"5-点击上图中的环境变量，然后开始环境变量的配置：\"><a href=\"#5-点击上图中的环境变量，然后开始环境变量的配置：\" class=\"headerlink\" title=\"5.点击上图中的环境变量，然后开始环境变量的配置：\"></a>5.点击上图中的环境变量，然后开始环境变量的配置：</h2><h5 id=\"（1）点击系统变量下面的新建按钮，变量名JAVA-HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。\"><a href=\"#（1）点击系统变量下面的新建按钮，变量名JAVA-HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。\" class=\"headerlink\" title=\"（1）点击系统变量下面的新建按钮，变量名JAVA_HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。\"></a>（1）点击系统变量下面的新建按钮，变量名JAVA_HOME（代表你的JDK安装路径），值对应的是你的JDK的安装路径。</h5><p>  <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzMDE5ODAw?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<h5 id=\"（2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示：\"><a href=\"#（2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示：\" class=\"headerlink\" title=\"（2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示：\"></a>（2）继续在系统变量里面新建一个CLASSPATH变量，其变量值如下图所示：</h5><p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzMjAxMjM4?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>此处需要注意：最前面有一个英文状态下的小圆点。。。。很多初学者在配置环境变量的时候就会跌倒在这个坑里。</p>\n<h5 id=\"（3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码：\"><a href=\"#（3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码：\" class=\"headerlink\" title=\"（3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码：\"></a>（3）在你的系统变量里面找一个变量名是PATH的变量，需要在它的值域里面追加一段如下的代码：</h5><blockquote>\n<p>%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;</p>\n</blockquote>\n<p>此时你应该在你原有的值域后面追加，记得在原有的值域后面记得添加一个英文状态下的分号。<br>最后点击确定，此时JDK的环境变量配置就完成了。</p>\n<h2 id=\"6-测试自己所配置的环境变量是否正确\"><a href=\"#6-测试自己所配置的环境变量是否正确\" class=\"headerlink\" title=\"6.测试自己所配置的环境变量是否正确\"></a>6.测试自己所配置的环境变量是否正确</h2><p>（1）WINDOWS+R键，输入cmd，进入命令行界面，如下所示：</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzNzM1MTAw?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>（2）输入java -version命令，可以出现如下图的提示，你可以看你安装的JDK版本。</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjIzOTAxNTA3?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>（3）输入javac命令可以出现如下的提示：</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0MDA1ODgy?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>（4）输入java命令就会出现如下图所示的结果</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0MTMwMjI2?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<h2 id=\"7-写一段代码可以验证一下\"><a href=\"#7-写一段代码可以验证一下\" class=\"headerlink\" title=\"7.写一段代码可以验证一下\"></a>7.写一段代码可以验证一下</h2><h5 id=\"（1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava-java，此时需要注意，你的文件名字后缀一定是-java\"><a href=\"#（1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava-java，此时需要注意，你的文件名字后缀一定是-java\" class=\"headerlink\" title=\"（1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava.java，此时需要注意，你的文件名字后缀一定是.java\"></a>（1）我在E盘新建了一个文件夹叫javafile，在里面有一个Java文件，名字叫TestJava.java，此时需要注意，你的文件名字后缀一定是.java</h5><h5 id=\"（2）你需要在你的文件里面写下面的代码：\"><a href=\"#（2）你需要在你的文件里面写下面的代码：\" class=\"headerlink\" title=\"（2）你需要在你的文件里面写下面的代码：\"></a>（2）你需要在你的文件里面写下面的代码：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class TestJava&#123;</span><br><span class=\"line\">\tpublic static void main(String[] args)&#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;I am a  java new learner!&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"（3）继续windows-r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样：\"><a href=\"#（3）继续windows-r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样：\" class=\"headerlink\" title=\"（3）继续windows+r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样：\"></a>（3）继续windows+r键进入dos命令行，你需要首先进入你java文件所在的目录，然后分别使用javac命令对你的java文件进行编译，然后使用java命令来解析你的javac命令编译的结果，就会如下图所示这样：</h5><p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI0OTQxNzc4?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>此处一定要注意：必须进入文件所在的目录；其次使用javac命令 文件的名字的后面一定要跟着.java的文件后缀；使用java命令时.java后缀可以不用写。<br>当你执行完javac命令如果没有错误提示，说明通过了编译，就会在你的文件目录下生成一个同名的.class文件。</p>\n<p> <img src=\"https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwNjE4MjI1MjAxNjI5?x-oss-process=image/format,png\" alt=\"这里写图片描述\"> </p>\n<p>如果你完成了以上的所有，并且结果显示正确，那么说明你的JDK安装和环境配置都很成功，此时你就可以开始你的JAVA学习了。<br>JDK1.8 API链接：<br><a href=\"http://docs.oracle.com/javase/8/docs/api/\" target=\"_blank\" rel=\"noopener\">http://docs.oracle.com/javase/8/docs/api/</a><br>JAVA tutorials:<br><a href=\"http://docs.oracle.com/javase/tutorial/\" target=\"_blank\" rel=\"noopener\">http://docs.oracle.com/javase/tutorial/</a></p>"},{"title":"〖postman〗接口测试01-基本介绍与安装","abbrlink":"d7719dab","date":"2021-03-06T14:00:00.000Z","_content":"\n> postman是一款支持http协议的接口测试工具，其主要特点就是功能强大，使用简单。 对于我们做接口测试来说，如果选择工具的话，postman可以是一款非常值得推荐的工具 。 <!-- more --> \n\n#### postman安装步骤（以windows为例）：\n\n访问postman官方网站，下载最新版本，访问地址：https://www.postman.com/downloads/\n\n进入到下载页面，根据自己电脑下载对应的版本。\n\n击下载的安装包，进入到安装界面，直到用户登录和注册界面。选择跳过，会进入到postman主界面，至此postman安装成功。\n\n ![down]( /img/blog/postman/01/01.png) ","source":"_posts/Postman/〖postman〗接口测试01-基本介绍与安装.md","raw":"---\ntitle: '〖postman〗接口测试01-基本介绍与安装'\nabbrlink: d7719dab\ndate: 2021-03-06 22:00:00\ntags:\n - postman\ncategories:\n  - postman\n---\n\n> postman是一款支持http协议的接口测试工具，其主要特点就是功能强大，使用简单。 对于我们做接口测试来说，如果选择工具的话，postman可以是一款非常值得推荐的工具 。 <!-- more --> \n\n#### postman安装步骤（以windows为例）：\n\n访问postman官方网站，下载最新版本，访问地址：https://www.postman.com/downloads/\n\n进入到下载页面，根据自己电脑下载对应的版本。\n\n击下载的安装包，进入到安装界面，直到用户登录和注册界面。选择跳过，会进入到postman主界面，至此postman安装成功。\n\n ![down]( /img/blog/postman/01/01.png) ","slug":"Postman/〖postman〗接口测试01-基本介绍与安装","published":1,"updated":"2021-03-06T14:00:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3x2001hn4epgqteczxf","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>postman是一款支持http协议的接口测试工具，其主要特点就是功能强大，使用简单。 对于我们做接口测试来说，如果选择工具的话，postman可以是一款非常值得推荐的工具 。 <a id=\"more\"></a> </p>\n</blockquote>\n<h4 id=\"postman安装步骤（以windows为例）：\"><a href=\"#postman安装步骤（以windows为例）：\" class=\"headerlink\" title=\"postman安装步骤（以windows为例）：\"></a>postman安装步骤（以windows为例）：</h4><p>访问postman官方网站，下载最新版本，访问地址：<a href=\"https://www.postman.com/downloads/\" target=\"_blank\" rel=\"noopener\">https://www.postman.com/downloads/</a></p>\n<p>进入到下载页面，根据自己电脑下载对应的版本。</p>\n<p>击下载的安装包，进入到安装界面，直到用户登录和注册界面。选择跳过，会进入到postman主界面，至此postman安装成功。</p>\n<p> <img src=\"/img/blog/postman/01/01.png\" alt=\"down\"> </p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>postman是一款支持http协议的接口测试工具，其主要特点就是功能强大，使用简单。 对于我们做接口测试来说，如果选择工具的话，postman可以是一款非常值得推荐的工具 。","more":"</p>\n</blockquote>\n<h4 id=\"postman安装步骤（以windows为例）：\"><a href=\"#postman安装步骤（以windows为例）：\" class=\"headerlink\" title=\"postman安装步骤（以windows为例）：\"></a>postman安装步骤（以windows为例）：</h4><p>访问postman官方网站，下载最新版本，访问地址：<a href=\"https://www.postman.com/downloads/\" target=\"_blank\" rel=\"noopener\">https://www.postman.com/downloads/</a></p>\n<p>进入到下载页面，根据自己电脑下载对应的版本。</p>\n<p>击下载的安装包，进入到安装界面，直到用户登录和注册界面。选择跳过，会进入到postman主界面，至此postman安装成功。</p>\n<p> <img src=\"/img/blog/postman/01/01.png\" alt=\"down\"> </p>"},{"title":"〖postman〗接口测试02-发送第一个请求","abbrlink":"8a00d2ea","date":"2021-03-13T15:30:00.000Z","_content":"\n## 1.界面导航说明\n\n在使用postman发送请求前，我们先来看下postman的主界面。来简单的了解下这款工具的主要功能 。 <!-- more --> \n\n ![img](/img/blog/postman/02/02-01.png) \n\n## 2.发送第一个请求 \n\n打开postman，点击+加号打开一个新的请求页。\n\n​\t在请求的URL中输入请求地址：http://www.weather.com.cn/data/sk/101010100.html\n\n​\t点击Send按钮，这时就可以在下部的窗格中看到来自服务器的json响应数据\n\n  ![img](/img/blog/postman/02/02-02.png) \n\n\n","source":"_posts/Postman/〖postman〗接口测试02-发送第一个请求.md","raw":"---\ntitle: 〖postman〗接口测试02-发送第一个请求\nabbrlink: 8a00d2ea\ndate: 2021-03-13 23:30:00\ntags:\n - postman\ncategories:\n  - postman\n---\n\n## 1.界面导航说明\n\n在使用postman发送请求前，我们先来看下postman的主界面。来简单的了解下这款工具的主要功能 。 <!-- more --> \n\n ![img](/img/blog/postman/02/02-01.png) \n\n## 2.发送第一个请求 \n\n打开postman，点击+加号打开一个新的请求页。\n\n​\t在请求的URL中输入请求地址：http://www.weather.com.cn/data/sk/101010100.html\n\n​\t点击Send按钮，这时就可以在下部的窗格中看到来自服务器的json响应数据\n\n  ![img](/img/blog/postman/02/02-02.png) \n\n\n","slug":"Postman/〖postman〗接口测试02-发送第一个请求","published":1,"updated":"2021-03-13T15:30:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3x3001ln4ep1y7ldn4i","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"1-界面导航说明\"><a href=\"#1-界面导航说明\" class=\"headerlink\" title=\"1.界面导航说明\"></a>1.界面导航说明</h2><p>在使用postman发送请求前，我们先来看下postman的主界面。来简单的了解下这款工具的主要功能 。 <a id=\"more\"></a> </p>\n<p> <img src=\"/img/blog/postman/02/02-01.png\" alt=\"img\"> </p>\n<h2 id=\"2-发送第一个请求\"><a href=\"#2-发送第一个请求\" class=\"headerlink\" title=\"2.发送第一个请求\"></a>2.发送第一个请求</h2><p>打开postman，点击+加号打开一个新的请求页。</p>\n<p>​    在请求的URL中输入请求地址：<a href=\"http://www.weather.com.cn/data/sk/101010100.html\" target=\"_blank\" rel=\"noopener\">http://www.weather.com.cn/data/sk/101010100.html</a></p>\n<p>​    点击Send按钮，这时就可以在下部的窗格中看到来自服务器的json响应数据</p>\n<p>  <img src=\"/img/blog/postman/02/02-02.png\" alt=\"img\"> </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"1-界面导航说明\"><a href=\"#1-界面导航说明\" class=\"headerlink\" title=\"1.界面导航说明\"></a>1.界面导航说明</h2><p>在使用postman发送请求前，我们先来看下postman的主界面。来简单的了解下这款工具的主要功能 。","more":"</p>\n<p> <img src=\"/img/blog/postman/02/02-01.png\" alt=\"img\"> </p>\n<h2 id=\"2-发送第一个请求\"><a href=\"#2-发送第一个请求\" class=\"headerlink\" title=\"2.发送第一个请求\"></a>2.发送第一个请求</h2><p>打开postman，点击+加号打开一个新的请求页。</p>\n<p>​    在请求的URL中输入请求地址：<a href=\"http://www.weather.com.cn/data/sk/101010100.html\" target=\"_blank\" rel=\"noopener\">http://www.weather.com.cn/data/sk/101010100.html</a></p>\n<p>​    点击Send按钮，这时就可以在下部的窗格中看到来自服务器的json响应数据</p>\n<p>  <img src=\"/img/blog/postman/02/02-02.png\" alt=\"img\"> </p>"},{"title":"〖postman〗接口测试04-常见类型接口请求","abbrlink":"be476180","date":"2021-03-27T12:38:24.000Z","_content":"\n接下来我们介绍俩种表单 ，分别是：application/x-www-form-urlencoded和multipart/form-data。它们都支持表单请求，所不同的是后一种支持上传文件，而前一种只支持表单 。 <!-- more --> \n\n## 三、表单类型的请求\n\n#### 1. 什么是表单 ？\n> 简单理解就是在请求头中查看Content-Type，它的值如果是:application/x-www-form-urlencoded .那么就说明客户端提交的数据是以表单形式提交的\n\n我们都知道，在发送HTTP请求的时候，一个请求中一般包含三个部分，分别是请求行，请求头，请求体 。不同的接口，请求体的数据类型是不一样的，比较常见的一种就是表单类型，见下图\n\n ![img](/img/blog/postman/04/04-01.png) \n\n#### 2. postman中如何请求？\n\n\n在postman请求上图的接口，我们只需要填写四个参数，分别是：\n\n请求方法：POST\n请求URL：http://localhost/index.php?m=Home&c=User&a=do_login&t=0.21942974229794432\n请求头：Content-Type：application/x-www-form-urlencoded\n请求体： username=13088888888&password=123456&verify_code=8888\n\n#### 3. 实现步骤：\n\n   1. 打开postman，新建一个请求 。\n   2. 在请求中设置以上四个参数，点击Send按钮。\n   3. 在postman中设置请求体类型为，需要选择body-> x-www-form-urlencoded\n   4. 查看响应数据。\n\n\n ![img](/img/blog/postman/04/04-02.png) \n\n## 四、支持上传文件的表单请求\n\n#### 1. 什么是文件请求？\n\n在做接口测试时，也会遇到需要上传文件的接口，比如微信的更新头像。这就需要另外一种表单的支持：multipart/form-data。这种类型的表单既支持上面类型的表单请求，同时支持上传文件。 它的请求报文往往是这样的。\n```\nPOST http://localhost/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html HTTP/1.1\nContent-Type: multipart/form-data\nfile=a1.jpg\n```\n这种类型的接口，在postman中该如何请求呢 ？ 我们先分析需要填写的参数 。\n请求方法：POST\n请求URL：http://localhost/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html\n请求类型：multipart/form-data\n请求体：file=a1.jpg\n\n#### 2. 实现步骤：\n\n1. 打开postman，新建一个请求 。\n2. 在请求中设置以上四个参数，点击Send按钮。\n3. 注意：在postman中设置请求体类型，需要选择body-> form-data 。\n4. file中要选择File类型，然后上传本地的文件 。\n5. 查看响应数据。\n\n ![img](/img/blog/postman/04/04-03.png) \n\n> 总结 ，以上四种类型的接口就是我们常见的接口请求，简单的来说，其实就是在Body中分别选择form-data(支持上传文件)，x-www-form-urlencoded(表单),raw-json（json）。最后填写响应的请求数据即可 。","source":"_posts/Postman/〖postman〗接口测试04-常见类型接口请求.md","raw":"---\ntitle: 〖postman〗接口测试04-常见类型接口请求\nabbrlink: be476180\ndate: 2021-03-27 20:38:24\ntags:\n  - postman\ncategories:\n  - postman\n---\n\n接下来我们介绍俩种表单 ，分别是：application/x-www-form-urlencoded和multipart/form-data。它们都支持表单请求，所不同的是后一种支持上传文件，而前一种只支持表单 。 <!-- more --> \n\n## 三、表单类型的请求\n\n#### 1. 什么是表单 ？\n> 简单理解就是在请求头中查看Content-Type，它的值如果是:application/x-www-form-urlencoded .那么就说明客户端提交的数据是以表单形式提交的\n\n我们都知道，在发送HTTP请求的时候，一个请求中一般包含三个部分，分别是请求行，请求头，请求体 。不同的接口，请求体的数据类型是不一样的，比较常见的一种就是表单类型，见下图\n\n ![img](/img/blog/postman/04/04-01.png) \n\n#### 2. postman中如何请求？\n\n\n在postman请求上图的接口，我们只需要填写四个参数，分别是：\n\n请求方法：POST\n请求URL：http://localhost/index.php?m=Home&c=User&a=do_login&t=0.21942974229794432\n请求头：Content-Type：application/x-www-form-urlencoded\n请求体： username=13088888888&password=123456&verify_code=8888\n\n#### 3. 实现步骤：\n\n   1. 打开postman，新建一个请求 。\n   2. 在请求中设置以上四个参数，点击Send按钮。\n   3. 在postman中设置请求体类型为，需要选择body-> x-www-form-urlencoded\n   4. 查看响应数据。\n\n\n ![img](/img/blog/postman/04/04-02.png) \n\n## 四、支持上传文件的表单请求\n\n#### 1. 什么是文件请求？\n\n在做接口测试时，也会遇到需要上传文件的接口，比如微信的更新头像。这就需要另外一种表单的支持：multipart/form-data。这种类型的表单既支持上面类型的表单请求，同时支持上传文件。 它的请求报文往往是这样的。\n```\nPOST http://localhost/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html HTTP/1.1\nContent-Type: multipart/form-data\nfile=a1.jpg\n```\n这种类型的接口，在postman中该如何请求呢 ？ 我们先分析需要填写的参数 。\n请求方法：POST\n请求URL：http://localhost/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html\n请求类型：multipart/form-data\n请求体：file=a1.jpg\n\n#### 2. 实现步骤：\n\n1. 打开postman，新建一个请求 。\n2. 在请求中设置以上四个参数，点击Send按钮。\n3. 注意：在postman中设置请求体类型，需要选择body-> form-data 。\n4. file中要选择File类型，然后上传本地的文件 。\n5. 查看响应数据。\n\n ![img](/img/blog/postman/04/04-03.png) \n\n> 总结 ，以上四种类型的接口就是我们常见的接口请求，简单的来说，其实就是在Body中分别选择form-data(支持上传文件)，x-www-form-urlencoded(表单),raw-json（json）。最后填写响应的请求数据即可 。","slug":"Postman/〖postman〗接口测试04-常见类型接口请求","published":1,"updated":"2021-03-27T12:38:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3x4001nn4ep6anja4bh","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>接下来我们介绍俩种表单 ，分别是：application/x-www-form-urlencoded和multipart/form-data。它们都支持表单请求，所不同的是后一种支持上传文件，而前一种只支持表单 。 <a id=\"more\"></a> </p>\n<h2 id=\"三、表单类型的请求\"><a href=\"#三、表单类型的请求\" class=\"headerlink\" title=\"三、表单类型的请求\"></a>三、表单类型的请求</h2><h4 id=\"1-什么是表单-？\"><a href=\"#1-什么是表单-？\" class=\"headerlink\" title=\"1. 什么是表单 ？\"></a>1. 什么是表单 ？</h4><blockquote>\n<p>简单理解就是在请求头中查看Content-Type，它的值如果是:application/x-www-form-urlencoded .那么就说明客户端提交的数据是以表单形式提交的</p>\n</blockquote>\n<p>我们都知道，在发送HTTP请求的时候，一个请求中一般包含三个部分，分别是请求行，请求头，请求体 。不同的接口，请求体的数据类型是不一样的，比较常见的一种就是表单类型，见下图</p>\n<p> <img src=\"/img/blog/postman/04/04-01.png\" alt=\"img\"> </p>\n<h4 id=\"2-postman中如何请求？\"><a href=\"#2-postman中如何请求？\" class=\"headerlink\" title=\"2. postman中如何请求？\"></a>2. postman中如何请求？</h4><p>在postman请求上图的接口，我们只需要填写四个参数，分别是：</p>\n<p>请求方法：POST<br>请求URL：<a href=\"http://localhost/index.php?m=Home&amp;c=User&amp;a=do_login&amp;t=0.21942974229794432\" target=\"_blank\" rel=\"noopener\">http://localhost/index.php?m=Home&amp;c=User&amp;a=do_login&amp;t=0.21942974229794432</a><br>请求头：Content-Type：application/x-www-form-urlencoded<br>请求体： username=13088888888&amp;password=123456&amp;verify_code=8888</p>\n<h4 id=\"3-实现步骤：\"><a href=\"#3-实现步骤：\" class=\"headerlink\" title=\"3. 实现步骤：\"></a>3. 实现步骤：</h4><ol>\n<li>打开postman，新建一个请求 。</li>\n<li>在请求中设置以上四个参数，点击Send按钮。</li>\n<li>在postman中设置请求体类型为，需要选择body-&gt; x-www-form-urlencoded</li>\n<li>查看响应数据。</li>\n</ol>\n<p> <img src=\"/img/blog/postman/04/04-02.png\" alt=\"img\"> </p>\n<h2 id=\"四、支持上传文件的表单请求\"><a href=\"#四、支持上传文件的表单请求\" class=\"headerlink\" title=\"四、支持上传文件的表单请求\"></a>四、支持上传文件的表单请求</h2><h4 id=\"1-什么是文件请求？\"><a href=\"#1-什么是文件请求？\" class=\"headerlink\" title=\"1. 什么是文件请求？\"></a>1. 什么是文件请求？</h4><p>在做接口测试时，也会遇到需要上传文件的接口，比如微信的更新头像。这就需要另外一种表单的支持：multipart/form-data。这种类型的表单既支持上面类型的表单请求，同时支持上传文件。 它的请求报文往往是这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http:&#x2F;&#x2F;localhost&#x2F;index.php&#x2F;home&#x2F;Uploadify&#x2F;imageUp&#x2F;savepath&#x2F;head_pic&#x2F;pictitle&#x2F;banner&#x2F;dir&#x2F;images.html HTTP&#x2F;1.1</span><br><span class=\"line\">Content-Type: multipart&#x2F;form-data</span><br><span class=\"line\">file&#x3D;a1.jpg</span><br></pre></td></tr></table></figure>\n<p>这种类型的接口，在postman中该如何请求呢 ？ 我们先分析需要填写的参数 。<br>请求方法：POST<br>请求URL：<a href=\"http://localhost/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html\" target=\"_blank\" rel=\"noopener\">http://localhost/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html</a><br>请求类型：multipart/form-data<br>请求体：file=a1.jpg</p>\n<h4 id=\"2-实现步骤：\"><a href=\"#2-实现步骤：\" class=\"headerlink\" title=\"2. 实现步骤：\"></a>2. 实现步骤：</h4><ol>\n<li><p>打开postman，新建一个请求 。</p>\n</li>\n<li><p>在请求中设置以上四个参数，点击Send按钮。</p>\n</li>\n<li><p>注意：在postman中设置请求体类型，需要选择body-&gt; form-data 。</p>\n</li>\n<li><p>file中要选择File类型，然后上传本地的文件 。</p>\n</li>\n<li><p>查看响应数据。</p>\n<p><img src=\"/img/blog/postman/04/04-03.png\" alt=\"img\"> </p>\n</li>\n</ol>\n<blockquote>\n<p>总结 ，以上四种类型的接口就是我们常见的接口请求，简单的来说，其实就是在Body中分别选择form-data(支持上传文件)，x-www-form-urlencoded(表单),raw-json（json）。最后填写响应的请求数据即可 。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>接下来我们介绍俩种表单 ，分别是：application/x-www-form-urlencoded和multipart/form-data。它们都支持表单请求，所不同的是后一种支持上传文件，而前一种只支持表单 。","more":"</p>\n<h2 id=\"三、表单类型的请求\"><a href=\"#三、表单类型的请求\" class=\"headerlink\" title=\"三、表单类型的请求\"></a>三、表单类型的请求</h2><h4 id=\"1-什么是表单-？\"><a href=\"#1-什么是表单-？\" class=\"headerlink\" title=\"1. 什么是表单 ？\"></a>1. 什么是表单 ？</h4><blockquote>\n<p>简单理解就是在请求头中查看Content-Type，它的值如果是:application/x-www-form-urlencoded .那么就说明客户端提交的数据是以表单形式提交的</p>\n</blockquote>\n<p>我们都知道，在发送HTTP请求的时候，一个请求中一般包含三个部分，分别是请求行，请求头，请求体 。不同的接口，请求体的数据类型是不一样的，比较常见的一种就是表单类型，见下图</p>\n<p> <img src=\"/img/blog/postman/04/04-01.png\" alt=\"img\"> </p>\n<h4 id=\"2-postman中如何请求？\"><a href=\"#2-postman中如何请求？\" class=\"headerlink\" title=\"2. postman中如何请求？\"></a>2. postman中如何请求？</h4><p>在postman请求上图的接口，我们只需要填写四个参数，分别是：</p>\n<p>请求方法：POST<br>请求URL：<a href=\"http://localhost/index.php?m=Home&amp;c=User&amp;a=do_login&amp;t=0.21942974229794432\" target=\"_blank\" rel=\"noopener\">http://localhost/index.php?m=Home&amp;c=User&amp;a=do_login&amp;t=0.21942974229794432</a><br>请求头：Content-Type：application/x-www-form-urlencoded<br>请求体： username=13088888888&amp;password=123456&amp;verify_code=8888</p>\n<h4 id=\"3-实现步骤：\"><a href=\"#3-实现步骤：\" class=\"headerlink\" title=\"3. 实现步骤：\"></a>3. 实现步骤：</h4><ol>\n<li>打开postman，新建一个请求 。</li>\n<li>在请求中设置以上四个参数，点击Send按钮。</li>\n<li>在postman中设置请求体类型为，需要选择body-&gt; x-www-form-urlencoded</li>\n<li>查看响应数据。</li>\n</ol>\n<p> <img src=\"/img/blog/postman/04/04-02.png\" alt=\"img\"> </p>\n<h2 id=\"四、支持上传文件的表单请求\"><a href=\"#四、支持上传文件的表单请求\" class=\"headerlink\" title=\"四、支持上传文件的表单请求\"></a>四、支持上传文件的表单请求</h2><h4 id=\"1-什么是文件请求？\"><a href=\"#1-什么是文件请求？\" class=\"headerlink\" title=\"1. 什么是文件请求？\"></a>1. 什么是文件请求？</h4><p>在做接口测试时，也会遇到需要上传文件的接口，比如微信的更新头像。这就需要另外一种表单的支持：multipart/form-data。这种类型的表单既支持上面类型的表单请求，同时支持上传文件。 它的请求报文往往是这样的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http:&#x2F;&#x2F;localhost&#x2F;index.php&#x2F;home&#x2F;Uploadify&#x2F;imageUp&#x2F;savepath&#x2F;head_pic&#x2F;pictitle&#x2F;banner&#x2F;dir&#x2F;images.html HTTP&#x2F;1.1</span><br><span class=\"line\">Content-Type: multipart&#x2F;form-data</span><br><span class=\"line\">file&#x3D;a1.jpg</span><br></pre></td></tr></table></figure>\n<p>这种类型的接口，在postman中该如何请求呢 ？ 我们先分析需要填写的参数 。<br>请求方法：POST<br>请求URL：<a href=\"http://localhost/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html\" target=\"_blank\" rel=\"noopener\">http://localhost/index.php/home/Uploadify/imageUp/savepath/head_pic/pictitle/banner/dir/images.html</a><br>请求类型：multipart/form-data<br>请求体：file=a1.jpg</p>\n<h4 id=\"2-实现步骤：\"><a href=\"#2-实现步骤：\" class=\"headerlink\" title=\"2. 实现步骤：\"></a>2. 实现步骤：</h4><ol>\n<li><p>打开postman，新建一个请求 。</p>\n</li>\n<li><p>在请求中设置以上四个参数，点击Send按钮。</p>\n</li>\n<li><p>注意：在postman中设置请求体类型，需要选择body-&gt; form-data 。</p>\n</li>\n<li><p>file中要选择File类型，然后上传本地的文件 。</p>\n</li>\n<li><p>查看响应数据。</p>\n<p><img src=\"/img/blog/postman/04/04-03.png\" alt=\"img\"> </p>\n</li>\n</ol>\n<blockquote>\n<p>总结 ，以上四种类型的接口就是我们常见的接口请求，简单的来说，其实就是在Body中分别选择form-data(支持上传文件)，x-www-form-urlencoded(表单),raw-json（json）。最后填写响应的请求数据即可 。</p>\n</blockquote>"},{"title":"〖postman〗接口测试03-常见类型接口请求","abbrlink":"66841aa6","date":"2021-03-20T12:18:17.000Z","_content":"\n\n在做接口测试时，我们经常遇到以下4种类型的接口，分别是查询参数接口，表单类型的接口，支持文件上传的接口以及json类型的接口 。那么这些类型的接口在postman如何去请求呢 ？ <!-- more --> \n\n## 一、查询参数的接口请求\n\n#### 1. 什么是查询参数?\n\n> 所谓的查询参数，其实就是URL地址中问号（?）后面的部分就叫查询参数\n\n比如：http://cx.shouji.360.cn/phonearea.php?number=13012345678 。在这个接口中，查询参数就是:number=13012345678 。而这一部分是由有键值对组成，格式为：key1=value1&key2=value2, 如果有多组键值对，需要用&隔开 。\n\n#### 2. postman如何请求?\n\n1. 在postman中实现这类接口请求非常简单，一般就需要明确俩个参数即可，一个是请求方法，一个请求地址。\n\n2. 针对上面的那个接口，地址已经给出 ，而它的请求方法是get 。那么在postman中只需要把这俩个参数填写上即可请求 。\n\n\n#### 3. 具体实现步骤：\n\n1. 打开postman，新建一个请求。\n\n2. 在请求方法中选择请求方法：GET,因为在postman中默认的请求方法就是GET,所以这一步可以忽略\n\n3. 接口URL中输入地址，点击Send按钮就发送请求了 。\n\n\n ![img](/img/blog/postman/03/03-01.png) \n\n \n\n> 说明：查询参数的URL一般直接拷贝到输入的URL地址栏中就可以了，当然也可以把查询参数在Params中输入，俩者的效果是一样的 。\n\n \n\n## 二、json类型的接口请求\n\n#### 1. 什么是文件请求？\n\n\n> json类型的请求参数是接口测试中最常见的一种情况了 ，常用于创建活动&商品等， 它的请求体类型为json,我们来看下这个请求报文 。\n\n```\nPOST http://xxx/api/sys/login HTTP/1.1\nContent-Type: application/json;charset=UTF-8\n\n{\"account\":\"root\",\"password\":\"123456\"}\n```\n根据以上报文，我们可以分析出，我们在postman只需要填写四个参数即可，具体如下：\n\n请求方法：POST\n请求地址：http://xxx/api/sys/login\n请求体类型：json\n请求体数据：{\"account\":\"root\",\"password\":\"123456\"}\n\n#### 2. 实现步骤：\n\n1. 打开postman，新建一个请求 。\n\n2. 在请求中设置以上四个参数，点击Send按钮。\n3. 查看响应数据。\n\n> 注意：在postman中设置请求体类型，需要选择body-> raw -JSON\n\n ![img](/img/blog/postman/03/03-02.png) \n\n ","source":"_posts/Postman/〖postman〗接口测试03-常见类型接口请求.md","raw":"---\ntitle: 〖postman〗接口测试03-常见类型接口请求\nabbrlink: 66841aa6\ndate: 2021-03-20 20:18:17\ntags:\n - postman\ncategories:\n  - postman\n---\n\n\n在做接口测试时，我们经常遇到以下4种类型的接口，分别是查询参数接口，表单类型的接口，支持文件上传的接口以及json类型的接口 。那么这些类型的接口在postman如何去请求呢 ？ <!-- more --> \n\n## 一、查询参数的接口请求\n\n#### 1. 什么是查询参数?\n\n> 所谓的查询参数，其实就是URL地址中问号（?）后面的部分就叫查询参数\n\n比如：http://cx.shouji.360.cn/phonearea.php?number=13012345678 。在这个接口中，查询参数就是:number=13012345678 。而这一部分是由有键值对组成，格式为：key1=value1&key2=value2, 如果有多组键值对，需要用&隔开 。\n\n#### 2. postman如何请求?\n\n1. 在postman中实现这类接口请求非常简单，一般就需要明确俩个参数即可，一个是请求方法，一个请求地址。\n\n2. 针对上面的那个接口，地址已经给出 ，而它的请求方法是get 。那么在postman中只需要把这俩个参数填写上即可请求 。\n\n\n#### 3. 具体实现步骤：\n\n1. 打开postman，新建一个请求。\n\n2. 在请求方法中选择请求方法：GET,因为在postman中默认的请求方法就是GET,所以这一步可以忽略\n\n3. 接口URL中输入地址，点击Send按钮就发送请求了 。\n\n\n ![img](/img/blog/postman/03/03-01.png) \n\n \n\n> 说明：查询参数的URL一般直接拷贝到输入的URL地址栏中就可以了，当然也可以把查询参数在Params中输入，俩者的效果是一样的 。\n\n \n\n## 二、json类型的接口请求\n\n#### 1. 什么是文件请求？\n\n\n> json类型的请求参数是接口测试中最常见的一种情况了 ，常用于创建活动&商品等， 它的请求体类型为json,我们来看下这个请求报文 。\n\n```\nPOST http://xxx/api/sys/login HTTP/1.1\nContent-Type: application/json;charset=UTF-8\n\n{\"account\":\"root\",\"password\":\"123456\"}\n```\n根据以上报文，我们可以分析出，我们在postman只需要填写四个参数即可，具体如下：\n\n请求方法：POST\n请求地址：http://xxx/api/sys/login\n请求体类型：json\n请求体数据：{\"account\":\"root\",\"password\":\"123456\"}\n\n#### 2. 实现步骤：\n\n1. 打开postman，新建一个请求 。\n\n2. 在请求中设置以上四个参数，点击Send按钮。\n3. 查看响应数据。\n\n> 注意：在postman中设置请求体类型，需要选择body-> raw -JSON\n\n ![img](/img/blog/postman/03/03-02.png) \n\n ","slug":"Postman/〖postman〗接口测试03-常见类型接口请求","published":1,"updated":"2021-03-20T12:18:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3x6001rn4epdd7r5q6k","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>在做接口测试时，我们经常遇到以下4种类型的接口，分别是查询参数接口，表单类型的接口，支持文件上传的接口以及json类型的接口 。那么这些类型的接口在postman如何去请求呢 ？ <a id=\"more\"></a> </p>\n<h2 id=\"一、查询参数的接口请求\"><a href=\"#一、查询参数的接口请求\" class=\"headerlink\" title=\"一、查询参数的接口请求\"></a>一、查询参数的接口请求</h2><h4 id=\"1-什么是查询参数\"><a href=\"#1-什么是查询参数\" class=\"headerlink\" title=\"1. 什么是查询参数?\"></a>1. 什么是查询参数?</h4><blockquote>\n<p>所谓的查询参数，其实就是URL地址中问号（?）后面的部分就叫查询参数</p>\n</blockquote>\n<p>比如：<a href=\"http://cx.shouji.360.cn/phonearea.php?number=13012345678\" target=\"_blank\" rel=\"noopener\">http://cx.shouji.360.cn/phonearea.php?number=13012345678</a> 。在这个接口中，查询参数就是:number=13012345678 。而这一部分是由有键值对组成，格式为：key1=value1&amp;key2=value2, 如果有多组键值对，需要用&amp;隔开 。</p>\n<h4 id=\"2-postman如何请求\"><a href=\"#2-postman如何请求\" class=\"headerlink\" title=\"2. postman如何请求?\"></a>2. postman如何请求?</h4><ol>\n<li><p>在postman中实现这类接口请求非常简单，一般就需要明确俩个参数即可，一个是请求方法，一个请求地址。</p>\n</li>\n<li><p>针对上面的那个接口，地址已经给出 ，而它的请求方法是get 。那么在postman中只需要把这俩个参数填写上即可请求 。</p>\n</li>\n</ol>\n<h4 id=\"3-具体实现步骤：\"><a href=\"#3-具体实现步骤：\" class=\"headerlink\" title=\"3. 具体实现步骤：\"></a>3. 具体实现步骤：</h4><ol>\n<li><p>打开postman，新建一个请求。</p>\n</li>\n<li><p>在请求方法中选择请求方法：GET,因为在postman中默认的请求方法就是GET,所以这一步可以忽略</p>\n</li>\n<li><p>接口URL中输入地址，点击Send按钮就发送请求了 。</p>\n</li>\n</ol>\n<p> <img src=\"/img/blog/postman/03/03-01.png\" alt=\"img\"> </p>\n<blockquote>\n<p>说明：查询参数的URL一般直接拷贝到输入的URL地址栏中就可以了，当然也可以把查询参数在Params中输入，俩者的效果是一样的 。</p>\n</blockquote>\n<h2 id=\"二、json类型的接口请求\"><a href=\"#二、json类型的接口请求\" class=\"headerlink\" title=\"二、json类型的接口请求\"></a>二、json类型的接口请求</h2><h4 id=\"1-什么是文件请求？\"><a href=\"#1-什么是文件请求？\" class=\"headerlink\" title=\"1. 什么是文件请求？\"></a>1. 什么是文件请求？</h4><blockquote>\n<p>json类型的请求参数是接口测试中最常见的一种情况了 ，常用于创建活动&amp;商品等， 它的请求体类型为json,我们来看下这个请求报文 。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http:&#x2F;&#x2F;xxx&#x2F;api&#x2F;sys&#x2F;login HTTP&#x2F;1.1</span><br><span class=\"line\">Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;account&quot;:&quot;root&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>根据以上报文，我们可以分析出，我们在postman只需要填写四个参数即可，具体如下：</p>\n<p>请求方法：POST<br>请求地址：<a href=\"http://xxx/api/sys/login\" target=\"_blank\" rel=\"noopener\">http://xxx/api/sys/login</a><br>请求体类型：json<br>请求体数据：{“account”:”root”,”password”:”123456”}</p>\n<h4 id=\"2-实现步骤：\"><a href=\"#2-实现步骤：\" class=\"headerlink\" title=\"2. 实现步骤：\"></a>2. 实现步骤：</h4><ol>\n<li><p>打开postman，新建一个请求 。</p>\n</li>\n<li><p>在请求中设置以上四个参数，点击Send按钮。</p>\n</li>\n<li><p>查看响应数据。</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：在postman中设置请求体类型，需要选择body-&gt; raw -JSON</p>\n</blockquote>\n<p> <img src=\"/img/blog/postman/03/03-02.png\" alt=\"img\"> </p>\n","site":{"data":{}},"excerpt":"<p>在做接口测试时，我们经常遇到以下4种类型的接口，分别是查询参数接口，表单类型的接口，支持文件上传的接口以及json类型的接口 。那么这些类型的接口在postman如何去请求呢 ？","more":"</p>\n<h2 id=\"一、查询参数的接口请求\"><a href=\"#一、查询参数的接口请求\" class=\"headerlink\" title=\"一、查询参数的接口请求\"></a>一、查询参数的接口请求</h2><h4 id=\"1-什么是查询参数\"><a href=\"#1-什么是查询参数\" class=\"headerlink\" title=\"1. 什么是查询参数?\"></a>1. 什么是查询参数?</h4><blockquote>\n<p>所谓的查询参数，其实就是URL地址中问号（?）后面的部分就叫查询参数</p>\n</blockquote>\n<p>比如：<a href=\"http://cx.shouji.360.cn/phonearea.php?number=13012345678\" target=\"_blank\" rel=\"noopener\">http://cx.shouji.360.cn/phonearea.php?number=13012345678</a> 。在这个接口中，查询参数就是:number=13012345678 。而这一部分是由有键值对组成，格式为：key1=value1&amp;key2=value2, 如果有多组键值对，需要用&amp;隔开 。</p>\n<h4 id=\"2-postman如何请求\"><a href=\"#2-postman如何请求\" class=\"headerlink\" title=\"2. postman如何请求?\"></a>2. postman如何请求?</h4><ol>\n<li><p>在postman中实现这类接口请求非常简单，一般就需要明确俩个参数即可，一个是请求方法，一个请求地址。</p>\n</li>\n<li><p>针对上面的那个接口，地址已经给出 ，而它的请求方法是get 。那么在postman中只需要把这俩个参数填写上即可请求 。</p>\n</li>\n</ol>\n<h4 id=\"3-具体实现步骤：\"><a href=\"#3-具体实现步骤：\" class=\"headerlink\" title=\"3. 具体实现步骤：\"></a>3. 具体实现步骤：</h4><ol>\n<li><p>打开postman，新建一个请求。</p>\n</li>\n<li><p>在请求方法中选择请求方法：GET,因为在postman中默认的请求方法就是GET,所以这一步可以忽略</p>\n</li>\n<li><p>接口URL中输入地址，点击Send按钮就发送请求了 。</p>\n</li>\n</ol>\n<p> <img src=\"/img/blog/postman/03/03-01.png\" alt=\"img\"> </p>\n<blockquote>\n<p>说明：查询参数的URL一般直接拷贝到输入的URL地址栏中就可以了，当然也可以把查询参数在Params中输入，俩者的效果是一样的 。</p>\n</blockquote>\n<h2 id=\"二、json类型的接口请求\"><a href=\"#二、json类型的接口请求\" class=\"headerlink\" title=\"二、json类型的接口请求\"></a>二、json类型的接口请求</h2><h4 id=\"1-什么是文件请求？\"><a href=\"#1-什么是文件请求？\" class=\"headerlink\" title=\"1. 什么是文件请求？\"></a>1. 什么是文件请求？</h4><blockquote>\n<p>json类型的请求参数是接口测试中最常见的一种情况了 ，常用于创建活动&amp;商品等， 它的请求体类型为json,我们来看下这个请求报文 。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST http:&#x2F;&#x2F;xxx&#x2F;api&#x2F;sys&#x2F;login HTTP&#x2F;1.1</span><br><span class=\"line\">Content-Type: application&#x2F;json;charset&#x3D;UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;&quot;account&quot;:&quot;root&quot;,&quot;password&quot;:&quot;123456&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p>根据以上报文，我们可以分析出，我们在postman只需要填写四个参数即可，具体如下：</p>\n<p>请求方法：POST<br>请求地址：<a href=\"http://xxx/api/sys/login\" target=\"_blank\" rel=\"noopener\">http://xxx/api/sys/login</a><br>请求体类型：json<br>请求体数据：{“account”:”root”,”password”:”123456”}</p>\n<h4 id=\"2-实现步骤：\"><a href=\"#2-实现步骤：\" class=\"headerlink\" title=\"2. 实现步骤：\"></a>2. 实现步骤：</h4><ol>\n<li><p>打开postman，新建一个请求 。</p>\n</li>\n<li><p>在请求中设置以上四个参数，点击Send按钮。</p>\n</li>\n<li><p>查看响应数据。</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：在postman中设置请求体类型，需要选择body-&gt; raw -JSON</p>\n</blockquote>\n<p> <img src=\"/img/blog/postman/03/03-02.png\" alt=\"img\"> </p>"},{"title":"〖postman〗接口测试05-响应数据解析","abbrlink":"9656df9f","date":"2022-01-10T14:33:29.000Z","_content":"\n## 什么是返回？\n响应数据是发送请求后经过服务器处理后返回的结果，响应是由三部分组成，分别是状态行、响应头、响应体。 <!-- more --> 我们来看下[postman](https://so.csdn.net/so/search?q=postman)的响应数据展示 \n\n![百度搜索](/img/blog/postman/05/05-01.png)\n\n在postman中的响应数据展示：\n状态行：Status：200 OK\n响应头：Headers + Cookies，需要注意的是Cookies是包含在响应头中的，但是为了明显，工具会分开显示\n响应体：Body\n\n## 返回测试什么？\n那么这些数据对我们做接口测试有什么作用呢 ？\nBody和Status是我们做接口测试的重点，一般来说我们都会验证响应体中的数据和响应状态码\nTest Results 是我们编写断言后，可以查看断言的执行结果 ，所以这个对我们也很有用 。\nTime 和Size 是我们做性能测试时，可以根据这俩个参数来对所测接口的性能做一个简单的判断。\n\n## 返回里有什么？\n接下来我们再来关注下Body中的几个显示主题，分别是：Pretty，Raw，Preview .\n![百度搜索](/img/blog/postman/05/05-02.png)\n\nPretty:翻译成中文就是漂亮 ， 也就是说返回的Body数据在这个标签中查看 ，都是经过格式化的，格式化后的数据看起来更加直观，所以postman默认展示的也是这个选项。比如返回html页面，它会经过格式化成HTML格式后展示，比如返回json，那么也会格式化成json格式展示 。\n\n需要说明的是，我们所测的接口多会返回json,这时我们看json数据时，只需要点击HTML后的小三角，选择JSON即可。\n\nRaw：翻译成中文未经过加工的，也就是原始数据 ，原始数据一般都是本文格式的，未经过格式化处理的，一般在抓包工具中都有这个选项 。\n\nPreview：翻译成中文就是预览，这个选项一般对返回HTML的页面效果特别明显，如请求百度后返回结果，点击这个选项后就直接能查看到的页面 ，如下图 。同时这个选项和浏览器抓包中的Preview也是一样的 。\n![百度搜索](/img/blog/postman/05/05-03.png)","source":"_posts/Postman/〖postman〗接口测试05-响应数据解析.md","raw":"---\ntitle: 〖postman〗接口测试05-响应数据解析\nabbrlink: 9656df9f\ndate: 2022-01-10 22:33:29\ntags:\n  - postman\ncategories:\n  - postman\n---\n\n## 什么是返回？\n响应数据是发送请求后经过服务器处理后返回的结果，响应是由三部分组成，分别是状态行、响应头、响应体。 <!-- more --> 我们来看下[postman](https://so.csdn.net/so/search?q=postman)的响应数据展示 \n\n![百度搜索](/img/blog/postman/05/05-01.png)\n\n在postman中的响应数据展示：\n状态行：Status：200 OK\n响应头：Headers + Cookies，需要注意的是Cookies是包含在响应头中的，但是为了明显，工具会分开显示\n响应体：Body\n\n## 返回测试什么？\n那么这些数据对我们做接口测试有什么作用呢 ？\nBody和Status是我们做接口测试的重点，一般来说我们都会验证响应体中的数据和响应状态码\nTest Results 是我们编写断言后，可以查看断言的执行结果 ，所以这个对我们也很有用 。\nTime 和Size 是我们做性能测试时，可以根据这俩个参数来对所测接口的性能做一个简单的判断。\n\n## 返回里有什么？\n接下来我们再来关注下Body中的几个显示主题，分别是：Pretty，Raw，Preview .\n![百度搜索](/img/blog/postman/05/05-02.png)\n\nPretty:翻译成中文就是漂亮 ， 也就是说返回的Body数据在这个标签中查看 ，都是经过格式化的，格式化后的数据看起来更加直观，所以postman默认展示的也是这个选项。比如返回html页面，它会经过格式化成HTML格式后展示，比如返回json，那么也会格式化成json格式展示 。\n\n需要说明的是，我们所测的接口多会返回json,这时我们看json数据时，只需要点击HTML后的小三角，选择JSON即可。\n\nRaw：翻译成中文未经过加工的，也就是原始数据 ，原始数据一般都是本文格式的，未经过格式化处理的，一般在抓包工具中都有这个选项 。\n\nPreview：翻译成中文就是预览，这个选项一般对返回HTML的页面效果特别明显，如请求百度后返回结果，点击这个选项后就直接能查看到的页面 ，如下图 。同时这个选项和浏览器抓包中的Preview也是一样的 。\n![百度搜索](/img/blog/postman/05/05-03.png)","slug":"Postman/〖postman〗接口测试05-响应数据解析","published":1,"updated":"2022-01-10T14:33:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3x7001tn4ep2g2l6cym","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"什么是返回？\"><a href=\"#什么是返回？\" class=\"headerlink\" title=\"什么是返回？\"></a>什么是返回？</h2><p>响应数据是发送请求后经过服务器处理后返回的结果，响应是由三部分组成，分别是状态行、响应头、响应体。 <a id=\"more\"></a> 我们来看下<a href=\"https://so.csdn.net/so/search?q=postman\" target=\"_blank\" rel=\"noopener\">postman</a>的响应数据展示 </p>\n<p><img src=\"/img/blog/postman/05/05-01.png\" alt=\"百度搜索\"></p>\n<p>在postman中的响应数据展示：<br>状态行：Status：200 OK<br>响应头：Headers + Cookies，需要注意的是Cookies是包含在响应头中的，但是为了明显，工具会分开显示<br>响应体：Body</p>\n<h2 id=\"返回测试什么？\"><a href=\"#返回测试什么？\" class=\"headerlink\" title=\"返回测试什么？\"></a>返回测试什么？</h2><p>那么这些数据对我们做接口测试有什么作用呢 ？<br>Body和Status是我们做接口测试的重点，一般来说我们都会验证响应体中的数据和响应状态码<br>Test Results 是我们编写断言后，可以查看断言的执行结果 ，所以这个对我们也很有用 。<br>Time 和Size 是我们做性能测试时，可以根据这俩个参数来对所测接口的性能做一个简单的判断。</p>\n<h2 id=\"返回里有什么？\"><a href=\"#返回里有什么？\" class=\"headerlink\" title=\"返回里有什么？\"></a>返回里有什么？</h2><p>接下来我们再来关注下Body中的几个显示主题，分别是：Pretty，Raw，Preview .<br><img src=\"/img/blog/postman/05/05-02.png\" alt=\"百度搜索\"></p>\n<p>Pretty:翻译成中文就是漂亮 ， 也就是说返回的Body数据在这个标签中查看 ，都是经过格式化的，格式化后的数据看起来更加直观，所以postman默认展示的也是这个选项。比如返回html页面，它会经过格式化成HTML格式后展示，比如返回json，那么也会格式化成json格式展示 。</p>\n<p>需要说明的是，我们所测的接口多会返回json,这时我们看json数据时，只需要点击HTML后的小三角，选择JSON即可。</p>\n<p>Raw：翻译成中文未经过加工的，也就是原始数据 ，原始数据一般都是本文格式的，未经过格式化处理的，一般在抓包工具中都有这个选项 。</p>\n<p>Preview：翻译成中文就是预览，这个选项一般对返回HTML的页面效果特别明显，如请求百度后返回结果，点击这个选项后就直接能查看到的页面 ，如下图 。同时这个选项和浏览器抓包中的Preview也是一样的 。<br><img src=\"/img/blog/postman/05/05-03.png\" alt=\"百度搜索\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是返回？\"><a href=\"#什么是返回？\" class=\"headerlink\" title=\"什么是返回？\"></a>什么是返回？</h2><p>响应数据是发送请求后经过服务器处理后返回的结果，响应是由三部分组成，分别是状态行、响应头、响应体。","more":"我们来看下<a href=\"https://so.csdn.net/so/search?q=postman\" target=\"_blank\" rel=\"noopener\">postman</a>的响应数据展示 </p>\n<p><img src=\"/img/blog/postman/05/05-01.png\" alt=\"百度搜索\"></p>\n<p>在postman中的响应数据展示：<br>状态行：Status：200 OK<br>响应头：Headers + Cookies，需要注意的是Cookies是包含在响应头中的，但是为了明显，工具会分开显示<br>响应体：Body</p>\n<h2 id=\"返回测试什么？\"><a href=\"#返回测试什么？\" class=\"headerlink\" title=\"返回测试什么？\"></a>返回测试什么？</h2><p>那么这些数据对我们做接口测试有什么作用呢 ？<br>Body和Status是我们做接口测试的重点，一般来说我们都会验证响应体中的数据和响应状态码<br>Test Results 是我们编写断言后，可以查看断言的执行结果 ，所以这个对我们也很有用 。<br>Time 和Size 是我们做性能测试时，可以根据这俩个参数来对所测接口的性能做一个简单的判断。</p>\n<h2 id=\"返回里有什么？\"><a href=\"#返回里有什么？\" class=\"headerlink\" title=\"返回里有什么？\"></a>返回里有什么？</h2><p>接下来我们再来关注下Body中的几个显示主题，分别是：Pretty，Raw，Preview .<br><img src=\"/img/blog/postman/05/05-02.png\" alt=\"百度搜索\"></p>\n<p>Pretty:翻译成中文就是漂亮 ， 也就是说返回的Body数据在这个标签中查看 ，都是经过格式化的，格式化后的数据看起来更加直观，所以postman默认展示的也是这个选项。比如返回html页面，它会经过格式化成HTML格式后展示，比如返回json，那么也会格式化成json格式展示 。</p>\n<p>需要说明的是，我们所测的接口多会返回json,这时我们看json数据时，只需要点击HTML后的小三角，选择JSON即可。</p>\n<p>Raw：翻译成中文未经过加工的，也就是原始数据 ，原始数据一般都是本文格式的，未经过格式化处理的，一般在抓包工具中都有这个选项 。</p>\n<p>Preview：翻译成中文就是预览，这个选项一般对返回HTML的页面效果特别明显，如请求百度后返回结果，点击这个选项后就直接能查看到的页面 ，如下图 。同时这个选项和浏览器抓包中的Preview也是一样的 。<br><img src=\"/img/blog/postman/05/05-03.png\" alt=\"百度搜索\"></p>"},{"title":"〖postman〗接口测试06-用例管理（Collection）（Collection）","abbrlink":"b8685e49","date":"2022-01-11T15:39:50.000Z","_content":"\n## 怎么解决用例满天飞的局面？\n\n当我们对一个或多个系统中的很多用例进行维护时，首先想到的就是对用例进行分类管理，同时我们还要对这些做回归测试 。那么postman也提供了这样一个功能，就是Collection 。通过这个Collection就可以满足我们的上面说的需求。 <!-- more --> \n\n### 先对Collection功能的使用场景做个简单总结 。\n\n#### 用例分类管理，方便后期维护\n\n#### 可以进行批量用例回归测试 。\n\n## 那么Collection是如何去管理用例的呢 ？ \n先想象我们要测试一个系统，系统下有多个模块，每个模块下有很多的被测接口用例 。那么基于这个场景，我们来通过Collection来进行实现：\n\n#### 1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）\n\n![create](/img/blog/postman/06/06-01.png)\n\n#### 2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）\n   ![create](/img/blog/postman/06/06-02.png)\n\n#### 3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。\n\n![create](/img/blog/postman/06/06-03.png)\n\n那么通过以上三个步骤，达到的效果就是如图所示：\n![create](/img/blog/postman/06/06-04.png)\n\n\n总结，通过上面的操作，我们实现了一个最简单的demo模型。但实际上，这个Collection的用处非常广，很多功能的使用都必须先创建Collection，比如用例的批量执行，Mock ，接口文档等功能 。\n","source":"_posts/Postman/〖postman〗接口测试06-用例管理（Collection）.md","raw":"---\ntitle: 〖postman〗接口测试06-用例管理（Collection）（Collection）\nabbrlink: b8685e49\ndate: 2022-01-11 23:39:50\ntags:\n - postman\ncategories:\n  - postman\n---\n\n## 怎么解决用例满天飞的局面？\n\n当我们对一个或多个系统中的很多用例进行维护时，首先想到的就是对用例进行分类管理，同时我们还要对这些做回归测试 。那么postman也提供了这样一个功能，就是Collection 。通过这个Collection就可以满足我们的上面说的需求。 <!-- more --> \n\n### 先对Collection功能的使用场景做个简单总结 。\n\n#### 用例分类管理，方便后期维护\n\n#### 可以进行批量用例回归测试 。\n\n## 那么Collection是如何去管理用例的呢 ？ \n先想象我们要测试一个系统，系统下有多个模块，每个模块下有很多的被测接口用例 。那么基于这个场景，我们来通过Collection来进行实现：\n\n#### 1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）\n\n![create](/img/blog/postman/06/06-01.png)\n\n#### 2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）\n   ![create](/img/blog/postman/06/06-02.png)\n\n#### 3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。\n\n![create](/img/blog/postman/06/06-03.png)\n\n那么通过以上三个步骤，达到的效果就是如图所示：\n![create](/img/blog/postman/06/06-04.png)\n\n\n总结，通过上面的操作，我们实现了一个最简单的demo模型。但实际上，这个Collection的用处非常广，很多功能的使用都必须先创建Collection，比如用例的批量执行，Mock ，接口文档等功能 。\n","slug":"Postman/〖postman〗接口测试06-用例管理（Collection）","published":1,"updated":"2022-01-11T15:39:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3x8001xn4epfcbh65zo","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"怎么解决用例满天飞的局面？\"><a href=\"#怎么解决用例满天飞的局面？\" class=\"headerlink\" title=\"怎么解决用例满天飞的局面？\"></a>怎么解决用例满天飞的局面？</h2><p>当我们对一个或多个系统中的很多用例进行维护时，首先想到的就是对用例进行分类管理，同时我们还要对这些做回归测试 。那么postman也提供了这样一个功能，就是Collection 。通过这个Collection就可以满足我们的上面说的需求。 <a id=\"more\"></a> </p>\n<h3 id=\"先对Collection功能的使用场景做个简单总结-。\"><a href=\"#先对Collection功能的使用场景做个简单总结-。\" class=\"headerlink\" title=\"先对Collection功能的使用场景做个简单总结 。\"></a>先对Collection功能的使用场景做个简单总结 。</h3><h4 id=\"用例分类管理，方便后期维护\"><a href=\"#用例分类管理，方便后期维护\" class=\"headerlink\" title=\"用例分类管理，方便后期维护\"></a>用例分类管理，方便后期维护</h4><h4 id=\"可以进行批量用例回归测试-。\"><a href=\"#可以进行批量用例回归测试-。\" class=\"headerlink\" title=\"可以进行批量用例回归测试 。\"></a>可以进行批量用例回归测试 。</h4><h2 id=\"那么Collection是如何去管理用例的呢-？\"><a href=\"#那么Collection是如何去管理用例的呢-？\" class=\"headerlink\" title=\"那么Collection是如何去管理用例的呢 ？\"></a>那么Collection是如何去管理用例的呢 ？</h2><p>先想象我们要测试一个系统，系统下有多个模块，每个模块下有很多的被测接口用例 。那么基于这个场景，我们来通过Collection来进行实现：</p>\n<h4 id=\"1-点击Collection，点击-New-Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）\"><a href=\"#1-点击Collection，点击-New-Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）\" class=\"headerlink\" title=\"1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）\"></a>1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）</h4><p><img src=\"/img/blog/postman/06/06-01.png\" alt=\"create\"></p>\n<h4 id=\"2-选中新建的Collection右键，点击Add-Folder-，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）\"><a href=\"#2-选中新建的Collection右键，点击Add-Folder-，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）\" class=\"headerlink\" title=\"2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）\"></a>2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）</h4><p>   <img src=\"/img/blog/postman/06/06-02.png\" alt=\"create\"></p>\n<h4 id=\"3-选中新建的Folder，点击Add-Request-，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例-。\"><a href=\"#3-选中新建的Folder，点击Add-Request-，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例-。\" class=\"headerlink\" title=\"3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。\"></a>3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。</h4><p><img src=\"/img/blog/postman/06/06-03.png\" alt=\"create\"></p>\n<p>那么通过以上三个步骤，达到的效果就是如图所示：<br><img src=\"/img/blog/postman/06/06-04.png\" alt=\"create\"></p>\n<p>总结，通过上面的操作，我们实现了一个最简单的demo模型。但实际上，这个Collection的用处非常广，很多功能的使用都必须先创建Collection，比如用例的批量执行，Mock ，接口文档等功能 。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"怎么解决用例满天飞的局面？\"><a href=\"#怎么解决用例满天飞的局面？\" class=\"headerlink\" title=\"怎么解决用例满天飞的局面？\"></a>怎么解决用例满天飞的局面？</h2><p>当我们对一个或多个系统中的很多用例进行维护时，首先想到的就是对用例进行分类管理，同时我们还要对这些做回归测试 。那么postman也提供了这样一个功能，就是Collection 。通过这个Collection就可以满足我们的上面说的需求。","more":"</p>\n<h3 id=\"先对Collection功能的使用场景做个简单总结-。\"><a href=\"#先对Collection功能的使用场景做个简单总结-。\" class=\"headerlink\" title=\"先对Collection功能的使用场景做个简单总结 。\"></a>先对Collection功能的使用场景做个简单总结 。</h3><h4 id=\"用例分类管理，方便后期维护\"><a href=\"#用例分类管理，方便后期维护\" class=\"headerlink\" title=\"用例分类管理，方便后期维护\"></a>用例分类管理，方便后期维护</h4><h4 id=\"可以进行批量用例回归测试-。\"><a href=\"#可以进行批量用例回归测试-。\" class=\"headerlink\" title=\"可以进行批量用例回归测试 。\"></a>可以进行批量用例回归测试 。</h4><h2 id=\"那么Collection是如何去管理用例的呢-？\"><a href=\"#那么Collection是如何去管理用例的呢-？\" class=\"headerlink\" title=\"那么Collection是如何去管理用例的呢 ？\"></a>那么Collection是如何去管理用例的呢 ？</h2><p>先想象我们要测试一个系统，系统下有多个模块，每个模块下有很多的被测接口用例 。那么基于这个场景，我们来通过Collection来进行实现：</p>\n<h4 id=\"1-点击Collection，点击-New-Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）\"><a href=\"#1-点击Collection，点击-New-Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）\" class=\"headerlink\" title=\"1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）\"></a>1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）</h4><p><img src=\"/img/blog/postman/06/06-01.png\" alt=\"create\"></p>\n<h4 id=\"2-选中新建的Collection右键，点击Add-Folder-，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）\"><a href=\"#2-选中新建的Collection右键，点击Add-Folder-，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）\" class=\"headerlink\" title=\"2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）\"></a>2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）</h4><p>   <img src=\"/img/blog/postman/06/06-02.png\" alt=\"create\"></p>\n<h4 id=\"3-选中新建的Folder，点击Add-Request-，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例-。\"><a href=\"#3-选中新建的Folder，点击Add-Request-，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例-。\" class=\"headerlink\" title=\"3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。\"></a>3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。</h4><p><img src=\"/img/blog/postman/06/06-03.png\" alt=\"create\"></p>\n<p>那么通过以上三个步骤，达到的效果就是如图所示：<br><img src=\"/img/blog/postman/06/06-04.png\" alt=\"create\"></p>\n<p>总结，通过上面的操作，我们实现了一个最简单的demo模型。但实际上，这个Collection的用处非常广，很多功能的使用都必须先创建Collection，比如用例的批量执行，Mock ，接口文档等功能 。</p>"},{"title":"〖postman〗接口测试07-批量执行用例","abbrlink":"c4b6dbb9","date":"2022-01-12T15:05:36.000Z","_content":"\n>  当我们在一个Collection中编写了很多的接口测试用例，想一起执行这批用例，在postman中是如何操作呢 ？ <!-- more --> \n\n# 实现步骤：\n\n## 1. 选中一个Collection，点击右三角，在弹出的界面点击RUN\n ![img](/img/blog/postman/07/07-01.png) \n\n\n## 2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选上.\n ![img](/img/blog/postman/07/07-02.png) \n\n## 3. 点击界面下方的RUN Collection，就会对Collection选中的所有测试用例运行 。\n\n ![img](/img/blog/postman/07/07-03.png) \n\n### 对上面的几个红框内的功能进行简单说明：\n断言统计：左上角的俩个0是统计当前Collection中断言成功的执行数和失败的执行数，如果没有编写断言默认都为0 。\n\n- Run Summary: 运行结果总览，点击它可以看到每个请求中具体的测试断言详细信息 。\n\n- Export Result：导出运行结果，默认导出的结果json文件 。\n\n- Retry: 重新运行，点击它会把该Collection重新运行一遍\n\n- New：返回到Runner，可以重新选择用例的组合 。\n\n总体来说，这个功能主要是用于对一个Collection中的所有用例或部分用例进行批量运行，已达到手工回归测试的目的。\n","source":"_posts/Postman/〖postman〗接口测试07-批量执行用例.md","raw":"---\ntitle: 〖postman〗接口测试07-批量执行用例\nabbrlink: c4b6dbb9\ndate: 2022-01-12 23:05:36\ntags:\n - postman\ncategories:\n  - postman\n---\n\n>  当我们在一个Collection中编写了很多的接口测试用例，想一起执行这批用例，在postman中是如何操作呢 ？ <!-- more --> \n\n# 实现步骤：\n\n## 1. 选中一个Collection，点击右三角，在弹出的界面点击RUN\n ![img](/img/blog/postman/07/07-01.png) \n\n\n## 2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选上.\n ![img](/img/blog/postman/07/07-02.png) \n\n## 3. 点击界面下方的RUN Collection，就会对Collection选中的所有测试用例运行 。\n\n ![img](/img/blog/postman/07/07-03.png) \n\n### 对上面的几个红框内的功能进行简单说明：\n断言统计：左上角的俩个0是统计当前Collection中断言成功的执行数和失败的执行数，如果没有编写断言默认都为0 。\n\n- Run Summary: 运行结果总览，点击它可以看到每个请求中具体的测试断言详细信息 。\n\n- Export Result：导出运行结果，默认导出的结果json文件 。\n\n- Retry: 重新运行，点击它会把该Collection重新运行一遍\n\n- New：返回到Runner，可以重新选择用例的组合 。\n\n总体来说，这个功能主要是用于对一个Collection中的所有用例或部分用例进行批量运行，已达到手工回归测试的目的。\n","slug":"Postman/〖postman〗接口测试07-批量执行用例","published":1,"updated":"2022-01-12T15:05:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3x9001zn4epg0ex94sc","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p> 当我们在一个Collection中编写了很多的接口测试用例，想一起执行这批用例，在postman中是如何操作呢 ？ <a id=\"more\"></a> </p>\n</blockquote>\n<h1 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a>实现步骤：</h1><h2 id=\"1-选中一个Collection，点击右三角，在弹出的界面点击RUN\"><a href=\"#1-选中一个Collection，点击右三角，在弹出的界面点击RUN\" class=\"headerlink\" title=\"1. 选中一个Collection，点击右三角，在弹出的界面点击RUN\"></a>1. 选中一个Collection，点击右三角，在弹出的界面点击RUN</h2><p> <img src=\"/img/blog/postman/07/07-01.png\" alt=\"img\"> </p>\n<h2 id=\"2-这是会弹出一个叫Collection-Runner的界面，默认会把Collection中的所有用例选上\"><a href=\"#2-这是会弹出一个叫Collection-Runner的界面，默认会把Collection中的所有用例选上\" class=\"headerlink\" title=\"2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选上.\"></a>2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选上.</h2><p> <img src=\"/img/blog/postman/07/07-02.png\" alt=\"img\"> </p>\n<h2 id=\"3-点击界面下方的RUN-Collection，就会对Collection选中的所有测试用例运行-。\"><a href=\"#3-点击界面下方的RUN-Collection，就会对Collection选中的所有测试用例运行-。\" class=\"headerlink\" title=\"3. 点击界面下方的RUN Collection，就会对Collection选中的所有测试用例运行 。\"></a>3. 点击界面下方的RUN Collection，就会对Collection选中的所有测试用例运行 。</h2><p> <img src=\"/img/blog/postman/07/07-03.png\" alt=\"img\"> </p>\n<h3 id=\"对上面的几个红框内的功能进行简单说明：\"><a href=\"#对上面的几个红框内的功能进行简单说明：\" class=\"headerlink\" title=\"对上面的几个红框内的功能进行简单说明：\"></a>对上面的几个红框内的功能进行简单说明：</h3><p>断言统计：左上角的俩个0是统计当前Collection中断言成功的执行数和失败的执行数，如果没有编写断言默认都为0 。</p>\n<ul>\n<li><p>Run Summary: 运行结果总览，点击它可以看到每个请求中具体的测试断言详细信息 。</p>\n</li>\n<li><p>Export Result：导出运行结果，默认导出的结果json文件 。</p>\n</li>\n<li><p>Retry: 重新运行，点击它会把该Collection重新运行一遍</p>\n</li>\n<li><p>New：返回到Runner，可以重新选择用例的组合 。</p>\n</li>\n</ul>\n<p>总体来说，这个功能主要是用于对一个Collection中的所有用例或部分用例进行批量运行，已达到手工回归测试的目的。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p> 当我们在一个Collection中编写了很多的接口测试用例，想一起执行这批用例，在postman中是如何操作呢 ？","more":"</p>\n</blockquote>\n<h1 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a>实现步骤：</h1><h2 id=\"1-选中一个Collection，点击右三角，在弹出的界面点击RUN\"><a href=\"#1-选中一个Collection，点击右三角，在弹出的界面点击RUN\" class=\"headerlink\" title=\"1. 选中一个Collection，点击右三角，在弹出的界面点击RUN\"></a>1. 选中一个Collection，点击右三角，在弹出的界面点击RUN</h2><p> <img src=\"/img/blog/postman/07/07-01.png\" alt=\"img\"> </p>\n<h2 id=\"2-这是会弹出一个叫Collection-Runner的界面，默认会把Collection中的所有用例选上\"><a href=\"#2-这是会弹出一个叫Collection-Runner的界面，默认会把Collection中的所有用例选上\" class=\"headerlink\" title=\"2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选上.\"></a>2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选上.</h2><p> <img src=\"/img/blog/postman/07/07-02.png\" alt=\"img\"> </p>\n<h2 id=\"3-点击界面下方的RUN-Collection，就会对Collection选中的所有测试用例运行-。\"><a href=\"#3-点击界面下方的RUN-Collection，就会对Collection选中的所有测试用例运行-。\" class=\"headerlink\" title=\"3. 点击界面下方的RUN Collection，就会对Collection选中的所有测试用例运行 。\"></a>3. 点击界面下方的RUN Collection，就会对Collection选中的所有测试用例运行 。</h2><p> <img src=\"/img/blog/postman/07/07-03.png\" alt=\"img\"> </p>\n<h3 id=\"对上面的几个红框内的功能进行简单说明：\"><a href=\"#对上面的几个红框内的功能进行简单说明：\" class=\"headerlink\" title=\"对上面的几个红框内的功能进行简单说明：\"></a>对上面的几个红框内的功能进行简单说明：</h3><p>断言统计：左上角的俩个0是统计当前Collection中断言成功的执行数和失败的执行数，如果没有编写断言默认都为0 。</p>\n<ul>\n<li><p>Run Summary: 运行结果总览，点击它可以看到每个请求中具体的测试断言详细信息 。</p>\n</li>\n<li><p>Export Result：导出运行结果，默认导出的结果json文件 。</p>\n</li>\n<li><p>Retry: 重新运行，点击它会把该Collection重新运行一遍</p>\n</li>\n<li><p>New：返回到Runner，可以重新选择用例的组合 。</p>\n</li>\n</ul>\n<p>总体来说，这个功能主要是用于对一个Collection中的所有用例或部分用例进行批量运行，已达到手工回归测试的目的。</p>"},{"title":"〖postman〗接口测试08-测试断言","abbrlink":"2ab40ef8","date":"2022-01-13T14:28:02.000Z","_content":"\n> 如果没有断言这个功能，那我们的测试就只能是通过我们人工比较预期结果和实际结果是否一致。有了这个功能就为我们做自动化提供了条件，postman中的断言也是非常方便的 。 <!-- more --> \n\n# 我们先来了解下postman断言的一些特点 ，具体如下\n\n-  断言编写位置：Tests标签\n\n\n-  断言所用语言：JavaScript\n\n\n-  断言执行顺序：在响应体数据返回后执行 。\n\n\n-  断言执行结果查看：Test Results\n\n\n在上面我们介绍到，编写的断言代码是JavaScript，那如果不会写怎么办 ？ 不用担心，因为postman已经给我们内置了一些常用的断言 。用的时候，只需从右侧点击其中一个断言，就会在文本框中自动生成对应断言代码块 。\n\n ![img](/img/blog/postman/08/08-01.png) \n\n# 接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。\n\n本次使用公开天气api接口演示「http://doc.tianqiapi.com/」\n\n\n状态行中又包括状态码，状态消息 。在postman也可以对这俩个进行断言\n## 状态行中的断言：\n\n### 断言状态码：Status code: code is 200\n```javascript\npm.test(\"断言相应状态码为200\", function () {\n    pm.response.to.have.status(200);\n});\t\n```\n### 断言状态消息：Status code：code name has string\n```javascript\npm.test(\"断言响应状态消息包含OK\", function () {\n    pm.response.to.have.status(\"OK\");\n});\n```\n## 响应头中的断言\n\n### 断言响应头中包含：Response headers:Content-Type header check\n```javascript\npm.test(\"断言响应头存在'Content-Type'\", function () {\n    pm.response.to.have.header(\"Content-Type\"); \n});\n```\n## 断言响应体(重点)\n\n### 断言响应体中包含XXX字符串：Response body:Contains string\n```javascript\npm.test(\"断言返回内容包含该文本\", function () {undefined\n    pm.expect(pm.response.text()).to.include(\"101010100\");\n});   \n//注解\n//pm.expect(pm.response.text()).to.include(\"string\")      获取响应文本中包含string\n```\n### 断言响应体等于XXX字符串：Response body : is equal to a string\n\n```javascript\npm.test(\"Body is correct\", function () {\n    pm.response.to.have.body(\"response_body_string\");\n});\n//注解\n//pm.response.to.have.body(\"response_body_string\");   获取响应体等于response_body_string\n```\n### 断言响应体(json)中某个键名对应的值：Response body : JSON value check\n\n```javascript\npm.test(\"断言相应城市为北京\", function () {\n    var jsonData = pm.response.json();\n    pm.expect(jsonData.city).to.eql(\"北京\");\n});\n//注解\n//var jsonData = pm.response.json()   获取响应体，以json显示，赋值给jsonData .注意：该响应体必须返会是的json，否则会报错\n//pm.expect(jsonData.value).to.eql(\"北京\")  获取jsonData中键名为value的值，然后和\"北京\"进行比较\n```\n### 响应时间(一般用于性能测试)\n\n断言响应时间：Response time is less than 200ms\n```javascript\npm.test(\"Response time is less than 200ms\", function () {\n    pm.expect(pm.response.responseTime).to.be.below(200);   //断言响应时间<200ms\n});\n```\n### 案例说明：\n\n针对以下接口返回的数据进行断言：\n```json\n{\n    \"cityid\": \"101010100\",\n    \"city\": \"北京\",\n    \"update_time\": \"22:34\",\n    \"wea\": \"晴\",\n    \"wea_img\": \"qing\",\n    \"tem\": \"-2\",\n    \"tem_day\": \"3\",\n    \"tem_night\": \"-7\",\n    \"win\": \"南风\",\n    \"win_speed\": \"2级\",\n    \"win_meter\": \"5km/h\",\n    \"air\": \"43\"\n}\n```\n- 断言响应状态码为200\n- 断言city等于济南\n- 断言update_time包含2020-04-17\n\n  ![img](/img/blog/postman/08/08-02.png) \n\n>  总结，整体来说，如果用postman做接口测试，这个断言功能必不可少，其中我们常断言的响应体包含和JSON这俩个断言又是重重之重。","source":"_posts/Postman/〖postman〗接口测试08-测试断言.md","raw":"---\ntitle: 〖postman〗接口测试08-测试断言\nabbrlink: 2ab40ef8\ndate: 2022-01-13 22:28:02\ntags:\n - postman\ncategories:\n  - postman\n---\n\n> 如果没有断言这个功能，那我们的测试就只能是通过我们人工比较预期结果和实际结果是否一致。有了这个功能就为我们做自动化提供了条件，postman中的断言也是非常方便的 。 <!-- more --> \n\n# 我们先来了解下postman断言的一些特点 ，具体如下\n\n-  断言编写位置：Tests标签\n\n\n-  断言所用语言：JavaScript\n\n\n-  断言执行顺序：在响应体数据返回后执行 。\n\n\n-  断言执行结果查看：Test Results\n\n\n在上面我们介绍到，编写的断言代码是JavaScript，那如果不会写怎么办 ？ 不用担心，因为postman已经给我们内置了一些常用的断言 。用的时候，只需从右侧点击其中一个断言，就会在文本框中自动生成对应断言代码块 。\n\n ![img](/img/blog/postman/08/08-01.png) \n\n# 接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。\n\n本次使用公开天气api接口演示「http://doc.tianqiapi.com/」\n\n\n状态行中又包括状态码，状态消息 。在postman也可以对这俩个进行断言\n## 状态行中的断言：\n\n### 断言状态码：Status code: code is 200\n```javascript\npm.test(\"断言相应状态码为200\", function () {\n    pm.response.to.have.status(200);\n});\t\n```\n### 断言状态消息：Status code：code name has string\n```javascript\npm.test(\"断言响应状态消息包含OK\", function () {\n    pm.response.to.have.status(\"OK\");\n});\n```\n## 响应头中的断言\n\n### 断言响应头中包含：Response headers:Content-Type header check\n```javascript\npm.test(\"断言响应头存在'Content-Type'\", function () {\n    pm.response.to.have.header(\"Content-Type\"); \n});\n```\n## 断言响应体(重点)\n\n### 断言响应体中包含XXX字符串：Response body:Contains string\n```javascript\npm.test(\"断言返回内容包含该文本\", function () {undefined\n    pm.expect(pm.response.text()).to.include(\"101010100\");\n});   \n//注解\n//pm.expect(pm.response.text()).to.include(\"string\")      获取响应文本中包含string\n```\n### 断言响应体等于XXX字符串：Response body : is equal to a string\n\n```javascript\npm.test(\"Body is correct\", function () {\n    pm.response.to.have.body(\"response_body_string\");\n});\n//注解\n//pm.response.to.have.body(\"response_body_string\");   获取响应体等于response_body_string\n```\n### 断言响应体(json)中某个键名对应的值：Response body : JSON value check\n\n```javascript\npm.test(\"断言相应城市为北京\", function () {\n    var jsonData = pm.response.json();\n    pm.expect(jsonData.city).to.eql(\"北京\");\n});\n//注解\n//var jsonData = pm.response.json()   获取响应体，以json显示，赋值给jsonData .注意：该响应体必须返会是的json，否则会报错\n//pm.expect(jsonData.value).to.eql(\"北京\")  获取jsonData中键名为value的值，然后和\"北京\"进行比较\n```\n### 响应时间(一般用于性能测试)\n\n断言响应时间：Response time is less than 200ms\n```javascript\npm.test(\"Response time is less than 200ms\", function () {\n    pm.expect(pm.response.responseTime).to.be.below(200);   //断言响应时间<200ms\n});\n```\n### 案例说明：\n\n针对以下接口返回的数据进行断言：\n```json\n{\n    \"cityid\": \"101010100\",\n    \"city\": \"北京\",\n    \"update_time\": \"22:34\",\n    \"wea\": \"晴\",\n    \"wea_img\": \"qing\",\n    \"tem\": \"-2\",\n    \"tem_day\": \"3\",\n    \"tem_night\": \"-7\",\n    \"win\": \"南风\",\n    \"win_speed\": \"2级\",\n    \"win_meter\": \"5km/h\",\n    \"air\": \"43\"\n}\n```\n- 断言响应状态码为200\n- 断言city等于济南\n- 断言update_time包含2020-04-17\n\n  ![img](/img/blog/postman/08/08-02.png) \n\n>  总结，整体来说，如果用postman做接口测试，这个断言功能必不可少，其中我们常断言的响应体包含和JSON这俩个断言又是重重之重。","slug":"Postman/〖postman〗接口测试08-测试断言","published":1,"updated":"2022-01-13T14:28:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xa0023n4ep2he3auta","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>如果没有断言这个功能，那我们的测试就只能是通过我们人工比较预期结果和实际结果是否一致。有了这个功能就为我们做自动化提供了条件，postman中的断言也是非常方便的 。 <a id=\"more\"></a> </p>\n</blockquote>\n<h1 id=\"我们先来了解下postman断言的一些特点-，具体如下\"><a href=\"#我们先来了解下postman断言的一些特点-，具体如下\" class=\"headerlink\" title=\"我们先来了解下postman断言的一些特点 ，具体如下\"></a>我们先来了解下postman断言的一些特点 ，具体如下</h1><ul>\n<li>断言编写位置：Tests标签</li>\n</ul>\n<ul>\n<li>断言所用语言：JavaScript</li>\n</ul>\n<ul>\n<li>断言执行顺序：在响应体数据返回后执行 。</li>\n</ul>\n<ul>\n<li>断言执行结果查看：Test Results</li>\n</ul>\n<p>在上面我们介绍到，编写的断言代码是JavaScript，那如果不会写怎么办 ？ 不用担心，因为postman已经给我们内置了一些常用的断言 。用的时候，只需从右侧点击其中一个断言，就会在文本框中自动生成对应断言代码块 。</p>\n<p> <img src=\"/img/blog/postman/08/08-01.png\" alt=\"img\"> </p>\n<h1 id=\"接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。\"><a href=\"#接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。\" class=\"headerlink\" title=\"接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。\"></a>接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。</h1><p>本次使用公开天气api接口演示「<a href=\"http://doc.tianqiapi.com/」\" target=\"_blank\" rel=\"noopener\">http://doc.tianqiapi.com/」</a></p>\n<p>状态行中又包括状态码，状态消息 。在postman也可以对这俩个进行断言</p>\n<h2 id=\"状态行中的断言：\"><a href=\"#状态行中的断言：\" class=\"headerlink\" title=\"状态行中的断言：\"></a>状态行中的断言：</h2><h3 id=\"断言状态码：Status-code-code-is-200\"><a href=\"#断言状态码：Status-code-code-is-200\" class=\"headerlink\" title=\"断言状态码：Status code: code is 200\"></a>断言状态码：Status code: code is 200</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"断言相应状态码为200\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pm.response.to.have.status(<span class=\"number\">200</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"断言状态消息：Status-code：code-name-has-string\"><a href=\"#断言状态消息：Status-code：code-name-has-string\" class=\"headerlink\" title=\"断言状态消息：Status code：code name has string\"></a>断言状态消息：Status code：code name has string</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"断言响应状态消息包含OK\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pm.response.to.have.status(<span class=\"string\">\"OK\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"响应头中的断言\"><a href=\"#响应头中的断言\" class=\"headerlink\" title=\"响应头中的断言\"></a>响应头中的断言</h2><h3 id=\"断言响应头中包含：Response-headers-Content-Type-header-check\"><a href=\"#断言响应头中包含：Response-headers-Content-Type-header-check\" class=\"headerlink\" title=\"断言响应头中包含：Response headers:Content-Type header check\"></a>断言响应头中包含：Response headers:Content-Type header check</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"断言响应头存在'Content-Type'\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pm.response.to.have.header(<span class=\"string\">\"Content-Type\"</span>); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"断言响应体-重点\"><a href=\"#断言响应体-重点\" class=\"headerlink\" title=\"断言响应体(重点)\"></a>断言响应体(重点)</h2><h3 id=\"断言响应体中包含XXX字符串：Response-body-Contains-string\"><a href=\"#断言响应体中包含XXX字符串：Response-body-Contains-string\" class=\"headerlink\" title=\"断言响应体中包含XXX字符串：Response body:Contains string\"></a>断言响应体中包含XXX字符串：Response body:Contains string</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"断言返回内容包含该文本\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"literal\">undefined</span></span><br><span class=\"line\">    pm.expect(pm.response.text()).to.include(<span class=\"string\">\"101010100\"</span>);</span><br><span class=\"line\">&#125;);   </span><br><span class=\"line\"><span class=\"comment\">//注解</span></span><br><span class=\"line\"><span class=\"comment\">//pm.expect(pm.response.text()).to.include(\"string\")      获取响应文本中包含string</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"断言响应体等于XXX字符串：Response-body-is-equal-to-a-string\"><a href=\"#断言响应体等于XXX字符串：Response-body-is-equal-to-a-string\" class=\"headerlink\" title=\"断言响应体等于XXX字符串：Response body : is equal to a string\"></a>断言响应体等于XXX字符串：Response body : is equal to a string</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"Body is correct\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pm.response.to.have.body(<span class=\"string\">\"response_body_string\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//注解</span></span><br><span class=\"line\"><span class=\"comment\">//pm.response.to.have.body(\"response_body_string\");   获取响应体等于response_body_string</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"断言响应体-json-中某个键名对应的值：Response-body-JSON-value-check\"><a href=\"#断言响应体-json-中某个键名对应的值：Response-body-JSON-value-check\" class=\"headerlink\" title=\"断言响应体(json)中某个键名对应的值：Response body : JSON value check\"></a>断言响应体(json)中某个键名对应的值：Response body : JSON value check</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"断言相应城市为北京\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> jsonData = pm.response.json();</span><br><span class=\"line\">    pm.expect(jsonData.city).to.eql(<span class=\"string\">\"北京\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//注解</span></span><br><span class=\"line\"><span class=\"comment\">//var jsonData = pm.response.json()   获取响应体，以json显示，赋值给jsonData .注意：该响应体必须返会是的json，否则会报错</span></span><br><span class=\"line\"><span class=\"comment\">//pm.expect(jsonData.value).to.eql(\"北京\")  获取jsonData中键名为value的值，然后和\"北京\"进行比较</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"响应时间-一般用于性能测试\"><a href=\"#响应时间-一般用于性能测试\" class=\"headerlink\" title=\"响应时间(一般用于性能测试)\"></a>响应时间(一般用于性能测试)</h3><p>断言响应时间：Response time is less than 200ms</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"Response time is less than 200ms\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pm.expect(pm.response.responseTime).to.be.below(<span class=\"number\">200</span>);   <span class=\"comment\">//断言响应时间&lt;200ms</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"案例说明：\"><a href=\"#案例说明：\" class=\"headerlink\" title=\"案例说明：\"></a>案例说明：</h3><p>针对以下接口返回的数据进行断言：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"cityid\"</span>: <span class=\"string\">\"101010100\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"北京\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"update_time\"</span>: <span class=\"string\">\"22:34\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"wea\"</span>: <span class=\"string\">\"晴\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"wea_img\"</span>: <span class=\"string\">\"qing\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"tem\"</span>: <span class=\"string\">\"-2\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"tem_day\"</span>: <span class=\"string\">\"3\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"tem_night\"</span>: <span class=\"string\">\"-7\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"win\"</span>: <span class=\"string\">\"南风\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"win_speed\"</span>: <span class=\"string\">\"2级\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"win_meter\"</span>: <span class=\"string\">\"5km/h\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"air\"</span>: <span class=\"string\">\"43\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>断言响应状态码为200</p>\n</li>\n<li><p>断言city等于济南</p>\n</li>\n<li><p>断言update_time包含2020-04-17</p>\n<p><img src=\"/img/blog/postman/08/08-02.png\" alt=\"img\"> </p>\n</li>\n</ul>\n<blockquote>\n<p> 总结，整体来说，如果用postman做接口测试，这个断言功能必不可少，其中我们常断言的响应体包含和JSON这俩个断言又是重重之重。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>如果没有断言这个功能，那我们的测试就只能是通过我们人工比较预期结果和实际结果是否一致。有了这个功能就为我们做自动化提供了条件，postman中的断言也是非常方便的 。","more":"</p>\n</blockquote>\n<h1 id=\"我们先来了解下postman断言的一些特点-，具体如下\"><a href=\"#我们先来了解下postman断言的一些特点-，具体如下\" class=\"headerlink\" title=\"我们先来了解下postman断言的一些特点 ，具体如下\"></a>我们先来了解下postman断言的一些特点 ，具体如下</h1><ul>\n<li>断言编写位置：Tests标签</li>\n</ul>\n<ul>\n<li>断言所用语言：JavaScript</li>\n</ul>\n<ul>\n<li>断言执行顺序：在响应体数据返回后执行 。</li>\n</ul>\n<ul>\n<li>断言执行结果查看：Test Results</li>\n</ul>\n<p>在上面我们介绍到，编写的断言代码是JavaScript，那如果不会写怎么办 ？ 不用担心，因为postman已经给我们内置了一些常用的断言 。用的时候，只需从右侧点击其中一个断言，就会在文本框中自动生成对应断言代码块 。</p>\n<p> <img src=\"/img/blog/postman/08/08-01.png\" alt=\"img\"> </p>\n<h1 id=\"接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。\"><a href=\"#接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。\" class=\"headerlink\" title=\"接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。\"></a>接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。</h1><p>本次使用公开天气api接口演示「<a href=\"http://doc.tianqiapi.com/」\" target=\"_blank\" rel=\"noopener\">http://doc.tianqiapi.com/」</a></p>\n<p>状态行中又包括状态码，状态消息 。在postman也可以对这俩个进行断言</p>\n<h2 id=\"状态行中的断言：\"><a href=\"#状态行中的断言：\" class=\"headerlink\" title=\"状态行中的断言：\"></a>状态行中的断言：</h2><h3 id=\"断言状态码：Status-code-code-is-200\"><a href=\"#断言状态码：Status-code-code-is-200\" class=\"headerlink\" title=\"断言状态码：Status code: code is 200\"></a>断言状态码：Status code: code is 200</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"断言相应状态码为200\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pm.response.to.have.status(<span class=\"number\">200</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"断言状态消息：Status-code：code-name-has-string\"><a href=\"#断言状态消息：Status-code：code-name-has-string\" class=\"headerlink\" title=\"断言状态消息：Status code：code name has string\"></a>断言状态消息：Status code：code name has string</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"断言响应状态消息包含OK\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pm.response.to.have.status(<span class=\"string\">\"OK\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"响应头中的断言\"><a href=\"#响应头中的断言\" class=\"headerlink\" title=\"响应头中的断言\"></a>响应头中的断言</h2><h3 id=\"断言响应头中包含：Response-headers-Content-Type-header-check\"><a href=\"#断言响应头中包含：Response-headers-Content-Type-header-check\" class=\"headerlink\" title=\"断言响应头中包含：Response headers:Content-Type header check\"></a>断言响应头中包含：Response headers:Content-Type header check</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"断言响应头存在'Content-Type'\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pm.response.to.have.header(<span class=\"string\">\"Content-Type\"</span>); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"断言响应体-重点\"><a href=\"#断言响应体-重点\" class=\"headerlink\" title=\"断言响应体(重点)\"></a>断言响应体(重点)</h2><h3 id=\"断言响应体中包含XXX字符串：Response-body-Contains-string\"><a href=\"#断言响应体中包含XXX字符串：Response-body-Contains-string\" class=\"headerlink\" title=\"断言响应体中包含XXX字符串：Response body:Contains string\"></a>断言响应体中包含XXX字符串：Response body:Contains string</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"断言返回内容包含该文本\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;<span class=\"literal\">undefined</span></span><br><span class=\"line\">    pm.expect(pm.response.text()).to.include(<span class=\"string\">\"101010100\"</span>);</span><br><span class=\"line\">&#125;);   </span><br><span class=\"line\"><span class=\"comment\">//注解</span></span><br><span class=\"line\"><span class=\"comment\">//pm.expect(pm.response.text()).to.include(\"string\")      获取响应文本中包含string</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"断言响应体等于XXX字符串：Response-body-is-equal-to-a-string\"><a href=\"#断言响应体等于XXX字符串：Response-body-is-equal-to-a-string\" class=\"headerlink\" title=\"断言响应体等于XXX字符串：Response body : is equal to a string\"></a>断言响应体等于XXX字符串：Response body : is equal to a string</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"Body is correct\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pm.response.to.have.body(<span class=\"string\">\"response_body_string\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//注解</span></span><br><span class=\"line\"><span class=\"comment\">//pm.response.to.have.body(\"response_body_string\");   获取响应体等于response_body_string</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"断言响应体-json-中某个键名对应的值：Response-body-JSON-value-check\"><a href=\"#断言响应体-json-中某个键名对应的值：Response-body-JSON-value-check\" class=\"headerlink\" title=\"断言响应体(json)中某个键名对应的值：Response body : JSON value check\"></a>断言响应体(json)中某个键名对应的值：Response body : JSON value check</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"断言相应城市为北京\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> jsonData = pm.response.json();</span><br><span class=\"line\">    pm.expect(jsonData.city).to.eql(<span class=\"string\">\"北京\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//注解</span></span><br><span class=\"line\"><span class=\"comment\">//var jsonData = pm.response.json()   获取响应体，以json显示，赋值给jsonData .注意：该响应体必须返会是的json，否则会报错</span></span><br><span class=\"line\"><span class=\"comment\">//pm.expect(jsonData.value).to.eql(\"北京\")  获取jsonData中键名为value的值，然后和\"北京\"进行比较</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"响应时间-一般用于性能测试\"><a href=\"#响应时间-一般用于性能测试\" class=\"headerlink\" title=\"响应时间(一般用于性能测试)\"></a>响应时间(一般用于性能测试)</h3><p>断言响应时间：Response time is less than 200ms</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.test(<span class=\"string\">\"Response time is less than 200ms\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    pm.expect(pm.response.responseTime).to.be.below(<span class=\"number\">200</span>);   <span class=\"comment\">//断言响应时间&lt;200ms</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"案例说明：\"><a href=\"#案例说明：\" class=\"headerlink\" title=\"案例说明：\"></a>案例说明：</h3><p>针对以下接口返回的数据进行断言：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">\"cityid\"</span>: <span class=\"string\">\"101010100\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"city\"</span>: <span class=\"string\">\"北京\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"update_time\"</span>: <span class=\"string\">\"22:34\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"wea\"</span>: <span class=\"string\">\"晴\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"wea_img\"</span>: <span class=\"string\">\"qing\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"tem\"</span>: <span class=\"string\">\"-2\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"tem_day\"</span>: <span class=\"string\">\"3\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"tem_night\"</span>: <span class=\"string\">\"-7\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"win\"</span>: <span class=\"string\">\"南风\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"win_speed\"</span>: <span class=\"string\">\"2级\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"win_meter\"</span>: <span class=\"string\">\"5km/h\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"air\"</span>: <span class=\"string\">\"43\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>断言响应状态码为200</p>\n</li>\n<li><p>断言city等于济南</p>\n</li>\n<li><p>断言update_time包含2020-04-17</p>\n<p><img src=\"/img/blog/postman/08/08-02.png\" alt=\"img\"> </p>\n</li>\n</ul>\n<blockquote>\n<p> 总结，整体来说，如果用postman做接口测试，这个断言功能必不可少，其中我们常断言的响应体包含和JSON这俩个断言又是重重之重。</p>\n</blockquote>"},{"title":"〖postman〗接口测试09-日志调试","abbrlink":"344e3c5b","date":"2022-01-14T16:39:30.000Z","_content":"\n> 在做接口测试时，经常会因为代码写的有问题导致报错，这时通过查看日志就显得非常重要了，postman也提供了这样的功能，它允许我们在脚本中编写打印语句，查看打印的结果 ; 同时也可以查看每个请求的日志信息 。 <!-- more --> \n\n## postman日志用的是什么编程语言？\n\n在postman中编写日志打印语句使用的是JavaScript，编写的位置可以是Pre-request Script 或Tests标签中。编写打印语句如：console.log(\"hello,postman\")\n\n ![img](/img/blog/postman/09/09-01.png) \n\n \n\n## 那么打印的日如何看呢 ？\n\n在postman中有俩个入口，第一个入口就是：view-show postman console 。\n\n第二个入口就是左下角第三个图标 。\n\n ![img](/img/blog/postman/09/09-02.png) \n\n \n\n### 打开的日志界面\n\n ![img](/img/blog/postman/09/09-03.png) \n\n \n\n这里面有几个比较实用的功能：\n\n搜索日志：输入URL或者打印的日志就能直接搜索出我们想要的请求和日志，这对我们在众多日志中查找某一条日志是非常方便的 。\n\n- 按级别搜索：可以查询log,info,warning,error级别的日志 ，有助于我们更快定位到错误 。\n\n\n- 查看原始报文(Show raw log)：如果习惯看原始请求报文的话，这个功能可能更方便些 。\n\n\n- 隐藏请求(Hide network)：把请求都隐藏掉，只查看输出日志 。\n\n\n总之，通过这个功能，我们在请求接口报错时，通过打印响应的日志，就能很轻松的找到问题原因了 。\n","source":"_posts/Postman/〖postman〗接口测试09-日志调试.md","raw":"---\ntitle: 〖postman〗接口测试09-日志调试\nabbrlink: 344e3c5b\ndate: 2022-01-15 00:39:30\ntags:\n - postman\ncategories:\n  - postman\n---\n\n> 在做接口测试时，经常会因为代码写的有问题导致报错，这时通过查看日志就显得非常重要了，postman也提供了这样的功能，它允许我们在脚本中编写打印语句，查看打印的结果 ; 同时也可以查看每个请求的日志信息 。 <!-- more --> \n\n## postman日志用的是什么编程语言？\n\n在postman中编写日志打印语句使用的是JavaScript，编写的位置可以是Pre-request Script 或Tests标签中。编写打印语句如：console.log(\"hello,postman\")\n\n ![img](/img/blog/postman/09/09-01.png) \n\n \n\n## 那么打印的日如何看呢 ？\n\n在postman中有俩个入口，第一个入口就是：view-show postman console 。\n\n第二个入口就是左下角第三个图标 。\n\n ![img](/img/blog/postman/09/09-02.png) \n\n \n\n### 打开的日志界面\n\n ![img](/img/blog/postman/09/09-03.png) \n\n \n\n这里面有几个比较实用的功能：\n\n搜索日志：输入URL或者打印的日志就能直接搜索出我们想要的请求和日志，这对我们在众多日志中查找某一条日志是非常方便的 。\n\n- 按级别搜索：可以查询log,info,warning,error级别的日志 ，有助于我们更快定位到错误 。\n\n\n- 查看原始报文(Show raw log)：如果习惯看原始请求报文的话，这个功能可能更方便些 。\n\n\n- 隐藏请求(Hide network)：把请求都隐藏掉，只查看输出日志 。\n\n\n总之，通过这个功能，我们在请求接口报错时，通过打印响应的日志，就能很轻松的找到问题原因了 。\n","slug":"Postman/〖postman〗接口测试09-日志调试","published":1,"updated":"2022-01-14T16:39:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xb0025n4ep5pksh3ig","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>在做接口测试时，经常会因为代码写的有问题导致报错，这时通过查看日志就显得非常重要了，postman也提供了这样的功能，它允许我们在脚本中编写打印语句，查看打印的结果 ; 同时也可以查看每个请求的日志信息 。 <a id=\"more\"></a> </p>\n</blockquote>\n<h2 id=\"postman日志用的是什么编程语言？\"><a href=\"#postman日志用的是什么编程语言？\" class=\"headerlink\" title=\"postman日志用的是什么编程语言？\"></a>postman日志用的是什么编程语言？</h2><p>在postman中编写日志打印语句使用的是JavaScript，编写的位置可以是Pre-request Script 或Tests标签中。编写打印语句如：console.log(“hello,postman”)</p>\n<p> <img src=\"/img/blog/postman/09/09-01.png\" alt=\"img\"> </p>\n<h2 id=\"那么打印的日如何看呢-？\"><a href=\"#那么打印的日如何看呢-？\" class=\"headerlink\" title=\"那么打印的日如何看呢 ？\"></a>那么打印的日如何看呢 ？</h2><p>在postman中有俩个入口，第一个入口就是：view-show postman console 。</p>\n<p>第二个入口就是左下角第三个图标 。</p>\n<p> <img src=\"/img/blog/postman/09/09-02.png\" alt=\"img\"> </p>\n<h3 id=\"打开的日志界面\"><a href=\"#打开的日志界面\" class=\"headerlink\" title=\"打开的日志界面\"></a>打开的日志界面</h3><p> <img src=\"/img/blog/postman/09/09-03.png\" alt=\"img\"> </p>\n<p>这里面有几个比较实用的功能：</p>\n<p>搜索日志：输入URL或者打印的日志就能直接搜索出我们想要的请求和日志，这对我们在众多日志中查找某一条日志是非常方便的 。</p>\n<ul>\n<li>按级别搜索：可以查询log,info,warning,error级别的日志 ，有助于我们更快定位到错误 。</li>\n</ul>\n<ul>\n<li>查看原始报文(Show raw log)：如果习惯看原始请求报文的话，这个功能可能更方便些 。</li>\n</ul>\n<ul>\n<li>隐藏请求(Hide network)：把请求都隐藏掉，只查看输出日志 。</li>\n</ul>\n<p>总之，通过这个功能，我们在请求接口报错时，通过打印响应的日志，就能很轻松的找到问题原因了 。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>在做接口测试时，经常会因为代码写的有问题导致报错，这时通过查看日志就显得非常重要了，postman也提供了这样的功能，它允许我们在脚本中编写打印语句，查看打印的结果 ; 同时也可以查看每个请求的日志信息 。","more":"</p>\n</blockquote>\n<h2 id=\"postman日志用的是什么编程语言？\"><a href=\"#postman日志用的是什么编程语言？\" class=\"headerlink\" title=\"postman日志用的是什么编程语言？\"></a>postman日志用的是什么编程语言？</h2><p>在postman中编写日志打印语句使用的是JavaScript，编写的位置可以是Pre-request Script 或Tests标签中。编写打印语句如：console.log(“hello,postman”)</p>\n<p> <img src=\"/img/blog/postman/09/09-01.png\" alt=\"img\"> </p>\n<h2 id=\"那么打印的日如何看呢-？\"><a href=\"#那么打印的日如何看呢-？\" class=\"headerlink\" title=\"那么打印的日如何看呢 ？\"></a>那么打印的日如何看呢 ？</h2><p>在postman中有俩个入口，第一个入口就是：view-show postman console 。</p>\n<p>第二个入口就是左下角第三个图标 。</p>\n<p> <img src=\"/img/blog/postman/09/09-02.png\" alt=\"img\"> </p>\n<h3 id=\"打开的日志界面\"><a href=\"#打开的日志界面\" class=\"headerlink\" title=\"打开的日志界面\"></a>打开的日志界面</h3><p> <img src=\"/img/blog/postman/09/09-03.png\" alt=\"img\"> </p>\n<p>这里面有几个比较实用的功能：</p>\n<p>搜索日志：输入URL或者打印的日志就能直接搜索出我们想要的请求和日志，这对我们在众多日志中查找某一条日志是非常方便的 。</p>\n<ul>\n<li>按级别搜索：可以查询log,info,warning,error级别的日志 ，有助于我们更快定位到错误 。</li>\n</ul>\n<ul>\n<li>查看原始报文(Show raw log)：如果习惯看原始请求报文的话，这个功能可能更方便些 。</li>\n</ul>\n<ul>\n<li>隐藏请求(Hide network)：把请求都隐藏掉，只查看输出日志 。</li>\n</ul>\n<p>总之，通过这个功能，我们在请求接口报错时，通过打印响应的日志，就能很轻松的找到问题原因了 。</p>"},{"title":"〖postman〗接口测试11-接口关联","abbrlink":"adb093cd","date":"2022-02-07T16:13:08.000Z","_content":"\n# 什么是关联接口\n\n在我们测试的接口中，经常出现这种情况 。 上一个接口的返回数据是下一个接口的输入参数 ，那么这俩个接口就产生了关联关系 。 这种关联在做接口测试时非常常见，那么在postman中，如何实现这种关联关系呢 ？我们通过一个案例来实现。 <!-- more --> \n\n### 案例：\n\n用户充值，需要用户先登录，然后在进行充值操作：\n\n调用登录接口成功后会返回如下信息：\n\n```\n{\n\n  \"code\": 0,\n\n  \"msg\": \"OK\",\n\n  \"data\": {\n\n    \"id\": 4,\n\n    \"leave_amount\": 6300.0,\n\n    \"mobile_phone\": \"15943873886\",\n\n    \"reg_name\": \"Auto_Test\",\n\n    \"reg_time\": \"2022-02-03 07:38:06.0\",\n\n    \"type\": 0,\n\n    \"token_info\": {\n\n      \"token_type\": \"Bearer\",\n\n      \"expires_in\": \"2022-02-07 16:24:08\",\n\n      \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJtZW1iZXJfaWQiOjQsImV4cCI6MTY0NDI1MTA0OH0.yXw4-_vnTJs3c1wPTwd8saMae8OP1jQ7Vlizvv0wygoD0ZCwX9Ahe6AHUEKsPJeOKkxfcXDXBcW4JNJ8mDkuvw\"\n\n    }\n\n  },\n\n}\n```\n\n而充值接口需要传入token，登录接口正好返回了token。那么这俩个接口就产生了关联 。那么在postman 可以通过以下三步完成这俩个接口的关联实现 。\n\n### 实现步骤：\n\n1. 登录获取后获取token\n2. 将token保存到环境变量\n3. 充值接口调用环境变量中的token就可以实现业务操作\n\n ![登录](/img/blog/postman/11/011-01.png) \n ![充值](/img/blog/postman/11/011-02.png) \n\n>  可以看出，接口的关联的解决方案都是用的是变量中的知识，也就是说只要你明确了要提取的值，后面就是保存该值，然后在其他接口使用该值就可以了。","source":"_posts/Postman/〖postman〗接口测试11-接口关联.md","raw":"---\ntitle: 〖postman〗接口测试11-接口关联\ntags:\n  - postman\ncategories:\n  - postman\nabbrlink: adb093cd\ndate: 2022-02-08 00:13:08\n---\n\n# 什么是关联接口\n\n在我们测试的接口中，经常出现这种情况 。 上一个接口的返回数据是下一个接口的输入参数 ，那么这俩个接口就产生了关联关系 。 这种关联在做接口测试时非常常见，那么在postman中，如何实现这种关联关系呢 ？我们通过一个案例来实现。 <!-- more --> \n\n### 案例：\n\n用户充值，需要用户先登录，然后在进行充值操作：\n\n调用登录接口成功后会返回如下信息：\n\n```\n{\n\n  \"code\": 0,\n\n  \"msg\": \"OK\",\n\n  \"data\": {\n\n    \"id\": 4,\n\n    \"leave_amount\": 6300.0,\n\n    \"mobile_phone\": \"15943873886\",\n\n    \"reg_name\": \"Auto_Test\",\n\n    \"reg_time\": \"2022-02-03 07:38:06.0\",\n\n    \"type\": 0,\n\n    \"token_info\": {\n\n      \"token_type\": \"Bearer\",\n\n      \"expires_in\": \"2022-02-07 16:24:08\",\n\n      \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJtZW1iZXJfaWQiOjQsImV4cCI6MTY0NDI1MTA0OH0.yXw4-_vnTJs3c1wPTwd8saMae8OP1jQ7Vlizvv0wygoD0ZCwX9Ahe6AHUEKsPJeOKkxfcXDXBcW4JNJ8mDkuvw\"\n\n    }\n\n  },\n\n}\n```\n\n而充值接口需要传入token，登录接口正好返回了token。那么这俩个接口就产生了关联 。那么在postman 可以通过以下三步完成这俩个接口的关联实现 。\n\n### 实现步骤：\n\n1. 登录获取后获取token\n2. 将token保存到环境变量\n3. 充值接口调用环境变量中的token就可以实现业务操作\n\n ![登录](/img/blog/postman/11/011-01.png) \n ![充值](/img/blog/postman/11/011-02.png) \n\n>  可以看出，接口的关联的解决方案都是用的是变量中的知识，也就是说只要你明确了要提取的值，后面就是保存该值，然后在其他接口使用该值就可以了。","slug":"Postman/〖postman〗接口测试11-接口关联","published":1,"updated":"2022-02-07T16:13:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xc0027n4ep7737e8p9","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"什么是关联接口\"><a href=\"#什么是关联接口\" class=\"headerlink\" title=\"什么是关联接口\"></a>什么是关联接口</h1><p>在我们测试的接口中，经常出现这种情况 。 上一个接口的返回数据是下一个接口的输入参数 ，那么这俩个接口就产生了关联关系 。 这种关联在做接口测试时非常常见，那么在postman中，如何实现这种关联关系呢 ？我们通过一个案例来实现。 <a id=\"more\"></a> </p>\n<h3 id=\"案例：\"><a href=\"#案例：\" class=\"headerlink\" title=\"案例：\"></a>案例：</h3><p>用户充值，需要用户先登录，然后在进行充值操作：</p>\n<p>调用登录接口成功后会返回如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &quot;code&quot;: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">  &quot;msg&quot;: &quot;OK&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">  &quot;data&quot;: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;id&quot;: 4,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;leave_amount&quot;: 6300.0,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;mobile_phone&quot;: &quot;15943873886&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;reg_name&quot;: &quot;Auto_Test&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;reg_time&quot;: &quot;2022-02-03 07:38:06.0&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;type&quot;: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;token_info&quot;: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      &quot;token_type&quot;: &quot;Bearer&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">      &quot;expires_in&quot;: &quot;2022-02-07 16:24:08&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">      &quot;token&quot;: &quot;eyJhbGciOiJIUzUxMiJ9.eyJtZW1iZXJfaWQiOjQsImV4cCI6MTY0NDI1MTA0OH0.yXw4-_vnTJs3c1wPTwd8saMae8OP1jQ7Vlizvv0wygoD0ZCwX9Ahe6AHUEKsPJeOKkxfcXDXBcW4JNJ8mDkuvw&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而充值接口需要传入token，登录接口正好返回了token。那么这俩个接口就产生了关联 。那么在postman 可以通过以下三步完成这俩个接口的关联实现 。</p>\n<h3 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a>实现步骤：</h3><ol>\n<li><p>登录获取后获取token</p>\n</li>\n<li><p>将token保存到环境变量</p>\n</li>\n<li><p>充值接口调用环境变量中的token就可以实现业务操作</p>\n<p><img src=\"/img/blog/postman/11/011-01.png\" alt=\"登录\"><br><img src=\"/img/blog/postman/11/011-02.png\" alt=\"充值\"> </p>\n</li>\n</ol>\n<blockquote>\n<p> 可以看出，接口的关联的解决方案都是用的是变量中的知识，也就是说只要你明确了要提取的值，后面就是保存该值，然后在其他接口使用该值就可以了。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是关联接口\"><a href=\"#什么是关联接口\" class=\"headerlink\" title=\"什么是关联接口\"></a>什么是关联接口</h1><p>在我们测试的接口中，经常出现这种情况 。 上一个接口的返回数据是下一个接口的输入参数 ，那么这俩个接口就产生了关联关系 。 这种关联在做接口测试时非常常见，那么在postman中，如何实现这种关联关系呢 ？我们通过一个案例来实现。","more":"</p>\n<h3 id=\"案例：\"><a href=\"#案例：\" class=\"headerlink\" title=\"案例：\"></a>案例：</h3><p>用户充值，需要用户先登录，然后在进行充值操作：</p>\n<p>调用登录接口成功后会返回如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &quot;code&quot;: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">  &quot;msg&quot;: &quot;OK&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">  &quot;data&quot;: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;id&quot;: 4,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;leave_amount&quot;: 6300.0,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;mobile_phone&quot;: &quot;15943873886&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;reg_name&quot;: &quot;Auto_Test&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;reg_time&quot;: &quot;2022-02-03 07:38:06.0&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;type&quot;: 0,</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;token_info&quot;: &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      &quot;token_type&quot;: &quot;Bearer&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">      &quot;expires_in&quot;: &quot;2022-02-07 16:24:08&quot;,</span><br><span class=\"line\"></span><br><span class=\"line\">      &quot;token&quot;: &quot;eyJhbGciOiJIUzUxMiJ9.eyJtZW1iZXJfaWQiOjQsImV4cCI6MTY0NDI1MTA0OH0.yXw4-_vnTJs3c1wPTwd8saMae8OP1jQ7Vlizvv0wygoD0ZCwX9Ahe6AHUEKsPJeOKkxfcXDXBcW4JNJ8mDkuvw&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而充值接口需要传入token，登录接口正好返回了token。那么这俩个接口就产生了关联 。那么在postman 可以通过以下三步完成这俩个接口的关联实现 。</p>\n<h3 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a>实现步骤：</h3><ol>\n<li><p>登录获取后获取token</p>\n</li>\n<li><p>将token保存到环境变量</p>\n</li>\n<li><p>充值接口调用环境变量中的token就可以实现业务操作</p>\n<p><img src=\"/img/blog/postman/11/011-01.png\" alt=\"登录\"><br><img src=\"/img/blog/postman/11/011-02.png\" alt=\"充值\"> </p>\n</li>\n</ol>\n<blockquote>\n<p> 可以看出，接口的关联的解决方案都是用的是变量中的知识，也就是说只要你明确了要提取的值，后面就是保存该值，然后在其他接口使用该值就可以了。</p>\n</blockquote>"},{"title":"〖postman〗接口测试10-全局变量-集合变量-环境变量","abbrlink":"c98d9940","date":"2022-01-23T13:13:56.000Z","_content":"\n> 变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。\n\n <!-- more --> 对我们做接口测试来说，又是一个非常重要的功能 。\n\n## 在postman常用的三种变量分别是全局变量，环境变量，集合变量 。\n\n> 全局变量：一旦申明了全局变量，全局有效，也就是说postman中的任何集合，任何请求中都可以使用这个变量。它的作用域是最大的 。\n\n> 环境变量：要申明环境变量，首先的创建环境，然后在环境中才能创建变量 。如果要想使用环境变量，必须先选择(导入)这个环境，这样就可以使用这个环境下的变量了 。需要说明的是环境也可以创建多个 。每个环境下又可以有多个变量 。\n\n> 集合变量：集合变量是针对集合的，也就是说申明的变量必须基于某个集合，它的使用范围也只是针对这个集合有效 。\n\n其中，他们的作用域范围依次从大到小：全局变量>集合变量>环境变量 。 当在几个不同的范围内都申明了相同的变量时，则会优先使用范围最小的变量使。\n\n## 想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。\n\n    1.定义变量（设置变量）\n    \n    2.获取变量（访问变量）\n\n### 1. 定义变量\n\n定义全局变量和环境变量，点击右上角的小齿轮，弹出如下界面，就可以根据需求定义全局变量或者环境变量了。\n\n ![img](/img/blog/postman/10/010-01.png) \n\n已经定义的全局变量和环境变量，可以进行快速查看\n\n ![img](/img/blog/postman/10/010-02.png) \n\n### 2.定义集合变量\n\n#### 2.1 选择一个集合，打开查看更多动作(...)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。\n\n ![img](/img/blog/postman/10/010-03.png) \n\n ![img](/img/blog/postman/10/010-04.png) \n\n\n#### 2.2 定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。\n\n在URL，Params , Authorization , Headers , Body中定义：\n\n手工方式创建一个空的变量名\n\n在以上的位置把想要的值选中右击，选中Set：环境|全局 ，选中一个变量名，点击后就会保存到这个变量中\n\n ![img](/img/blog/postman/10/010-05.png) \n\n在Tests，Pre-requests Script：\n\n定义全局变量：pm.collectionVariables.set(\"变量名\",变量值)\n\n定义环境变量：pm.environment.set(\"变量名\"，变量值)\n\n定义集合变量：pm.variables.set(\"变量名\",变量值)\n\n### 3.获取变量\n\n定义好变量，接下来就可以使用变量了 。需要注意的是，在不同的位置获取变量，编写的规则也是不一样的 。\n\n如果在请求参数中获取变量，无论是获取全局变量，还是环境变量，还是集合变量，获取的方式都是一样的编写规则：{undefined{变量名}} 。\n\n请求参数指的是：URL，Params , Authorization , Headers , Body\n\n如果是在编写代码的位置(Tests,Pre-requests Script)获取变量，获取不同类型的变量，编写的代码都不相同，具体如下：\n\n获取环境变量：pm.environment.get(‘变量名’)\n\n获取全局变量：pm.globals.get('变量名')\n\n获取集合变量：pm.pm.collectionVariables.get.get('变量名')\n\n ![img](/img/blog/postman/10/010-06.png) \n\n变量的使用场景非常广泛，比如我们后面要提到的接口关联，请求前置脚本都会使用到变量 。\n\n","source":"_posts/Postman/〖postman〗接口测试10-全局变量-集合变量-环境变量.md","raw":"---\ntitle: 〖postman〗接口测试10-全局变量-集合变量-环境变量\nabbrlink: c98d9940\ndate: 2022-01-23 21:13:56\ntags:\n - postman\ncategories:\n  - postman\n---\n\n> 变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。\n\n <!-- more --> 对我们做接口测试来说，又是一个非常重要的功能 。\n\n## 在postman常用的三种变量分别是全局变量，环境变量，集合变量 。\n\n> 全局变量：一旦申明了全局变量，全局有效，也就是说postman中的任何集合，任何请求中都可以使用这个变量。它的作用域是最大的 。\n\n> 环境变量：要申明环境变量，首先的创建环境，然后在环境中才能创建变量 。如果要想使用环境变量，必须先选择(导入)这个环境，这样就可以使用这个环境下的变量了 。需要说明的是环境也可以创建多个 。每个环境下又可以有多个变量 。\n\n> 集合变量：集合变量是针对集合的，也就是说申明的变量必须基于某个集合，它的使用范围也只是针对这个集合有效 。\n\n其中，他们的作用域范围依次从大到小：全局变量>集合变量>环境变量 。 当在几个不同的范围内都申明了相同的变量时，则会优先使用范围最小的变量使。\n\n## 想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。\n\n    1.定义变量（设置变量）\n    \n    2.获取变量（访问变量）\n\n### 1. 定义变量\n\n定义全局变量和环境变量，点击右上角的小齿轮，弹出如下界面，就可以根据需求定义全局变量或者环境变量了。\n\n ![img](/img/blog/postman/10/010-01.png) \n\n已经定义的全局变量和环境变量，可以进行快速查看\n\n ![img](/img/blog/postman/10/010-02.png) \n\n### 2.定义集合变量\n\n#### 2.1 选择一个集合，打开查看更多动作(...)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。\n\n ![img](/img/blog/postman/10/010-03.png) \n\n ![img](/img/blog/postman/10/010-04.png) \n\n\n#### 2.2 定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。\n\n在URL，Params , Authorization , Headers , Body中定义：\n\n手工方式创建一个空的变量名\n\n在以上的位置把想要的值选中右击，选中Set：环境|全局 ，选中一个变量名，点击后就会保存到这个变量中\n\n ![img](/img/blog/postman/10/010-05.png) \n\n在Tests，Pre-requests Script：\n\n定义全局变量：pm.collectionVariables.set(\"变量名\",变量值)\n\n定义环境变量：pm.environment.set(\"变量名\"，变量值)\n\n定义集合变量：pm.variables.set(\"变量名\",变量值)\n\n### 3.获取变量\n\n定义好变量，接下来就可以使用变量了 。需要注意的是，在不同的位置获取变量，编写的规则也是不一样的 。\n\n如果在请求参数中获取变量，无论是获取全局变量，还是环境变量，还是集合变量，获取的方式都是一样的编写规则：{undefined{变量名}} 。\n\n请求参数指的是：URL，Params , Authorization , Headers , Body\n\n如果是在编写代码的位置(Tests,Pre-requests Script)获取变量，获取不同类型的变量，编写的代码都不相同，具体如下：\n\n获取环境变量：pm.environment.get(‘变量名’)\n\n获取全局变量：pm.globals.get('变量名')\n\n获取集合变量：pm.pm.collectionVariables.get.get('变量名')\n\n ![img](/img/blog/postman/10/010-06.png) \n\n变量的使用场景非常广泛，比如我们后面要提到的接口关联，请求前置脚本都会使用到变量 。\n\n","slug":"Postman/〖postman〗接口测试10-全局变量-集合变量-环境变量","published":1,"updated":"2022-01-23T13:13:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xd002bn4epg0hw1kpv","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。</p>\n</blockquote>\n <a id=\"more\"></a> 对我们做接口测试来说，又是一个非常重要的功能 。\n\n<h2 id=\"在postman常用的三种变量分别是全局变量，环境变量，集合变量-。\"><a href=\"#在postman常用的三种变量分别是全局变量，环境变量，集合变量-。\" class=\"headerlink\" title=\"在postman常用的三种变量分别是全局变量，环境变量，集合变量 。\"></a>在postman常用的三种变量分别是全局变量，环境变量，集合变量 。</h2><blockquote>\n<p>全局变量：一旦申明了全局变量，全局有效，也就是说postman中的任何集合，任何请求中都可以使用这个变量。它的作用域是最大的 。</p>\n</blockquote>\n<blockquote>\n<p>环境变量：要申明环境变量，首先的创建环境，然后在环境中才能创建变量 。如果要想使用环境变量，必须先选择(导入)这个环境，这样就可以使用这个环境下的变量了 。需要说明的是环境也可以创建多个 。每个环境下又可以有多个变量 。</p>\n</blockquote>\n<blockquote>\n<p>集合变量：集合变量是针对集合的，也就是说申明的变量必须基于某个集合，它的使用范围也只是针对这个集合有效 。</p>\n</blockquote>\n<p>其中，他们的作用域范围依次从大到小：全局变量&gt;集合变量&gt;环境变量 。 当在几个不同的范围内都申明了相同的变量时，则会优先使用范围最小的变量使。</p>\n<h2 id=\"想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量-。\"><a href=\"#想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量-。\" class=\"headerlink\" title=\"想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。\"></a>想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。</h2><pre><code>1.定义变量（设置变量）\n\n2.获取变量（访问变量）</code></pre><h3 id=\"1-定义变量\"><a href=\"#1-定义变量\" class=\"headerlink\" title=\"1. 定义变量\"></a>1. 定义变量</h3><p>定义全局变量和环境变量，点击右上角的小齿轮，弹出如下界面，就可以根据需求定义全局变量或者环境变量了。</p>\n<p> <img src=\"/img/blog/postman/10/010-01.png\" alt=\"img\"> </p>\n<p>已经定义的全局变量和环境变量，可以进行快速查看</p>\n<p> <img src=\"/img/blog/postman/10/010-02.png\" alt=\"img\"> </p>\n<h3 id=\"2-定义集合变量\"><a href=\"#2-定义集合变量\" class=\"headerlink\" title=\"2.定义集合变量\"></a>2.定义集合变量</h3><h4 id=\"2-1-选择一个集合，打开查看更多动作-…-菜单，然后点击编辑-。选择“变量”选项卡以编辑或添加到集合变量。\"><a href=\"#2-1-选择一个集合，打开查看更多动作-…-菜单，然后点击编辑-。选择“变量”选项卡以编辑或添加到集合变量。\" class=\"headerlink\" title=\"2.1 选择一个集合，打开查看更多动作(…)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。\"></a>2.1 选择一个集合，打开查看更多动作(…)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。</h4><p> <img src=\"/img/blog/postman/10/010-03.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/blog/postman/10/010-04.png\" alt=\"img\"> </p>\n<h4 id=\"2-2-定义变量除了以上方式，还有另外一种方式-。但是这种方式在不同的位置定义，编写不一样。\"><a href=\"#2-2-定义变量除了以上方式，还有另外一种方式-。但是这种方式在不同的位置定义，编写不一样。\" class=\"headerlink\" title=\"2.2 定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。\"></a>2.2 定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。</h4><p>在URL，Params , Authorization , Headers , Body中定义：</p>\n<p>手工方式创建一个空的变量名</p>\n<p>在以上的位置把想要的值选中右击，选中Set：环境|全局 ，选中一个变量名，点击后就会保存到这个变量中</p>\n<p> <img src=\"/img/blog/postman/10/010-05.png\" alt=\"img\"> </p>\n<p>在Tests，Pre-requests Script：</p>\n<p>定义全局变量：pm.collectionVariables.set(“变量名”,变量值)</p>\n<p>定义环境变量：pm.environment.set(“变量名”，变量值)</p>\n<p>定义集合变量：pm.variables.set(“变量名”,变量值)</p>\n<h3 id=\"3-获取变量\"><a href=\"#3-获取变量\" class=\"headerlink\" title=\"3.获取变量\"></a>3.获取变量</h3><p>定义好变量，接下来就可以使用变量了 。需要注意的是，在不同的位置获取变量，编写的规则也是不一样的 。</p>\n<p>如果在请求参数中获取变量，无论是获取全局变量，还是环境变量，还是集合变量，获取的方式都是一样的编写规则：{undefined{变量名}} 。</p>\n<p>请求参数指的是：URL，Params , Authorization , Headers , Body</p>\n<p>如果是在编写代码的位置(Tests,Pre-requests Script)获取变量，获取不同类型的变量，编写的代码都不相同，具体如下：</p>\n<p>获取环境变量：pm.environment.get(‘变量名’)</p>\n<p>获取全局变量：pm.globals.get(‘变量名’)</p>\n<p>获取集合变量：pm.pm.collectionVariables.get.get(‘变量名’)</p>\n<p> <img src=\"/img/blog/postman/10/010-06.png\" alt=\"img\"> </p>\n<p>变量的使用场景非常广泛，比如我们后面要提到的接口关联，请求前置脚本都会使用到变量 。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。</p>\n</blockquote>","more":"对我们做接口测试来说，又是一个非常重要的功能 。\n\n<h2 id=\"在postman常用的三种变量分别是全局变量，环境变量，集合变量-。\"><a href=\"#在postman常用的三种变量分别是全局变量，环境变量，集合变量-。\" class=\"headerlink\" title=\"在postman常用的三种变量分别是全局变量，环境变量，集合变量 。\"></a>在postman常用的三种变量分别是全局变量，环境变量，集合变量 。</h2><blockquote>\n<p>全局变量：一旦申明了全局变量，全局有效，也就是说postman中的任何集合，任何请求中都可以使用这个变量。它的作用域是最大的 。</p>\n</blockquote>\n<blockquote>\n<p>环境变量：要申明环境变量，首先的创建环境，然后在环境中才能创建变量 。如果要想使用环境变量，必须先选择(导入)这个环境，这样就可以使用这个环境下的变量了 。需要说明的是环境也可以创建多个 。每个环境下又可以有多个变量 。</p>\n</blockquote>\n<blockquote>\n<p>集合变量：集合变量是针对集合的，也就是说申明的变量必须基于某个集合，它的使用范围也只是针对这个集合有效 。</p>\n</blockquote>\n<p>其中，他们的作用域范围依次从大到小：全局变量&gt;集合变量&gt;环境变量 。 当在几个不同的范围内都申明了相同的变量时，则会优先使用范围最小的变量使。</p>\n<h2 id=\"想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量-。\"><a href=\"#想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量-。\" class=\"headerlink\" title=\"想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。\"></a>想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。</h2><pre><code>1.定义变量（设置变量）\n\n2.获取变量（访问变量）</code></pre><h3 id=\"1-定义变量\"><a href=\"#1-定义变量\" class=\"headerlink\" title=\"1. 定义变量\"></a>1. 定义变量</h3><p>定义全局变量和环境变量，点击右上角的小齿轮，弹出如下界面，就可以根据需求定义全局变量或者环境变量了。</p>\n<p> <img src=\"/img/blog/postman/10/010-01.png\" alt=\"img\"> </p>\n<p>已经定义的全局变量和环境变量，可以进行快速查看</p>\n<p> <img src=\"/img/blog/postman/10/010-02.png\" alt=\"img\"> </p>\n<h3 id=\"2-定义集合变量\"><a href=\"#2-定义集合变量\" class=\"headerlink\" title=\"2.定义集合变量\"></a>2.定义集合变量</h3><h4 id=\"2-1-选择一个集合，打开查看更多动作-…-菜单，然后点击编辑-。选择“变量”选项卡以编辑或添加到集合变量。\"><a href=\"#2-1-选择一个集合，打开查看更多动作-…-菜单，然后点击编辑-。选择“变量”选项卡以编辑或添加到集合变量。\" class=\"headerlink\" title=\"2.1 选择一个集合，打开查看更多动作(…)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。\"></a>2.1 选择一个集合，打开查看更多动作(…)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。</h4><p> <img src=\"/img/blog/postman/10/010-03.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/blog/postman/10/010-04.png\" alt=\"img\"> </p>\n<h4 id=\"2-2-定义变量除了以上方式，还有另外一种方式-。但是这种方式在不同的位置定义，编写不一样。\"><a href=\"#2-2-定义变量除了以上方式，还有另外一种方式-。但是这种方式在不同的位置定义，编写不一样。\" class=\"headerlink\" title=\"2.2 定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。\"></a>2.2 定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。</h4><p>在URL，Params , Authorization , Headers , Body中定义：</p>\n<p>手工方式创建一个空的变量名</p>\n<p>在以上的位置把想要的值选中右击，选中Set：环境|全局 ，选中一个变量名，点击后就会保存到这个变量中</p>\n<p> <img src=\"/img/blog/postman/10/010-05.png\" alt=\"img\"> </p>\n<p>在Tests，Pre-requests Script：</p>\n<p>定义全局变量：pm.collectionVariables.set(“变量名”,变量值)</p>\n<p>定义环境变量：pm.environment.set(“变量名”，变量值)</p>\n<p>定义集合变量：pm.variables.set(“变量名”,变量值)</p>\n<h3 id=\"3-获取变量\"><a href=\"#3-获取变量\" class=\"headerlink\" title=\"3.获取变量\"></a>3.获取变量</h3><p>定义好变量，接下来就可以使用变量了 。需要注意的是，在不同的位置获取变量，编写的规则也是不一样的 。</p>\n<p>如果在请求参数中获取变量，无论是获取全局变量，还是环境变量，还是集合变量，获取的方式都是一样的编写规则：{undefined{变量名}} 。</p>\n<p>请求参数指的是：URL，Params , Authorization , Headers , Body</p>\n<p>如果是在编写代码的位置(Tests,Pre-requests Script)获取变量，获取不同类型的变量，编写的代码都不相同，具体如下：</p>\n<p>获取环境变量：pm.environment.get(‘变量名’)</p>\n<p>获取全局变量：pm.globals.get(‘变量名’)</p>\n<p>获取集合变量：pm.pm.collectionVariables.get.get(‘变量名’)</p>\n<p> <img src=\"/img/blog/postman/10/010-06.png\" alt=\"img\"> </p>\n<p>变量的使用场景非常广泛，比如我们后面要提到的接口关联，请求前置脚本都会使用到变量 。</p>"},{"title":"〖postman〗接口测试12-请求前置脚本","abbrlink":"99817e93","date":"2022-02-08T14:24:22.000Z","_content":"\n# 什么是前置脚本\n\n前置脚本其实就是在Pre-requests Script中编写的JavaScript脚本，想要了解这个功能，需要先了解它的执行顺序。那么下面就来看下它的执行顺序 。 <!-- more --> \n\n ![img](/img/blog/postman/12/012-01.png) \n\n可以看出，一个请求在发送之前，会先去执行Pre Request Script（前置脚本）中的代码 。那么这个功能在实际工作中有什么作用呢 ？\n\n主要场景：一般情况下，在发送请求前需要对接口的数据做进一步处理，就都可以使用这个功能，比如说，登录接口的密码，在发送前需要做加密处理，那么就可以在前置脚本中做加密处理，再比如说，有的接口的输入参数有一些随机数，每请求一次接口参数值都会发送变化，就可以在前置脚本中编写生成随机数的代码 。\n\n总结来说，就是在请求接口之前对我们的请求数据进行进一步加工处理的都可以使用前置脚本这个功能。\n\n# 接下来通过一个案例来看下该功能是如何使用 ？\n\n### 案例：\n\n请求的充值接口，要做个抽奖的活动，随机到谁，就充值给谁，那么这个ID就是一个随机数\n\n\n\n ![img](/img/blog/postman/12/012-02.png) \n\n### 实现步骤：\n\n​\t1、在前置脚本中编写生成随机数\n\n​\t2、将这个值保存成环境变量\n\n​\t3、将ID的值替换成环境变量的值 。\n\n \n\n> 总之，这个前置脚本对我们做接口测试也非常有用，对一些复杂的场景，都可以使用前置脚本进行处理后再请求接口 。","source":"_posts/Postman/〖postman〗接口测试12-请求前置脚本.md","raw":"---\ntitle: 〖postman〗接口测试12-请求前置脚本\ntags:\n  - postman\ncategories:\n  - postman\nabbrlink: '99817e93'\ndate: 2022-02-08 22:24:22\n---\n\n# 什么是前置脚本\n\n前置脚本其实就是在Pre-requests Script中编写的JavaScript脚本，想要了解这个功能，需要先了解它的执行顺序。那么下面就来看下它的执行顺序 。 <!-- more --> \n\n ![img](/img/blog/postman/12/012-01.png) \n\n可以看出，一个请求在发送之前，会先去执行Pre Request Script（前置脚本）中的代码 。那么这个功能在实际工作中有什么作用呢 ？\n\n主要场景：一般情况下，在发送请求前需要对接口的数据做进一步处理，就都可以使用这个功能，比如说，登录接口的密码，在发送前需要做加密处理，那么就可以在前置脚本中做加密处理，再比如说，有的接口的输入参数有一些随机数，每请求一次接口参数值都会发送变化，就可以在前置脚本中编写生成随机数的代码 。\n\n总结来说，就是在请求接口之前对我们的请求数据进行进一步加工处理的都可以使用前置脚本这个功能。\n\n# 接下来通过一个案例来看下该功能是如何使用 ？\n\n### 案例：\n\n请求的充值接口，要做个抽奖的活动，随机到谁，就充值给谁，那么这个ID就是一个随机数\n\n\n\n ![img](/img/blog/postman/12/012-02.png) \n\n### 实现步骤：\n\n​\t1、在前置脚本中编写生成随机数\n\n​\t2、将这个值保存成环境变量\n\n​\t3、将ID的值替换成环境变量的值 。\n\n \n\n> 总之，这个前置脚本对我们做接口测试也非常有用，对一些复杂的场景，都可以使用前置脚本进行处理后再请求接口 。","slug":"Postman/〖postman〗接口测试12-请求前置脚本","published":1,"updated":"2022-02-08T14:24:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xe002dn4epbzk8aqdv","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"什么是前置脚本\"><a href=\"#什么是前置脚本\" class=\"headerlink\" title=\"什么是前置脚本\"></a>什么是前置脚本</h1><p>前置脚本其实就是在Pre-requests Script中编写的JavaScript脚本，想要了解这个功能，需要先了解它的执行顺序。那么下面就来看下它的执行顺序 。 <a id=\"more\"></a> </p>\n<p> <img src=\"/img/blog/postman/12/012-01.png\" alt=\"img\"> </p>\n<p>可以看出，一个请求在发送之前，会先去执行Pre Request Script（前置脚本）中的代码 。那么这个功能在实际工作中有什么作用呢 ？</p>\n<p>主要场景：一般情况下，在发送请求前需要对接口的数据做进一步处理，就都可以使用这个功能，比如说，登录接口的密码，在发送前需要做加密处理，那么就可以在前置脚本中做加密处理，再比如说，有的接口的输入参数有一些随机数，每请求一次接口参数值都会发送变化，就可以在前置脚本中编写生成随机数的代码 。</p>\n<p>总结来说，就是在请求接口之前对我们的请求数据进行进一步加工处理的都可以使用前置脚本这个功能。</p>\n<h1 id=\"接下来通过一个案例来看下该功能是如何使用-？\"><a href=\"#接下来通过一个案例来看下该功能是如何使用-？\" class=\"headerlink\" title=\"接下来通过一个案例来看下该功能是如何使用 ？\"></a>接下来通过一个案例来看下该功能是如何使用 ？</h1><h3 id=\"案例：\"><a href=\"#案例：\" class=\"headerlink\" title=\"案例：\"></a>案例：</h3><p>请求的充值接口，要做个抽奖的活动，随机到谁，就充值给谁，那么这个ID就是一个随机数</p>\n<p> <img src=\"/img/blog/postman/12/012-02.png\" alt=\"img\"> </p>\n<h3 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a>实现步骤：</h3><p>​    1、在前置脚本中编写生成随机数</p>\n<p>​    2、将这个值保存成环境变量</p>\n<p>​    3、将ID的值替换成环境变量的值 。</p>\n<blockquote>\n<p>总之，这个前置脚本对我们做接口测试也非常有用，对一些复杂的场景，都可以使用前置脚本进行处理后再请求接口 。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"什么是前置脚本\"><a href=\"#什么是前置脚本\" class=\"headerlink\" title=\"什么是前置脚本\"></a>什么是前置脚本</h1><p>前置脚本其实就是在Pre-requests Script中编写的JavaScript脚本，想要了解这个功能，需要先了解它的执行顺序。那么下面就来看下它的执行顺序 。","more":"</p>\n<p> <img src=\"/img/blog/postman/12/012-01.png\" alt=\"img\"> </p>\n<p>可以看出，一个请求在发送之前，会先去执行Pre Request Script（前置脚本）中的代码 。那么这个功能在实际工作中有什么作用呢 ？</p>\n<p>主要场景：一般情况下，在发送请求前需要对接口的数据做进一步处理，就都可以使用这个功能，比如说，登录接口的密码，在发送前需要做加密处理，那么就可以在前置脚本中做加密处理，再比如说，有的接口的输入参数有一些随机数，每请求一次接口参数值都会发送变化，就可以在前置脚本中编写生成随机数的代码 。</p>\n<p>总结来说，就是在请求接口之前对我们的请求数据进行进一步加工处理的都可以使用前置脚本这个功能。</p>\n<h1 id=\"接下来通过一个案例来看下该功能是如何使用-？\"><a href=\"#接下来通过一个案例来看下该功能是如何使用-？\" class=\"headerlink\" title=\"接下来通过一个案例来看下该功能是如何使用 ？\"></a>接下来通过一个案例来看下该功能是如何使用 ？</h1><h3 id=\"案例：\"><a href=\"#案例：\" class=\"headerlink\" title=\"案例：\"></a>案例：</h3><p>请求的充值接口，要做个抽奖的活动，随机到谁，就充值给谁，那么这个ID就是一个随机数</p>\n<p> <img src=\"/img/blog/postman/12/012-02.png\" alt=\"img\"> </p>\n<h3 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a>实现步骤：</h3><p>​    1、在前置脚本中编写生成随机数</p>\n<p>​    2、将这个值保存成环境变量</p>\n<p>​    3、将ID的值替换成环境变量的值 。</p>\n<blockquote>\n<p>总之，这个前置脚本对我们做接口测试也非常有用，对一些复杂的场景，都可以使用前置脚本进行处理后再请求接口 。</p>\n</blockquote>"},{"title":"〖postman〗接口测试13-认证-Authorization","abbrlink":"dcc42dc3","date":"2022-02-11T14:13:55.000Z","_content":"\n# Authorization是什么？\n这又是一个非常实用的功能，对我们做接口测试来说，经常要处理登录认证的情况 。 <!-- more --> 如果不用这个Authorization其实也能解决认证的问题，无非就是把要认证的数据按照要求在指定位置传入参数即可。比如我们之前测试的系统，登录后返回的token要在每个请求接口的headers中传入 。这时就需要在每个headers中都填写一个认证参数传入 ，但是这样做的话太过繁琐，如果使用认证(Authorization)功能的话，就会大大简化了我们的认证过程。\n\n我们先来看下这个功能的具体位置及主要作用 。\n ![img](/img/blog/postman/13/013-01.png)\n\nInherit auto from parent:从父级继承身份验证，是每个请求的默认选择 。这是一个很有用的功能，当我们对一个集合(collection)进行测试的时候，集合中的每个请求都需要获取token，那么如果我们在集合中把token处理好的话，那么该集合下的所有请求都会自动获取到这个token，也就省略了我们对每个token进行处理了。\n\n### 实现步骤：\n![img](/img/blog/postman/13/013-02.png)\n\n ![img](/img/blog/postman/13/013-03.png)\n ![img](/img/blog/postman/13/013-04.png)\n\n\n### No Auth: 无需身份认证的可以选择这个 。\n选中一个集合进行编辑，切换到Pre-Request Script.在这里请求登录接口 ，将返回的token值拿到，然后保存成全局变量 。\n\n切换到Authorization选项卡，在这里直接获取token 。这里的获取token需要根据具体的项目 。比如我们所测试的项目正好是Bearer token这种形式 。直接在列表中使用这种方式输入{undefined{token}}即可。\n\n向集合添加请求，无需进行token处理，所有接口都能请求成功 。\n\n### API Key: 也有很多系统是通过这种认证方式，比如在请求头添加 model: data xxx-xxx-xxx-xxxx\n![img](/img/blog/postman/13/013-05.png)\n\n### Bearer Token:很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer Token 。那么使用这种认证就非常方便 。\n\n![img](/img/blog/postman/13/013-06.png)\n\n> 总之，需要认证方式要根据所测试的系统而定，通过Authorization来处理认证后，能大大节省我们的工作量。","source":"_posts/Postman/〖postman〗接口测试13-认证-Authorization.md","raw":"---\ntitle: 〖postman〗接口测试13-认证-Authorization\nabbrlink: dcc42dc3\ndate: 2022-02-11 22:13:55\ntags:\n - postman\ncategories:\n  - postman\n---\n\n# Authorization是什么？\n这又是一个非常实用的功能，对我们做接口测试来说，经常要处理登录认证的情况 。 <!-- more --> 如果不用这个Authorization其实也能解决认证的问题，无非就是把要认证的数据按照要求在指定位置传入参数即可。比如我们之前测试的系统，登录后返回的token要在每个请求接口的headers中传入 。这时就需要在每个headers中都填写一个认证参数传入 ，但是这样做的话太过繁琐，如果使用认证(Authorization)功能的话，就会大大简化了我们的认证过程。\n\n我们先来看下这个功能的具体位置及主要作用 。\n ![img](/img/blog/postman/13/013-01.png)\n\nInherit auto from parent:从父级继承身份验证，是每个请求的默认选择 。这是一个很有用的功能，当我们对一个集合(collection)进行测试的时候，集合中的每个请求都需要获取token，那么如果我们在集合中把token处理好的话，那么该集合下的所有请求都会自动获取到这个token，也就省略了我们对每个token进行处理了。\n\n### 实现步骤：\n![img](/img/blog/postman/13/013-02.png)\n\n ![img](/img/blog/postman/13/013-03.png)\n ![img](/img/blog/postman/13/013-04.png)\n\n\n### No Auth: 无需身份认证的可以选择这个 。\n选中一个集合进行编辑，切换到Pre-Request Script.在这里请求登录接口 ，将返回的token值拿到，然后保存成全局变量 。\n\n切换到Authorization选项卡，在这里直接获取token 。这里的获取token需要根据具体的项目 。比如我们所测试的项目正好是Bearer token这种形式 。直接在列表中使用这种方式输入{undefined{token}}即可。\n\n向集合添加请求，无需进行token处理，所有接口都能请求成功 。\n\n### API Key: 也有很多系统是通过这种认证方式，比如在请求头添加 model: data xxx-xxx-xxx-xxxx\n![img](/img/blog/postman/13/013-05.png)\n\n### Bearer Token:很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer Token 。那么使用这种认证就非常方便 。\n\n![img](/img/blog/postman/13/013-06.png)\n\n> 总之，需要认证方式要根据所测试的系统而定，通过Authorization来处理认证后，能大大节省我们的工作量。","slug":"Postman/〖postman〗接口测试13-认证-Authorization","published":1,"updated":"2022-02-11T14:13:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xf002in4ep25c65i4y","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"Authorization是什么？\"><a href=\"#Authorization是什么？\" class=\"headerlink\" title=\"Authorization是什么？\"></a>Authorization是什么？</h1><p>这又是一个非常实用的功能，对我们做接口测试来说，经常要处理登录认证的情况 。 <a id=\"more\"></a> 如果不用这个Authorization其实也能解决认证的问题，无非就是把要认证的数据按照要求在指定位置传入参数即可。比如我们之前测试的系统，登录后返回的token要在每个请求接口的headers中传入 。这时就需要在每个headers中都填写一个认证参数传入 ，但是这样做的话太过繁琐，如果使用认证(Authorization)功能的话，就会大大简化了我们的认证过程。</p>\n<p>我们先来看下这个功能的具体位置及主要作用 。<br> <img src=\"/img/blog/postman/13/013-01.png\" alt=\"img\"></p>\n<p>Inherit auto from parent:从父级继承身份验证，是每个请求的默认选择 。这是一个很有用的功能，当我们对一个集合(collection)进行测试的时候，集合中的每个请求都需要获取token，那么如果我们在集合中把token处理好的话，那么该集合下的所有请求都会自动获取到这个token，也就省略了我们对每个token进行处理了。</p>\n<h3 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a>实现步骤：</h3><p><img src=\"/img/blog/postman/13/013-02.png\" alt=\"img\"></p>\n<p> <img src=\"/img/blog/postman/13/013-03.png\" alt=\"img\"><br> <img src=\"/img/blog/postman/13/013-04.png\" alt=\"img\"></p>\n<h3 id=\"No-Auth-无需身份认证的可以选择这个-。\"><a href=\"#No-Auth-无需身份认证的可以选择这个-。\" class=\"headerlink\" title=\"No Auth: 无需身份认证的可以选择这个 。\"></a>No Auth: 无需身份认证的可以选择这个 。</h3><p>选中一个集合进行编辑，切换到Pre-Request Script.在这里请求登录接口 ，将返回的token值拿到，然后保存成全局变量 。</p>\n<p>切换到Authorization选项卡，在这里直接获取token 。这里的获取token需要根据具体的项目 。比如我们所测试的项目正好是Bearer token这种形式 。直接在列表中使用这种方式输入{undefined{token}}即可。</p>\n<p>向集合添加请求，无需进行token处理，所有接口都能请求成功 。</p>\n<h3 id=\"API-Key-也有很多系统是通过这种认证方式，比如在请求头添加-model-data-xxx-xxx-xxx-xxxx\"><a href=\"#API-Key-也有很多系统是通过这种认证方式，比如在请求头添加-model-data-xxx-xxx-xxx-xxxx\" class=\"headerlink\" title=\"API Key: 也有很多系统是通过这种认证方式，比如在请求头添加 model: data xxx-xxx-xxx-xxxx\"></a>API Key: 也有很多系统是通过这种认证方式，比如在请求头添加 model: data xxx-xxx-xxx-xxxx</h3><p><img src=\"/img/blog/postman/13/013-05.png\" alt=\"img\"></p>\n<h3 id=\"Bearer-Token-很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer-Token-。那么使用这种认证就非常方便-。\"><a href=\"#Bearer-Token-很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer-Token-。那么使用这种认证就非常方便-。\" class=\"headerlink\" title=\"Bearer Token:很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer Token 。那么使用这种认证就非常方便 。\"></a>Bearer Token:很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer Token 。那么使用这种认证就非常方便 。</h3><p><img src=\"/img/blog/postman/13/013-06.png\" alt=\"img\"></p>\n<blockquote>\n<p>总之，需要认证方式要根据所测试的系统而定，通过Authorization来处理认证后，能大大节省我们的工作量。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"Authorization是什么？\"><a href=\"#Authorization是什么？\" class=\"headerlink\" title=\"Authorization是什么？\"></a>Authorization是什么？</h1><p>这又是一个非常实用的功能，对我们做接口测试来说，经常要处理登录认证的情况 。","more":"如果不用这个Authorization其实也能解决认证的问题，无非就是把要认证的数据按照要求在指定位置传入参数即可。比如我们之前测试的系统，登录后返回的token要在每个请求接口的headers中传入 。这时就需要在每个headers中都填写一个认证参数传入 ，但是这样做的话太过繁琐，如果使用认证(Authorization)功能的话，就会大大简化了我们的认证过程。</p>\n<p>我们先来看下这个功能的具体位置及主要作用 。<br> <img src=\"/img/blog/postman/13/013-01.png\" alt=\"img\"></p>\n<p>Inherit auto from parent:从父级继承身份验证，是每个请求的默认选择 。这是一个很有用的功能，当我们对一个集合(collection)进行测试的时候，集合中的每个请求都需要获取token，那么如果我们在集合中把token处理好的话，那么该集合下的所有请求都会自动获取到这个token，也就省略了我们对每个token进行处理了。</p>\n<h3 id=\"实现步骤：\"><a href=\"#实现步骤：\" class=\"headerlink\" title=\"实现步骤：\"></a>实现步骤：</h3><p><img src=\"/img/blog/postman/13/013-02.png\" alt=\"img\"></p>\n<p> <img src=\"/img/blog/postman/13/013-03.png\" alt=\"img\"><br> <img src=\"/img/blog/postman/13/013-04.png\" alt=\"img\"></p>\n<h3 id=\"No-Auth-无需身份认证的可以选择这个-。\"><a href=\"#No-Auth-无需身份认证的可以选择这个-。\" class=\"headerlink\" title=\"No Auth: 无需身份认证的可以选择这个 。\"></a>No Auth: 无需身份认证的可以选择这个 。</h3><p>选中一个集合进行编辑，切换到Pre-Request Script.在这里请求登录接口 ，将返回的token值拿到，然后保存成全局变量 。</p>\n<p>切换到Authorization选项卡，在这里直接获取token 。这里的获取token需要根据具体的项目 。比如我们所测试的项目正好是Bearer token这种形式 。直接在列表中使用这种方式输入{undefined{token}}即可。</p>\n<p>向集合添加请求，无需进行token处理，所有接口都能请求成功 。</p>\n<h3 id=\"API-Key-也有很多系统是通过这种认证方式，比如在请求头添加-model-data-xxx-xxx-xxx-xxxx\"><a href=\"#API-Key-也有很多系统是通过这种认证方式，比如在请求头添加-model-data-xxx-xxx-xxx-xxxx\" class=\"headerlink\" title=\"API Key: 也有很多系统是通过这种认证方式，比如在请求头添加 model: data xxx-xxx-xxx-xxxx\"></a>API Key: 也有很多系统是通过这种认证方式，比如在请求头添加 model: data xxx-xxx-xxx-xxxx</h3><p><img src=\"/img/blog/postman/13/013-05.png\" alt=\"img\"></p>\n<h3 id=\"Bearer-Token-很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer-Token-。那么使用这种认证就非常方便-。\"><a href=\"#Bearer-Token-很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer-Token-。那么使用这种认证就非常方便-。\" class=\"headerlink\" title=\"Bearer Token:很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer Token 。那么使用这种认证就非常方便 。\"></a>Bearer Token:很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer Token 。那么使用这种认证就非常方便 。</h3><p><img src=\"/img/blog/postman/13/013-06.png\" alt=\"img\"></p>\n<blockquote>\n<p>总之，需要认证方式要根据所测试的系统而定，通过Authorization来处理认证后，能大大节省我们的工作量。</p>\n</blockquote>"},{"title":"〖postman〗接口测试15-快速查询与替换","abbrlink":"f5e730b6","date":"2022-02-16T14:47:59.000Z","_content":"\n有时候我们常会遇到这样一种问题，系统中有太多的用例，环境变量和系统变量的值也太多，查找其中的某个值太不方便；或者有的值想要修改，但苦于修改的地方太多，修改起来太费劲。那么，针对这样的困扰，是否有办法解决呢 ？ 答案是有的 ，那就是快速查询与批量替换。 <!-- more --> \n\n接下来我们先来了解这个功能的入口和简单介绍。\n\n ![img](/img/blog/postman/15/015-01.png)\n\n### 功能介绍：\n\nFIND:搜索输入框，在搜索框中输入你想要搜索的值，postman会自动到已打开的请求，集合，环境变量，全局变量中去搜索，如果搜索到，就会在右侧展示出搜素的结果 。其下方有俩个复选框，分别是Regex(正则匹配)和Ignore Case(忽略大小写)。\n\nWHERE:带条件查询，默认会选择everything（查询所有），如果想要选择某一个tab搜索，从下面选择即可，可以支持从集合、环境变量、全局变量以及以打开的请求中搜索 。\n\nREPLACE WITH: 替换文本框，在此文本框中输入替换的值，点击Replace in ... 按钮，会将搜索出的值全部替换 。\n\n右侧的搜索结果：搜索出对应的结果后，右侧每个tab中都会显示具体的数字，代表当前tab中匹配值的数量。你可以选择一个值点击Open，就会直接进入到对应的功能选项卡中 。\n\n### 案例说明：\n\n##### 案例1：按照正则表达式搜索11位数字。\n\n操作步骤：在搜索框中输入\\d{11}，勾选Regex,点击Find，右侧就会展示出还有11位数字的所有信息。\n\n![img](/img/blog/postman/15/015-02.png)\n\n##### 案例2：从集合中搜索\n\n在搜索框中输入搜索关键字，\n\n在WHERE中选择Choose entities to find in，选中Collections 。\n\n找到你想要的结果，点击Open in builder。就会直接打开对应请求tab.\n\n![img](/img/blog/postman/15/015-03.png)\n\n##### 案例3：替换某个字符串\n\n在查找搜索框中输入关键字，\n\n在REPLACE WITH框中输入想要替换的值，可以选择select All ,点击后面的按钮。\n\n再次搜索替换后的结果，发现所有值都已被替换 。\n\n![img](/img/blog/postman/15/015-04.png)\n\n>  总之，通过这个功能，我们可以快速找到我们想要的集合，环境变量，全局变量，请求或者代码块。","source":"_posts/Postman/〖postman〗接口测试15-快速查询与替换.md","raw":"---\ntitle: 〖postman〗接口测试15-快速查询与替换\nabbrlink: f5e730b6\ndate: 2022-02-16 22:47:59\ntags:\n - postman\ncategories:\n  - postman\n---\n\n有时候我们常会遇到这样一种问题，系统中有太多的用例，环境变量和系统变量的值也太多，查找其中的某个值太不方便；或者有的值想要修改，但苦于修改的地方太多，修改起来太费劲。那么，针对这样的困扰，是否有办法解决呢 ？ 答案是有的 ，那就是快速查询与批量替换。 <!-- more --> \n\n接下来我们先来了解这个功能的入口和简单介绍。\n\n ![img](/img/blog/postman/15/015-01.png)\n\n### 功能介绍：\n\nFIND:搜索输入框，在搜索框中输入你想要搜索的值，postman会自动到已打开的请求，集合，环境变量，全局变量中去搜索，如果搜索到，就会在右侧展示出搜素的结果 。其下方有俩个复选框，分别是Regex(正则匹配)和Ignore Case(忽略大小写)。\n\nWHERE:带条件查询，默认会选择everything（查询所有），如果想要选择某一个tab搜索，从下面选择即可，可以支持从集合、环境变量、全局变量以及以打开的请求中搜索 。\n\nREPLACE WITH: 替换文本框，在此文本框中输入替换的值，点击Replace in ... 按钮，会将搜索出的值全部替换 。\n\n右侧的搜索结果：搜索出对应的结果后，右侧每个tab中都会显示具体的数字，代表当前tab中匹配值的数量。你可以选择一个值点击Open，就会直接进入到对应的功能选项卡中 。\n\n### 案例说明：\n\n##### 案例1：按照正则表达式搜索11位数字。\n\n操作步骤：在搜索框中输入\\d{11}，勾选Regex,点击Find，右侧就会展示出还有11位数字的所有信息。\n\n![img](/img/blog/postman/15/015-02.png)\n\n##### 案例2：从集合中搜索\n\n在搜索框中输入搜索关键字，\n\n在WHERE中选择Choose entities to find in，选中Collections 。\n\n找到你想要的结果，点击Open in builder。就会直接打开对应请求tab.\n\n![img](/img/blog/postman/15/015-03.png)\n\n##### 案例3：替换某个字符串\n\n在查找搜索框中输入关键字，\n\n在REPLACE WITH框中输入想要替换的值，可以选择select All ,点击后面的按钮。\n\n再次搜索替换后的结果，发现所有值都已被替换 。\n\n![img](/img/blog/postman/15/015-04.png)\n\n>  总之，通过这个功能，我们可以快速找到我们想要的集合，环境变量，全局变量，请求或者代码块。","slug":"Postman/〖postman〗接口测试15-快速查询与替换","published":1,"updated":"2022-02-16T14:47:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xg002ln4ep34v06v04","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>有时候我们常会遇到这样一种问题，系统中有太多的用例，环境变量和系统变量的值也太多，查找其中的某个值太不方便；或者有的值想要修改，但苦于修改的地方太多，修改起来太费劲。那么，针对这样的困扰，是否有办法解决呢 ？ 答案是有的 ，那就是快速查询与批量替换。 <a id=\"more\"></a> </p>\n<p>接下来我们先来了解这个功能的入口和简单介绍。</p>\n<p> <img src=\"/img/blog/postman/15/015-01.png\" alt=\"img\"></p>\n<h3 id=\"功能介绍：\"><a href=\"#功能介绍：\" class=\"headerlink\" title=\"功能介绍：\"></a>功能介绍：</h3><p>FIND:搜索输入框，在搜索框中输入你想要搜索的值，postman会自动到已打开的请求，集合，环境变量，全局变量中去搜索，如果搜索到，就会在右侧展示出搜素的结果 。其下方有俩个复选框，分别是Regex(正则匹配)和Ignore Case(忽略大小写)。</p>\n<p>WHERE:带条件查询，默认会选择everything（查询所有），如果想要选择某一个tab搜索，从下面选择即可，可以支持从集合、环境变量、全局变量以及以打开的请求中搜索 。</p>\n<p>REPLACE WITH: 替换文本框，在此文本框中输入替换的值，点击Replace in … 按钮，会将搜索出的值全部替换 。</p>\n<p>右侧的搜索结果：搜索出对应的结果后，右侧每个tab中都会显示具体的数字，代表当前tab中匹配值的数量。你可以选择一个值点击Open，就会直接进入到对应的功能选项卡中 。</p>\n<h3 id=\"案例说明：\"><a href=\"#案例说明：\" class=\"headerlink\" title=\"案例说明：\"></a>案例说明：</h3><h5 id=\"案例1：按照正则表达式搜索11位数字。\"><a href=\"#案例1：按照正则表达式搜索11位数字。\" class=\"headerlink\" title=\"案例1：按照正则表达式搜索11位数字。\"></a>案例1：按照正则表达式搜索11位数字。</h5><p>操作步骤：在搜索框中输入\\d{11}，勾选Regex,点击Find，右侧就会展示出还有11位数字的所有信息。</p>\n<p><img src=\"/img/blog/postman/15/015-02.png\" alt=\"img\"></p>\n<h5 id=\"案例2：从集合中搜索\"><a href=\"#案例2：从集合中搜索\" class=\"headerlink\" title=\"案例2：从集合中搜索\"></a>案例2：从集合中搜索</h5><p>在搜索框中输入搜索关键字，</p>\n<p>在WHERE中选择Choose entities to find in，选中Collections 。</p>\n<p>找到你想要的结果，点击Open in builder。就会直接打开对应请求tab.</p>\n<p><img src=\"/img/blog/postman/15/015-03.png\" alt=\"img\"></p>\n<h5 id=\"案例3：替换某个字符串\"><a href=\"#案例3：替换某个字符串\" class=\"headerlink\" title=\"案例3：替换某个字符串\"></a>案例3：替换某个字符串</h5><p>在查找搜索框中输入关键字，</p>\n<p>在REPLACE WITH框中输入想要替换的值，可以选择select All ,点击后面的按钮。</p>\n<p>再次搜索替换后的结果，发现所有值都已被替换 。</p>\n<p><img src=\"/img/blog/postman/15/015-04.png\" alt=\"img\"></p>\n<blockquote>\n<p> 总之，通过这个功能，我们可以快速找到我们想要的集合，环境变量，全局变量，请求或者代码块。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>有时候我们常会遇到这样一种问题，系统中有太多的用例，环境变量和系统变量的值也太多，查找其中的某个值太不方便；或者有的值想要修改，但苦于修改的地方太多，修改起来太费劲。那么，针对这样的困扰，是否有办法解决呢 ？ 答案是有的 ，那就是快速查询与批量替换。","more":"</p>\n<p>接下来我们先来了解这个功能的入口和简单介绍。</p>\n<p> <img src=\"/img/blog/postman/15/015-01.png\" alt=\"img\"></p>\n<h3 id=\"功能介绍：\"><a href=\"#功能介绍：\" class=\"headerlink\" title=\"功能介绍：\"></a>功能介绍：</h3><p>FIND:搜索输入框，在搜索框中输入你想要搜索的值，postman会自动到已打开的请求，集合，环境变量，全局变量中去搜索，如果搜索到，就会在右侧展示出搜素的结果 。其下方有俩个复选框，分别是Regex(正则匹配)和Ignore Case(忽略大小写)。</p>\n<p>WHERE:带条件查询，默认会选择everything（查询所有），如果想要选择某一个tab搜索，从下面选择即可，可以支持从集合、环境变量、全局变量以及以打开的请求中搜索 。</p>\n<p>REPLACE WITH: 替换文本框，在此文本框中输入替换的值，点击Replace in … 按钮，会将搜索出的值全部替换 。</p>\n<p>右侧的搜索结果：搜索出对应的结果后，右侧每个tab中都会显示具体的数字，代表当前tab中匹配值的数量。你可以选择一个值点击Open，就会直接进入到对应的功能选项卡中 。</p>\n<h3 id=\"案例说明：\"><a href=\"#案例说明：\" class=\"headerlink\" title=\"案例说明：\"></a>案例说明：</h3><h5 id=\"案例1：按照正则表达式搜索11位数字。\"><a href=\"#案例1：按照正则表达式搜索11位数字。\" class=\"headerlink\" title=\"案例1：按照正则表达式搜索11位数字。\"></a>案例1：按照正则表达式搜索11位数字。</h5><p>操作步骤：在搜索框中输入\\d{11}，勾选Regex,点击Find，右侧就会展示出还有11位数字的所有信息。</p>\n<p><img src=\"/img/blog/postman/15/015-02.png\" alt=\"img\"></p>\n<h5 id=\"案例2：从集合中搜索\"><a href=\"#案例2：从集合中搜索\" class=\"headerlink\" title=\"案例2：从集合中搜索\"></a>案例2：从集合中搜索</h5><p>在搜索框中输入搜索关键字，</p>\n<p>在WHERE中选择Choose entities to find in，选中Collections 。</p>\n<p>找到你想要的结果，点击Open in builder。就会直接打开对应请求tab.</p>\n<p><img src=\"/img/blog/postman/15/015-03.png\" alt=\"img\"></p>\n<h5 id=\"案例3：替换某个字符串\"><a href=\"#案例3：替换某个字符串\" class=\"headerlink\" title=\"案例3：替换某个字符串\"></a>案例3：替换某个字符串</h5><p>在查找搜索框中输入关键字，</p>\n<p>在REPLACE WITH框中输入想要替换的值，可以选择select All ,点击后面的按钮。</p>\n<p>再次搜索替换后的结果，发现所有值都已被替换 。</p>\n<p><img src=\"/img/blog/postman/15/015-04.png\" alt=\"img\"></p>\n<blockquote>\n<p> 总之，通过这个功能，我们可以快速找到我们想要的集合，环境变量，全局变量，请求或者代码块。</p>\n</blockquote>"},{"title":"〖postman〗接口测试16-生成测试报告","abbrlink":"43b8c324","date":"2022-02-20T08:54:38.000Z","_content":"\n# 生成测试报告\n\npostman生成测试报告需要一个插件：newman ，并且这个插件需要先安装 。 <!-- more --> \n\n## 安装步骤：\n\n1. 安装nodejs: newman是由nodejs开发，所以要先安装它的运行环境，下载地址：http://nodejs.cn/download/ 。安装成功后需要验证：在cmd窗口中输入node -v,如果输出node的版本信息，则证明安装成功。\n\n2. 安装newman：安装成功nodejs后，会自动安装一个包管理工具npm(类似于python中的pip)。通过它就可以直接安装newman。 打开cmd窗口输入：npm install -g newman .安装成功后进行验证：newman -v 。如果输出newman的版本信息，则证明安装成功 。\n\n3. 安装newman-reporter-html:通过这个插件可以指定报告的生成路径和名称。同样打开cmd窗口输入：npm install -g newman-reporter-html.安装成功后进行验证：npm list -g --depth 0.如果能出现newman-reporter-html包及版本及证明安装成功 。\n\n通过newman生成测试报告必须在cmd执行，命令执行：newman run <collection> [options] ，其中options中有很多参数，接下来我们来解析这些参数。\n\n### 命令解析：\n- -e : 可选，指定一个URL或者postman的环境变量脚本文件。如果集合中指定了环境变量，则需要添加这个参数。\n\n- -g：可选，指定一个URL或者postman的全局变量脚本文件，如果集合中指定了全局变量，则需要加这个参数 。\n\n- -r：可选，指定测试报告的类型，如果想生成对应的报告类型，需要添加这个参数，典型的有html,json,cli，若不添加，默认为cli。\n\n- -d：可选，指定一个数据参数化文件 ，如果有参数化文件，需要添加这个选项。\n\n- --reporter-html-export：可选，指定生成报告的路径和文件名，如果不添加该参数，默认会生成一个newman的文件夹，里面存放着生成的测试报告\n\n输入的命令就可以是下面这样的 。\n\n> newman run collect_a.json [-e environment_b.json] [-r html] [--reporter-html-export report.html]  其中[]内的参数是可选的。\n\n### 案例说明：\n#### 案例1：通过newman生成测试报告，集合为一个URL。\n\n##### 命令：\n\n```\nnewman run https://www.getpostman.com/collections/6e95413b91fe582ec78d\n```\n\n说明：run后面跟的链接可以通过分享得到\n\n#### 案例2：通过newman生成测试报告，报告格式为默认:cli\n\n```\nnewman run A.postman_collection.json  -r cli //默认的展示结果如下图所示。\n```\n\n\n![img](/img/blog/postman/16/016-01.png)\n\n\n#### 案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告 。\n\n```\nnewman run B.postman_collection.json -e test.postman_environment.json -r html\n```\n\n\n#### 案例4：通过newman生成测试报告，需要制定报告路径和文件名称。\n\n```\nnewman run B.postman_collection.json -e test.postman_environment.json -r html --reporter-html-export report.html\n```\n\n//生成的测试报告会存放在当前路径下，报告名为：report.html\n\n> 虽然newman提供了强大的生成测试报告功能，但是目前为止，生成的测试报告都是在我们本地，那如果想要把报告展示给团队成员查看呢 ？ 我们就可以通过jenkins进行持续集成，把生成的报告展示在Jenkins上，甚至可以将报告通过邮件发送给团队成员 。","source":"_posts/Postman/〖postman〗接口测试16-生成测试报告.md","raw":"---\ntitle: 〖postman〗接口测试16-生成测试报告\nabbrlink: 43b8c324\ndate: 2022-02-20 16:54:38\ntags:\n - postman\ncategories:\n  - postman\n---\n\n# 生成测试报告\n\npostman生成测试报告需要一个插件：newman ，并且这个插件需要先安装 。 <!-- more --> \n\n## 安装步骤：\n\n1. 安装nodejs: newman是由nodejs开发，所以要先安装它的运行环境，下载地址：http://nodejs.cn/download/ 。安装成功后需要验证：在cmd窗口中输入node -v,如果输出node的版本信息，则证明安装成功。\n\n2. 安装newman：安装成功nodejs后，会自动安装一个包管理工具npm(类似于python中的pip)。通过它就可以直接安装newman。 打开cmd窗口输入：npm install -g newman .安装成功后进行验证：newman -v 。如果输出newman的版本信息，则证明安装成功 。\n\n3. 安装newman-reporter-html:通过这个插件可以指定报告的生成路径和名称。同样打开cmd窗口输入：npm install -g newman-reporter-html.安装成功后进行验证：npm list -g --depth 0.如果能出现newman-reporter-html包及版本及证明安装成功 。\n\n通过newman生成测试报告必须在cmd执行，命令执行：newman run <collection> [options] ，其中options中有很多参数，接下来我们来解析这些参数。\n\n### 命令解析：\n- -e : 可选，指定一个URL或者postman的环境变量脚本文件。如果集合中指定了环境变量，则需要添加这个参数。\n\n- -g：可选，指定一个URL或者postman的全局变量脚本文件，如果集合中指定了全局变量，则需要加这个参数 。\n\n- -r：可选，指定测试报告的类型，如果想生成对应的报告类型，需要添加这个参数，典型的有html,json,cli，若不添加，默认为cli。\n\n- -d：可选，指定一个数据参数化文件 ，如果有参数化文件，需要添加这个选项。\n\n- --reporter-html-export：可选，指定生成报告的路径和文件名，如果不添加该参数，默认会生成一个newman的文件夹，里面存放着生成的测试报告\n\n输入的命令就可以是下面这样的 。\n\n> newman run collect_a.json [-e environment_b.json] [-r html] [--reporter-html-export report.html]  其中[]内的参数是可选的。\n\n### 案例说明：\n#### 案例1：通过newman生成测试报告，集合为一个URL。\n\n##### 命令：\n\n```\nnewman run https://www.getpostman.com/collections/6e95413b91fe582ec78d\n```\n\n说明：run后面跟的链接可以通过分享得到\n\n#### 案例2：通过newman生成测试报告，报告格式为默认:cli\n\n```\nnewman run A.postman_collection.json  -r cli //默认的展示结果如下图所示。\n```\n\n\n![img](/img/blog/postman/16/016-01.png)\n\n\n#### 案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告 。\n\n```\nnewman run B.postman_collection.json -e test.postman_environment.json -r html\n```\n\n\n#### 案例4：通过newman生成测试报告，需要制定报告路径和文件名称。\n\n```\nnewman run B.postman_collection.json -e test.postman_environment.json -r html --reporter-html-export report.html\n```\n\n//生成的测试报告会存放在当前路径下，报告名为：report.html\n\n> 虽然newman提供了强大的生成测试报告功能，但是目前为止，生成的测试报告都是在我们本地，那如果想要把报告展示给团队成员查看呢 ？ 我们就可以通过jenkins进行持续集成，把生成的报告展示在Jenkins上，甚至可以将报告通过邮件发送给团队成员 。","slug":"Postman/〖postman〗接口测试16-生成测试报告","published":1,"updated":"2022-02-20T08:54:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xh002qn4epez0o2kdn","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"生成测试报告\"><a href=\"#生成测试报告\" class=\"headerlink\" title=\"生成测试报告\"></a>生成测试报告</h1><p>postman生成测试报告需要一个插件：newman ，并且这个插件需要先安装 。 <a id=\"more\"></a> </p>\n<h2 id=\"安装步骤：\"><a href=\"#安装步骤：\" class=\"headerlink\" title=\"安装步骤：\"></a>安装步骤：</h2><ol>\n<li><p>安装nodejs: newman是由nodejs开发，所以要先安装它的运行环境，下载地址：<a href=\"http://nodejs.cn/download/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/download/</a> 。安装成功后需要验证：在cmd窗口中输入node -v,如果输出node的版本信息，则证明安装成功。</p>\n</li>\n<li><p>安装newman：安装成功nodejs后，会自动安装一个包管理工具npm(类似于python中的pip)。通过它就可以直接安装newman。 打开cmd窗口输入：npm install -g newman .安装成功后进行验证：newman -v 。如果输出newman的版本信息，则证明安装成功 。</p>\n</li>\n<li><p>安装newman-reporter-html:通过这个插件可以指定报告的生成路径和名称。同样打开cmd窗口输入：npm install -g newman-reporter-html.安装成功后进行验证：npm list -g –depth 0.如果能出现newman-reporter-html包及版本及证明安装成功 。</p>\n</li>\n</ol>\n<p>通过newman生成测试报告必须在cmd执行，命令执行：newman run <collection> [options] ，其中options中有很多参数，接下来我们来解析这些参数。</p>\n<h3 id=\"命令解析：\"><a href=\"#命令解析：\" class=\"headerlink\" title=\"命令解析：\"></a>命令解析：</h3><ul>\n<li><p>-e : 可选，指定一个URL或者postman的环境变量脚本文件。如果集合中指定了环境变量，则需要添加这个参数。</p>\n</li>\n<li><p>-g：可选，指定一个URL或者postman的全局变量脚本文件，如果集合中指定了全局变量，则需要加这个参数 。</p>\n</li>\n<li><p>-r：可选，指定测试报告的类型，如果想生成对应的报告类型，需要添加这个参数，典型的有html,json,cli，若不添加，默认为cli。</p>\n</li>\n<li><p>-d：可选，指定一个数据参数化文件 ，如果有参数化文件，需要添加这个选项。</p>\n</li>\n<li><p>–reporter-html-export：可选，指定生成报告的路径和文件名，如果不添加该参数，默认会生成一个newman的文件夹，里面存放着生成的测试报告</p>\n</li>\n</ul>\n<p>输入的命令就可以是下面这样的 。</p>\n<blockquote>\n<p>newman run collect_a.json [-e environment_b.json] [-r html] [–reporter-html-export report.html]  其中[]内的参数是可选的。</p>\n</blockquote>\n<h3 id=\"案例说明：\"><a href=\"#案例说明：\" class=\"headerlink\" title=\"案例说明：\"></a>案例说明：</h3><h4 id=\"案例1：通过newman生成测试报告，集合为一个URL。\"><a href=\"#案例1：通过newman生成测试报告，集合为一个URL。\" class=\"headerlink\" title=\"案例1：通过newman生成测试报告，集合为一个URL。\"></a>案例1：通过newman生成测试报告，集合为一个URL。</h4><h5 id=\"命令：\"><a href=\"#命令：\" class=\"headerlink\" title=\"命令：\"></a>命令：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newman run https:&#x2F;&#x2F;www.getpostman.com&#x2F;collections&#x2F;6e95413b91fe582ec78d</span><br></pre></td></tr></table></figure>\n\n<p>说明：run后面跟的链接可以通过分享得到</p>\n<h4 id=\"案例2：通过newman生成测试报告，报告格式为默认-cli\"><a href=\"#案例2：通过newman生成测试报告，报告格式为默认-cli\" class=\"headerlink\" title=\"案例2：通过newman生成测试报告，报告格式为默认:cli\"></a>案例2：通过newman生成测试报告，报告格式为默认:cli</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newman run A.postman_collection.json  -r cli &#x2F;&#x2F;默认的展示结果如下图所示。</span><br></pre></td></tr></table></figure>\n\n\n<p><img src=\"/img/blog/postman/16/016-01.png\" alt=\"img\"></p>\n<h4 id=\"案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告-。\"><a href=\"#案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告-。\" class=\"headerlink\" title=\"案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告 。\"></a>案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告 。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newman run B.postman_collection.json -e test.postman_environment.json -r html</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"案例4：通过newman生成测试报告，需要制定报告路径和文件名称。\"><a href=\"#案例4：通过newman生成测试报告，需要制定报告路径和文件名称。\" class=\"headerlink\" title=\"案例4：通过newman生成测试报告，需要制定报告路径和文件名称。\"></a>案例4：通过newman生成测试报告，需要制定报告路径和文件名称。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newman run B.postman_collection.json -e test.postman_environment.json -r html --reporter-html-export report.html</span><br></pre></td></tr></table></figure>\n\n<p>//生成的测试报告会存放在当前路径下，报告名为：report.html</p>\n<blockquote>\n<p>虽然newman提供了强大的生成测试报告功能，但是目前为止，生成的测试报告都是在我们本地，那如果想要把报告展示给团队成员查看呢 ？ 我们就可以通过jenkins进行持续集成，把生成的报告展示在Jenkins上，甚至可以将报告通过邮件发送给团队成员 。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"生成测试报告\"><a href=\"#生成测试报告\" class=\"headerlink\" title=\"生成测试报告\"></a>生成测试报告</h1><p>postman生成测试报告需要一个插件：newman ，并且这个插件需要先安装 。","more":"</p>\n<h2 id=\"安装步骤：\"><a href=\"#安装步骤：\" class=\"headerlink\" title=\"安装步骤：\"></a>安装步骤：</h2><ol>\n<li><p>安装nodejs: newman是由nodejs开发，所以要先安装它的运行环境，下载地址：<a href=\"http://nodejs.cn/download/\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/download/</a> 。安装成功后需要验证：在cmd窗口中输入node -v,如果输出node的版本信息，则证明安装成功。</p>\n</li>\n<li><p>安装newman：安装成功nodejs后，会自动安装一个包管理工具npm(类似于python中的pip)。通过它就可以直接安装newman。 打开cmd窗口输入：npm install -g newman .安装成功后进行验证：newman -v 。如果输出newman的版本信息，则证明安装成功 。</p>\n</li>\n<li><p>安装newman-reporter-html:通过这个插件可以指定报告的生成路径和名称。同样打开cmd窗口输入：npm install -g newman-reporter-html.安装成功后进行验证：npm list -g –depth 0.如果能出现newman-reporter-html包及版本及证明安装成功 。</p>\n</li>\n</ol>\n<p>通过newman生成测试报告必须在cmd执行，命令执行：newman run <collection> [options] ，其中options中有很多参数，接下来我们来解析这些参数。</p>\n<h3 id=\"命令解析：\"><a href=\"#命令解析：\" class=\"headerlink\" title=\"命令解析：\"></a>命令解析：</h3><ul>\n<li><p>-e : 可选，指定一个URL或者postman的环境变量脚本文件。如果集合中指定了环境变量，则需要添加这个参数。</p>\n</li>\n<li><p>-g：可选，指定一个URL或者postman的全局变量脚本文件，如果集合中指定了全局变量，则需要加这个参数 。</p>\n</li>\n<li><p>-r：可选，指定测试报告的类型，如果想生成对应的报告类型，需要添加这个参数，典型的有html,json,cli，若不添加，默认为cli。</p>\n</li>\n<li><p>-d：可选，指定一个数据参数化文件 ，如果有参数化文件，需要添加这个选项。</p>\n</li>\n<li><p>–reporter-html-export：可选，指定生成报告的路径和文件名，如果不添加该参数，默认会生成一个newman的文件夹，里面存放着生成的测试报告</p>\n</li>\n</ul>\n<p>输入的命令就可以是下面这样的 。</p>\n<blockquote>\n<p>newman run collect_a.json [-e environment_b.json] [-r html] [–reporter-html-export report.html]  其中[]内的参数是可选的。</p>\n</blockquote>\n<h3 id=\"案例说明：\"><a href=\"#案例说明：\" class=\"headerlink\" title=\"案例说明：\"></a>案例说明：</h3><h4 id=\"案例1：通过newman生成测试报告，集合为一个URL。\"><a href=\"#案例1：通过newman生成测试报告，集合为一个URL。\" class=\"headerlink\" title=\"案例1：通过newman生成测试报告，集合为一个URL。\"></a>案例1：通过newman生成测试报告，集合为一个URL。</h4><h5 id=\"命令：\"><a href=\"#命令：\" class=\"headerlink\" title=\"命令：\"></a>命令：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newman run https:&#x2F;&#x2F;www.getpostman.com&#x2F;collections&#x2F;6e95413b91fe582ec78d</span><br></pre></td></tr></table></figure>\n\n<p>说明：run后面跟的链接可以通过分享得到</p>\n<h4 id=\"案例2：通过newman生成测试报告，报告格式为默认-cli\"><a href=\"#案例2：通过newman生成测试报告，报告格式为默认-cli\" class=\"headerlink\" title=\"案例2：通过newman生成测试报告，报告格式为默认:cli\"></a>案例2：通过newman生成测试报告，报告格式为默认:cli</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newman run A.postman_collection.json  -r cli &#x2F;&#x2F;默认的展示结果如下图所示。</span><br></pre></td></tr></table></figure>\n\n\n<p><img src=\"/img/blog/postman/16/016-01.png\" alt=\"img\"></p>\n<h4 id=\"案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告-。\"><a href=\"#案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告-。\" class=\"headerlink\" title=\"案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告 。\"></a>案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告 。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newman run B.postman_collection.json -e test.postman_environment.json -r html</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"案例4：通过newman生成测试报告，需要制定报告路径和文件名称。\"><a href=\"#案例4：通过newman生成测试报告，需要制定报告路径和文件名称。\" class=\"headerlink\" title=\"案例4：通过newman生成测试报告，需要制定报告路径和文件名称。\"></a>案例4：通过newman生成测试报告，需要制定报告路径和文件名称。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newman run B.postman_collection.json -e test.postman_environment.json -r html --reporter-html-export report.html</span><br></pre></td></tr></table></figure>\n\n<p>//生成的测试报告会存放在当前路径下，报告名为：report.html</p>\n<blockquote>\n<p>虽然newman提供了强大的生成测试报告功能，但是目前为止，生成的测试报告都是在我们本地，那如果想要把报告展示给团队成员查看呢 ？ 我们就可以通过jenkins进行持续集成，把生成的报告展示在Jenkins上，甚至可以将报告通过邮件发送给团队成员 。</p>\n</blockquote>"},{"title":"〖postman〗接口测试14-导入导出","abbrlink":"6172e27e","date":"2022-02-15T14:59:55.000Z","_content":"\n这又是一个非常实用的功能。可以将postman中的集合脚本，环境变量、全局变量导出，然后分享到团队成员，也可以通过导出后的脚本通过newman生成测试报告。更牛的是可以把浏览器，抓包工具，接口文档(swagger)中的数据包导入到postman中，并且会自动生成一个请求 。非常非常的方便 。 <!-- more --> \n\n## 1.导出\n\n### 导出集合脚本\n\n选择其中一个集合，点击右边的三个点（...）,选择‘export’.\n\n在弹出的对话框Collection v2.1(recommended),点击‘Export’ .\n\n选择本地路径保存即可，默认导入的文件格式是json且文件名中含有Collection,这样能区分出是集合文件 。\n\n### 导出环境/全局变量\n\n选择右上角的小齿轮(MANAGE ENVIRONMENT)，\n\n如果是选择环境变量导出，只需要在点击对应环境的下载图标\n\n如果是选择全局变量导出，点击Globals,再点击Download as JSON .\n\n选择本地路径保存即可，默认导出的文件格式是json文件名找那个含有environemnt或globals，可以区分出这是环境变量文件或全局变量文件\n\n ![img](/img/blog/postman/14/014-01.png) \n\n简单来说，导出后的文件主要就是以下几个目的：\n\n​\t分享给团队成员\n\n​\t生成测试报告\n\n​\t数据备份\n\n## 2.导入\n\n导入有四个选项，支持从文件导入，文件夹导入，从链接导入，粘贴文本导入。导入的入口：\n\n ![img](/img/blog/postman/14/014-02.png) \n\n### Import File：从文件导入\n\n可以支持集合文件导入，环境/全局变量文件导入(json)，通过抓包工具保存的请求文件导入 。\n\n无论是导入集合文件还是变量文件，都需要提前把对应的文件导出 。 当然此功能的使用场景就是团队成员相互分享脚本 。\n\n  ![img](/img/blog/postman/14/014-03.png) \n\n### 导入fiddler数据：\n\n可以将fiddler的抓取到的数据包导出，然后在postman中导入，就会在postman自动生成请求，无需任何修改 。具体实现步骤如下：\n\n从fiddler中选择一个请求，然后导出脚本文件 。\n\n在postman中的import File 中导入即可\n\n会自动将请求转变成postman脚本。\n\n ![img](/img/blog/postman/14/014-04.png) \n\n ![img](/img/blog/postman/14/014-05.png) \n\n ![img](/img/blog/postman/14/014-06.png) \n\n### Import Folder：选择从文件夹导入。\n\n有时候我们导出的集合需要用到环境变量，所以，需要把集合文件和环境变量文件都要导出，把它们放在一个文件夹下，如团队成员需要时，可以选择Import Folder直接一次性都导入即可。\n\n### Import From Link：通过链接导入也可以将集合分享给团队成员。\n\n但 使用这个功能需要先注册账号且登录才可以 。具体实现步骤如下 ：\n\n选择一个集合，点击分享\n\n ![img](/img/blog/postman/14/014-07.png) \n\n在弹出的界面点击Get public link\n\n ![img](/img/blog/postman/14/014-08.png)\n\n ![img](/img/blog/postman/14/014-09.png)  \n\n\n\n 选择Import-Import From Link 进行导入\n\n ![img](/img/blog/postman/14/014-10.png) \n\nPaste Raw Text：这个功能可以将浏览器的数据包或接口文档（swagger）的数据粘贴进来自动生成请求 ，无需任何修改，就可以直接发送请求 。非常的赞 。\n\n实现步骤：\n\n在浏览器中抓取到想要的包，然后右键copy出Curl的数据包\n\n在postman的import中将数据粘贴进来，就会自动生成了对应的请求 。\n\n  ![img](/img/blog/postman/14/014-11.png) \n\n ![img](/img/blog/postman/14/014-12.png) \n\n ![img](/img/blog/postman/14/014-13.png) \n\n下面的这个截图是从接口文档swagger，将这个数据包拷贝粘贴到上面的文本中(Paste Raw Text) 也可以自动生成请求 。\n\n ![img](/img/blog/postman/14/014-14.png) \n\n \n\n>  总之，这个功能非常实用，尤其是可以把浏览器或抓包工具中的数据包导入进来直接使用，大大的减少了我们的接口实现时间 。\n\n  <！--more--> ","source":"_posts/Postman/〖postman〗接口测试14-导入导出.md","raw":"---\ntitle: 〖postman〗接口测试14-导入导出\ntags:\n  - postman\ncategories:\n  - postman\nabbrlink: 6172e27e\ndate: 2022-02-15 22:59:55\n---\n\n这又是一个非常实用的功能。可以将postman中的集合脚本，环境变量、全局变量导出，然后分享到团队成员，也可以通过导出后的脚本通过newman生成测试报告。更牛的是可以把浏览器，抓包工具，接口文档(swagger)中的数据包导入到postman中，并且会自动生成一个请求 。非常非常的方便 。 <!-- more --> \n\n## 1.导出\n\n### 导出集合脚本\n\n选择其中一个集合，点击右边的三个点（...）,选择‘export’.\n\n在弹出的对话框Collection v2.1(recommended),点击‘Export’ .\n\n选择本地路径保存即可，默认导入的文件格式是json且文件名中含有Collection,这样能区分出是集合文件 。\n\n### 导出环境/全局变量\n\n选择右上角的小齿轮(MANAGE ENVIRONMENT)，\n\n如果是选择环境变量导出，只需要在点击对应环境的下载图标\n\n如果是选择全局变量导出，点击Globals,再点击Download as JSON .\n\n选择本地路径保存即可，默认导出的文件格式是json文件名找那个含有environemnt或globals，可以区分出这是环境变量文件或全局变量文件\n\n ![img](/img/blog/postman/14/014-01.png) \n\n简单来说，导出后的文件主要就是以下几个目的：\n\n​\t分享给团队成员\n\n​\t生成测试报告\n\n​\t数据备份\n\n## 2.导入\n\n导入有四个选项，支持从文件导入，文件夹导入，从链接导入，粘贴文本导入。导入的入口：\n\n ![img](/img/blog/postman/14/014-02.png) \n\n### Import File：从文件导入\n\n可以支持集合文件导入，环境/全局变量文件导入(json)，通过抓包工具保存的请求文件导入 。\n\n无论是导入集合文件还是变量文件，都需要提前把对应的文件导出 。 当然此功能的使用场景就是团队成员相互分享脚本 。\n\n  ![img](/img/blog/postman/14/014-03.png) \n\n### 导入fiddler数据：\n\n可以将fiddler的抓取到的数据包导出，然后在postman中导入，就会在postman自动生成请求，无需任何修改 。具体实现步骤如下：\n\n从fiddler中选择一个请求，然后导出脚本文件 。\n\n在postman中的import File 中导入即可\n\n会自动将请求转变成postman脚本。\n\n ![img](/img/blog/postman/14/014-04.png) \n\n ![img](/img/blog/postman/14/014-05.png) \n\n ![img](/img/blog/postman/14/014-06.png) \n\n### Import Folder：选择从文件夹导入。\n\n有时候我们导出的集合需要用到环境变量，所以，需要把集合文件和环境变量文件都要导出，把它们放在一个文件夹下，如团队成员需要时，可以选择Import Folder直接一次性都导入即可。\n\n### Import From Link：通过链接导入也可以将集合分享给团队成员。\n\n但 使用这个功能需要先注册账号且登录才可以 。具体实现步骤如下 ：\n\n选择一个集合，点击分享\n\n ![img](/img/blog/postman/14/014-07.png) \n\n在弹出的界面点击Get public link\n\n ![img](/img/blog/postman/14/014-08.png)\n\n ![img](/img/blog/postman/14/014-09.png)  \n\n\n\n 选择Import-Import From Link 进行导入\n\n ![img](/img/blog/postman/14/014-10.png) \n\nPaste Raw Text：这个功能可以将浏览器的数据包或接口文档（swagger）的数据粘贴进来自动生成请求 ，无需任何修改，就可以直接发送请求 。非常的赞 。\n\n实现步骤：\n\n在浏览器中抓取到想要的包，然后右键copy出Curl的数据包\n\n在postman的import中将数据粘贴进来，就会自动生成了对应的请求 。\n\n  ![img](/img/blog/postman/14/014-11.png) \n\n ![img](/img/blog/postman/14/014-12.png) \n\n ![img](/img/blog/postman/14/014-13.png) \n\n下面的这个截图是从接口文档swagger，将这个数据包拷贝粘贴到上面的文本中(Paste Raw Text) 也可以自动生成请求 。\n\n ![img](/img/blog/postman/14/014-14.png) \n\n \n\n>  总之，这个功能非常实用，尤其是可以把浏览器或抓包工具中的数据包导入进来直接使用，大大的减少了我们的接口实现时间 。\n\n  <！--more--> ","slug":"Postman/〖postman〗接口测试14-导入导出","published":1,"updated":"2022-02-15T14:59:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xi002tn4ep3mutave4","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>这又是一个非常实用的功能。可以将postman中的集合脚本，环境变量、全局变量导出，然后分享到团队成员，也可以通过导出后的脚本通过newman生成测试报告。更牛的是可以把浏览器，抓包工具，接口文档(swagger)中的数据包导入到postman中，并且会自动生成一个请求 。非常非常的方便 。 <a id=\"more\"></a> </p>\n<h2 id=\"1-导出\"><a href=\"#1-导出\" class=\"headerlink\" title=\"1.导出\"></a>1.导出</h2><h3 id=\"导出集合脚本\"><a href=\"#导出集合脚本\" class=\"headerlink\" title=\"导出集合脚本\"></a>导出集合脚本</h3><p>选择其中一个集合，点击右边的三个点（…）,选择‘export’.</p>\n<p>在弹出的对话框Collection v2.1(recommended),点击‘Export’ .</p>\n<p>选择本地路径保存即可，默认导入的文件格式是json且文件名中含有Collection,这样能区分出是集合文件 。</p>\n<h3 id=\"导出环境-全局变量\"><a href=\"#导出环境-全局变量\" class=\"headerlink\" title=\"导出环境/全局变量\"></a>导出环境/全局变量</h3><p>选择右上角的小齿轮(MANAGE ENVIRONMENT)，</p>\n<p>如果是选择环境变量导出，只需要在点击对应环境的下载图标</p>\n<p>如果是选择全局变量导出，点击Globals,再点击Download as JSON .</p>\n<p>选择本地路径保存即可，默认导出的文件格式是json文件名找那个含有environemnt或globals，可以区分出这是环境变量文件或全局变量文件</p>\n<p> <img src=\"/img/blog/postman/14/014-01.png\" alt=\"img\"> </p>\n<p>简单来说，导出后的文件主要就是以下几个目的：</p>\n<p>​    分享给团队成员</p>\n<p>​    生成测试报告</p>\n<p>​    数据备份</p>\n<h2 id=\"2-导入\"><a href=\"#2-导入\" class=\"headerlink\" title=\"2.导入\"></a>2.导入</h2><p>导入有四个选项，支持从文件导入，文件夹导入，从链接导入，粘贴文本导入。导入的入口：</p>\n<p> <img src=\"/img/blog/postman/14/014-02.png\" alt=\"img\"> </p>\n<h3 id=\"Import-File：从文件导入\"><a href=\"#Import-File：从文件导入\" class=\"headerlink\" title=\"Import File：从文件导入\"></a>Import File：从文件导入</h3><p>可以支持集合文件导入，环境/全局变量文件导入(json)，通过抓包工具保存的请求文件导入 。</p>\n<p>无论是导入集合文件还是变量文件，都需要提前把对应的文件导出 。 当然此功能的使用场景就是团队成员相互分享脚本 。</p>\n<p>  <img src=\"/img/blog/postman/14/014-03.png\" alt=\"img\"> </p>\n<h3 id=\"导入fiddler数据：\"><a href=\"#导入fiddler数据：\" class=\"headerlink\" title=\"导入fiddler数据：\"></a>导入fiddler数据：</h3><p>可以将fiddler的抓取到的数据包导出，然后在postman中导入，就会在postman自动生成请求，无需任何修改 。具体实现步骤如下：</p>\n<p>从fiddler中选择一个请求，然后导出脚本文件 。</p>\n<p>在postman中的import File 中导入即可</p>\n<p>会自动将请求转变成postman脚本。</p>\n<p> <img src=\"/img/blog/postman/14/014-04.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/blog/postman/14/014-05.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/blog/postman/14/014-06.png\" alt=\"img\"> </p>\n<h3 id=\"Import-Folder：选择从文件夹导入。\"><a href=\"#Import-Folder：选择从文件夹导入。\" class=\"headerlink\" title=\"Import Folder：选择从文件夹导入。\"></a>Import Folder：选择从文件夹导入。</h3><p>有时候我们导出的集合需要用到环境变量，所以，需要把集合文件和环境变量文件都要导出，把它们放在一个文件夹下，如团队成员需要时，可以选择Import Folder直接一次性都导入即可。</p>\n<h3 id=\"Import-From-Link：通过链接导入也可以将集合分享给团队成员。\"><a href=\"#Import-From-Link：通过链接导入也可以将集合分享给团队成员。\" class=\"headerlink\" title=\"Import From Link：通过链接导入也可以将集合分享给团队成员。\"></a>Import From Link：通过链接导入也可以将集合分享给团队成员。</h3><p>但 使用这个功能需要先注册账号且登录才可以 。具体实现步骤如下 ：</p>\n<p>选择一个集合，点击分享</p>\n<p> <img src=\"/img/blog/postman/14/014-07.png\" alt=\"img\"> </p>\n<p>在弹出的界面点击Get public link</p>\n<p> <img src=\"/img/blog/postman/14/014-08.png\" alt=\"img\"></p>\n<p> <img src=\"/img/blog/postman/14/014-09.png\" alt=\"img\">  </p>\n<p> 选择Import-Import From Link 进行导入</p>\n<p> <img src=\"/img/blog/postman/14/014-10.png\" alt=\"img\"> </p>\n<p>Paste Raw Text：这个功能可以将浏览器的数据包或接口文档（swagger）的数据粘贴进来自动生成请求 ，无需任何修改，就可以直接发送请求 。非常的赞 。</p>\n<p>实现步骤：</p>\n<p>在浏览器中抓取到想要的包，然后右键copy出Curl的数据包</p>\n<p>在postman的import中将数据粘贴进来，就会自动生成了对应的请求 。</p>\n<p>  <img src=\"/img/blog/postman/14/014-11.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/blog/postman/14/014-12.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/blog/postman/14/014-13.png\" alt=\"img\"> </p>\n<p>下面的这个截图是从接口文档swagger，将这个数据包拷贝粘贴到上面的文本中(Paste Raw Text) 也可以自动生成请求 。</p>\n<p> <img src=\"/img/blog/postman/14/014-14.png\" alt=\"img\"> </p>\n<blockquote>\n<p> 总之，这个功能非常实用，尤其是可以把浏览器或抓包工具中的数据包导入进来直接使用，大大的减少了我们的接口实现时间 。</p>\n</blockquote>\n<p>  &lt;！–more–&gt; </p>\n","site":{"data":{}},"excerpt":"<p>这又是一个非常实用的功能。可以将postman中的集合脚本，环境变量、全局变量导出，然后分享到团队成员，也可以通过导出后的脚本通过newman生成测试报告。更牛的是可以把浏览器，抓包工具，接口文档(swagger)中的数据包导入到postman中，并且会自动生成一个请求 。非常非常的方便 。","more":"</p>\n<h2 id=\"1-导出\"><a href=\"#1-导出\" class=\"headerlink\" title=\"1.导出\"></a>1.导出</h2><h3 id=\"导出集合脚本\"><a href=\"#导出集合脚本\" class=\"headerlink\" title=\"导出集合脚本\"></a>导出集合脚本</h3><p>选择其中一个集合，点击右边的三个点（…）,选择‘export’.</p>\n<p>在弹出的对话框Collection v2.1(recommended),点击‘Export’ .</p>\n<p>选择本地路径保存即可，默认导入的文件格式是json且文件名中含有Collection,这样能区分出是集合文件 。</p>\n<h3 id=\"导出环境-全局变量\"><a href=\"#导出环境-全局变量\" class=\"headerlink\" title=\"导出环境/全局变量\"></a>导出环境/全局变量</h3><p>选择右上角的小齿轮(MANAGE ENVIRONMENT)，</p>\n<p>如果是选择环境变量导出，只需要在点击对应环境的下载图标</p>\n<p>如果是选择全局变量导出，点击Globals,再点击Download as JSON .</p>\n<p>选择本地路径保存即可，默认导出的文件格式是json文件名找那个含有environemnt或globals，可以区分出这是环境变量文件或全局变量文件</p>\n<p> <img src=\"/img/blog/postman/14/014-01.png\" alt=\"img\"> </p>\n<p>简单来说，导出后的文件主要就是以下几个目的：</p>\n<p>​    分享给团队成员</p>\n<p>​    生成测试报告</p>\n<p>​    数据备份</p>\n<h2 id=\"2-导入\"><a href=\"#2-导入\" class=\"headerlink\" title=\"2.导入\"></a>2.导入</h2><p>导入有四个选项，支持从文件导入，文件夹导入，从链接导入，粘贴文本导入。导入的入口：</p>\n<p> <img src=\"/img/blog/postman/14/014-02.png\" alt=\"img\"> </p>\n<h3 id=\"Import-File：从文件导入\"><a href=\"#Import-File：从文件导入\" class=\"headerlink\" title=\"Import File：从文件导入\"></a>Import File：从文件导入</h3><p>可以支持集合文件导入，环境/全局变量文件导入(json)，通过抓包工具保存的请求文件导入 。</p>\n<p>无论是导入集合文件还是变量文件，都需要提前把对应的文件导出 。 当然此功能的使用场景就是团队成员相互分享脚本 。</p>\n<p>  <img src=\"/img/blog/postman/14/014-03.png\" alt=\"img\"> </p>\n<h3 id=\"导入fiddler数据：\"><a href=\"#导入fiddler数据：\" class=\"headerlink\" title=\"导入fiddler数据：\"></a>导入fiddler数据：</h3><p>可以将fiddler的抓取到的数据包导出，然后在postman中导入，就会在postman自动生成请求，无需任何修改 。具体实现步骤如下：</p>\n<p>从fiddler中选择一个请求，然后导出脚本文件 。</p>\n<p>在postman中的import File 中导入即可</p>\n<p>会自动将请求转变成postman脚本。</p>\n<p> <img src=\"/img/blog/postman/14/014-04.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/blog/postman/14/014-05.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/blog/postman/14/014-06.png\" alt=\"img\"> </p>\n<h3 id=\"Import-Folder：选择从文件夹导入。\"><a href=\"#Import-Folder：选择从文件夹导入。\" class=\"headerlink\" title=\"Import Folder：选择从文件夹导入。\"></a>Import Folder：选择从文件夹导入。</h3><p>有时候我们导出的集合需要用到环境变量，所以，需要把集合文件和环境变量文件都要导出，把它们放在一个文件夹下，如团队成员需要时，可以选择Import Folder直接一次性都导入即可。</p>\n<h3 id=\"Import-From-Link：通过链接导入也可以将集合分享给团队成员。\"><a href=\"#Import-From-Link：通过链接导入也可以将集合分享给团队成员。\" class=\"headerlink\" title=\"Import From Link：通过链接导入也可以将集合分享给团队成员。\"></a>Import From Link：通过链接导入也可以将集合分享给团队成员。</h3><p>但 使用这个功能需要先注册账号且登录才可以 。具体实现步骤如下 ：</p>\n<p>选择一个集合，点击分享</p>\n<p> <img src=\"/img/blog/postman/14/014-07.png\" alt=\"img\"> </p>\n<p>在弹出的界面点击Get public link</p>\n<p> <img src=\"/img/blog/postman/14/014-08.png\" alt=\"img\"></p>\n<p> <img src=\"/img/blog/postman/14/014-09.png\" alt=\"img\">  </p>\n<p> 选择Import-Import From Link 进行导入</p>\n<p> <img src=\"/img/blog/postman/14/014-10.png\" alt=\"img\"> </p>\n<p>Paste Raw Text：这个功能可以将浏览器的数据包或接口文档（swagger）的数据粘贴进来自动生成请求 ，无需任何修改，就可以直接发送请求 。非常的赞 。</p>\n<p>实现步骤：</p>\n<p>在浏览器中抓取到想要的包，然后右键copy出Curl的数据包</p>\n<p>在postman的import中将数据粘贴进来，就会自动生成了对应的请求 。</p>\n<p>  <img src=\"/img/blog/postman/14/014-11.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/blog/postman/14/014-12.png\" alt=\"img\"> </p>\n<p> <img src=\"/img/blog/postman/14/014-13.png\" alt=\"img\"> </p>\n<p>下面的这个截图是从接口文档swagger，将这个数据包拷贝粘贴到上面的文本中(Paste Raw Text) 也可以自动生成请求 。</p>\n<p> <img src=\"/img/blog/postman/14/014-14.png\" alt=\"img\"> </p>\n<blockquote>\n<p> 总之，这个功能非常实用，尤其是可以把浏览器或抓包工具中的数据包导入进来直接使用，大大的减少了我们的接口实现时间 。</p>\n</blockquote>\n<p>  &lt;！–more–&gt; </p>"},{"title":"〖postman〗接口测试17-pm对象解析","abbrlink":"22131793","date":"2022-02-26T05:16:11.000Z","_content":"\n> pm对象包含了正在执行的脚本有关的所有信息，并允许一个对象访问正在发送的请求或已收到的响应数据。它还允许设置环境和全局变量 。 <!-- more --> \n\n## 1.pm.sendRequest:\n该功能允许发送HTTP/HTTPS请求。并且要求在Pre-request Script或Tests标签中使用。\n\n发送一个get请求\n\n//发送一个get请求，请求成功后设置一个环境变量\n```\npm.sendRequest('http://cx.shouji.360.cn/phonearea.php?number=13012345678', function (err, res) {\n    if (err) {\n        console.log(err);\n    } else {\n        pm.environment.set(\"xab\", \"123\");\n    }\n});\n```\n发送一个post请求\n```\nconst PostRequest = {\n  url: 'http://ihrm-test.itheima.net/api/sys/login',\n  method: 'POST',\n  header: 'Content-Type:application/json',\n  body: {\n    mode: 'raw',\n    raw: JSON.stringify({ \"mobile\": '13800000002',\"password\":\"123456\" })\n  }\n};\npm.sendRequest(PostRequest, function (err, res) {\n  console.log(err ? err : res.json());\n});\n```\n发送的请求中添加断言\n```\npm.sendRequest('https://www.baidu.com', function (err, res) {\n  if (err) { console.log(err); }\n  pm.test('断言响应数据', function () {\n    pm.expect(err).to.equal(null);\n    pm.expect(res).to.have.property('code', 200);\n    pm.expect(res).to.have.property('status', 'OK');\n  });\n});\n```\n这个功能也非常的有用，具体使用场景我们在后面的章节后详细介绍 。\n\n## 2.pm.variables\n局部变量，作用范围更小，定义的变量想要在一个请求中使用，就可以使用这个变量 。\n\n- pm.variables.has(\"var_name\") ：检查当前作用域内是否存在变量var_name，返回boolean类型\n\n- pm.variables.get(\"var_name\") ：获取局部变量var_name的值\n\n- pm.variables.set(\"var_name\", \"value\") : 设置局部变量var_name的值为value\n\n- pm.variables.toObject() ：返回包含本地范围内所有变量的对象\n\n\n## 3.pm.environment\n环境变量，如果某个集合导入环境后，该集合下的请求都可以使用环境变量 。\n\n- pm.environment.name : 获取当前环境的名字\n\n- pm.environment.has(\"var_name\"):检查环境变量中是否存在变量var_name，返回boolean类型。\n\n- pm.environment.get(\"var_name\") :获取环境变量var_name的值\n\n- pm.environment.set(\"var_name\",\"value\") :设置环境变量var_name的值为value\n\n- pm.environment.replaceIn(\"var_name\") :将动态变量{{var_name}}语法替换为其实际的解析值\n\n- pm.environment.toObject() :以单个对象的形式返回所有环境变量\n\n- pm.environment.unset(\"var_name\") 在当前选定的环境中删除具有给定名称的变量。\n\n- pm.environment.clear() : 清除当前所选环境中的所有变量。\n\n\n## 4.pm.collectionVariables\n集合变量，只是针对集合有效的变量 。\n\n- pm.collectionVariables.has(\"var_name\") :检查集合变量中是否存在变量var_name，返回boolean类型\n\n- pm.collectionVariables.get(“var_name”) : 获取集合变量var_name的值\n\n- pm.collectionVariables.set(“var_name”, \"value\") :设置集合变量var_name的值为value\n\n- pm.collectionVariables.replaceIn(\"var_name\") :将动态变量{{var_name}}语法替换为其实际的解析值\n\n- pm.collectionVariables.toObject():以对象的形式返回变量及其值的列表。\n\n- pm.collectionVariables.unset(\"var_name\") : 清除指定的集合变量\n\n- pm.collectionVariables.clear() : 清除所有集合变量。\n\n\n## 5.pm.globals\n全局变量，只要申明了全局变量，对postman工具内的任何请求和集合都有效 。\n\n- pm.globals.has(“var_name”) : 检查全局变量中是否存在变量var_name，返回boolean类型\n\n- pm.globals.get(“var_name”) ： 获取全局变量var_name的值\n\n- pm.globals.set(“var_name”, \"value\") : 设置全局变量var_name的值为value\n\n- pm.globals.replaceIn(“var_name”) : 将动态变量{{var_name}}语法替换为其实际的解析值\n\n- pm.globals.toObject() : 以对象的形式返回变量及其值的列表。\n\n- pm.globals.unset(\"var_name\") : 清除指定的全局变量。\n\n- pm.globals.clear() :清除所有全局变量。\n\n\n## 6.pm.request\nrequest为脚本执行请求。对于前置脚本，这是将要发送的请求，在测试脚本中，这是已发送的请求 。\n\nrequest包含以下结构信息：\n\n- pm.requests.url: 包含发出请求的URL，返回json数据，主要包括了url中的protocol,host,path,query,variable部分 。可以通过.解析出每一部分 。\n\n- pm.request.headers ：包含发送请求的headers ，返回列表数据 。\n\n- pm.request.method ： 发送的请求方法\n\n- pm.request.body ：包含与请求正文相关的所有数据\n\n- pm.request.headers.add(headerName）：为当前请求添加请求头headerName\n\n- pm.request.headers.remove (headerName)：删除请求头中的headerName\n\n- pm.request.headers.upsert({ key: headerName:String, value: headerValue:String}) : 插入给定当前请求的键值对 。（如果该键不存在，否则将已存在的键值更新为新值）\n\n\n## 7.pm.response\npm.response对象包含与收到的响应有关的所有信息 。响应信息格式如下：\n\n- pm.response.code : 返回响应状态码\n\n- pm.response.status : 返回响应状态消息\n\n- pm.response.headers：返回响应头\n\n- pm.response.responseTime ： 返回响应时间\n\n- pm.response.responseSize： 返回响应大小\n\n- pm.response.text()：返回响应体的文本数据\n\n- pm.response.json() ：返回响应体的json数据\n\n\n## 8.pm.test\n格式：pm.test(testName:String, specFunction:Function)\n\n我们可以使用此方法在Pre-request Script 或Tests标签中，即使该方法内部存在错误，也可以确保脚本的其余部分不会被阻塞。\n\n示例：\n\n测试异步：done可以将可选的回调添加到pm.test\n```\n pm.test('async test', function (done) {\n    setTimeout(() => {\n        pm.expect(pm.response.code).to.equal(200);\n        done();\n    }, 1500);\n  });\npm.test.index() ：从特定位置获取总数测试\n```\n## 9.pm.expect\n格式：pm.expect(assertion:*)\n\npm.expect是一个通用的断言函数。这是ChaiJS期望的BDD库的基础。使用该库，可以很容易地编写语法易读的测试。\n\n此功能对于处理来自response或的数据断言很有用variables。有关使用的断言测试示例pm.expect。\n\n测试脚本中提供了Response Assertion API\n\n- pm.response.to.have.status(code:Number)\n\t\n- pm.response.to.have.status(reason:String)\n\n- pm.response.to.have.header(key:String)\n\n- pm.response.to.have.header(key:String, optionalValue:String)\n\n- pm.response.to.have.body()\n\n- pm.response.to.have.body(optionalValue:String)\n\n- pm.response.to.have.body(optionalValue:RegExp)\n\n- pm.response.to.have.jsonBody()\n\n- pm.response.to.have.jsonBody(optionalExpectEqual:Object)\n\n- pm.response.to.have.jsonBody(optionalExpectPath:String)\n\n- pm.response.to.have.jsonBody(optionalExpectPath:String, optionalValue:*)\n\n- pm.response.to.have.jsonSchema(schema:Object)\n\n- pm.response.to.have.jsonSchema(schema:Object, ajvOptions:Object)","source":"_posts/Postman/〖postman〗接口测试17-pm对象解析.md","raw":"---\ntitle: 〖postman〗接口测试17-pm对象解析\nabbrlink: '22131793'\ndate: 2022-02-26 13:16:11\ntags:\n - postman\ncategories:\n  - postman\n---\n\n> pm对象包含了正在执行的脚本有关的所有信息，并允许一个对象访问正在发送的请求或已收到的响应数据。它还允许设置环境和全局变量 。 <!-- more --> \n\n## 1.pm.sendRequest:\n该功能允许发送HTTP/HTTPS请求。并且要求在Pre-request Script或Tests标签中使用。\n\n发送一个get请求\n\n//发送一个get请求，请求成功后设置一个环境变量\n```\npm.sendRequest('http://cx.shouji.360.cn/phonearea.php?number=13012345678', function (err, res) {\n    if (err) {\n        console.log(err);\n    } else {\n        pm.environment.set(\"xab\", \"123\");\n    }\n});\n```\n发送一个post请求\n```\nconst PostRequest = {\n  url: 'http://ihrm-test.itheima.net/api/sys/login',\n  method: 'POST',\n  header: 'Content-Type:application/json',\n  body: {\n    mode: 'raw',\n    raw: JSON.stringify({ \"mobile\": '13800000002',\"password\":\"123456\" })\n  }\n};\npm.sendRequest(PostRequest, function (err, res) {\n  console.log(err ? err : res.json());\n});\n```\n发送的请求中添加断言\n```\npm.sendRequest('https://www.baidu.com', function (err, res) {\n  if (err) { console.log(err); }\n  pm.test('断言响应数据', function () {\n    pm.expect(err).to.equal(null);\n    pm.expect(res).to.have.property('code', 200);\n    pm.expect(res).to.have.property('status', 'OK');\n  });\n});\n```\n这个功能也非常的有用，具体使用场景我们在后面的章节后详细介绍 。\n\n## 2.pm.variables\n局部变量，作用范围更小，定义的变量想要在一个请求中使用，就可以使用这个变量 。\n\n- pm.variables.has(\"var_name\") ：检查当前作用域内是否存在变量var_name，返回boolean类型\n\n- pm.variables.get(\"var_name\") ：获取局部变量var_name的值\n\n- pm.variables.set(\"var_name\", \"value\") : 设置局部变量var_name的值为value\n\n- pm.variables.toObject() ：返回包含本地范围内所有变量的对象\n\n\n## 3.pm.environment\n环境变量，如果某个集合导入环境后，该集合下的请求都可以使用环境变量 。\n\n- pm.environment.name : 获取当前环境的名字\n\n- pm.environment.has(\"var_name\"):检查环境变量中是否存在变量var_name，返回boolean类型。\n\n- pm.environment.get(\"var_name\") :获取环境变量var_name的值\n\n- pm.environment.set(\"var_name\",\"value\") :设置环境变量var_name的值为value\n\n- pm.environment.replaceIn(\"var_name\") :将动态变量{{var_name}}语法替换为其实际的解析值\n\n- pm.environment.toObject() :以单个对象的形式返回所有环境变量\n\n- pm.environment.unset(\"var_name\") 在当前选定的环境中删除具有给定名称的变量。\n\n- pm.environment.clear() : 清除当前所选环境中的所有变量。\n\n\n## 4.pm.collectionVariables\n集合变量，只是针对集合有效的变量 。\n\n- pm.collectionVariables.has(\"var_name\") :检查集合变量中是否存在变量var_name，返回boolean类型\n\n- pm.collectionVariables.get(“var_name”) : 获取集合变量var_name的值\n\n- pm.collectionVariables.set(“var_name”, \"value\") :设置集合变量var_name的值为value\n\n- pm.collectionVariables.replaceIn(\"var_name\") :将动态变量{{var_name}}语法替换为其实际的解析值\n\n- pm.collectionVariables.toObject():以对象的形式返回变量及其值的列表。\n\n- pm.collectionVariables.unset(\"var_name\") : 清除指定的集合变量\n\n- pm.collectionVariables.clear() : 清除所有集合变量。\n\n\n## 5.pm.globals\n全局变量，只要申明了全局变量，对postman工具内的任何请求和集合都有效 。\n\n- pm.globals.has(“var_name”) : 检查全局变量中是否存在变量var_name，返回boolean类型\n\n- pm.globals.get(“var_name”) ： 获取全局变量var_name的值\n\n- pm.globals.set(“var_name”, \"value\") : 设置全局变量var_name的值为value\n\n- pm.globals.replaceIn(“var_name”) : 将动态变量{{var_name}}语法替换为其实际的解析值\n\n- pm.globals.toObject() : 以对象的形式返回变量及其值的列表。\n\n- pm.globals.unset(\"var_name\") : 清除指定的全局变量。\n\n- pm.globals.clear() :清除所有全局变量。\n\n\n## 6.pm.request\nrequest为脚本执行请求。对于前置脚本，这是将要发送的请求，在测试脚本中，这是已发送的请求 。\n\nrequest包含以下结构信息：\n\n- pm.requests.url: 包含发出请求的URL，返回json数据，主要包括了url中的protocol,host,path,query,variable部分 。可以通过.解析出每一部分 。\n\n- pm.request.headers ：包含发送请求的headers ，返回列表数据 。\n\n- pm.request.method ： 发送的请求方法\n\n- pm.request.body ：包含与请求正文相关的所有数据\n\n- pm.request.headers.add(headerName）：为当前请求添加请求头headerName\n\n- pm.request.headers.remove (headerName)：删除请求头中的headerName\n\n- pm.request.headers.upsert({ key: headerName:String, value: headerValue:String}) : 插入给定当前请求的键值对 。（如果该键不存在，否则将已存在的键值更新为新值）\n\n\n## 7.pm.response\npm.response对象包含与收到的响应有关的所有信息 。响应信息格式如下：\n\n- pm.response.code : 返回响应状态码\n\n- pm.response.status : 返回响应状态消息\n\n- pm.response.headers：返回响应头\n\n- pm.response.responseTime ： 返回响应时间\n\n- pm.response.responseSize： 返回响应大小\n\n- pm.response.text()：返回响应体的文本数据\n\n- pm.response.json() ：返回响应体的json数据\n\n\n## 8.pm.test\n格式：pm.test(testName:String, specFunction:Function)\n\n我们可以使用此方法在Pre-request Script 或Tests标签中，即使该方法内部存在错误，也可以确保脚本的其余部分不会被阻塞。\n\n示例：\n\n测试异步：done可以将可选的回调添加到pm.test\n```\n pm.test('async test', function (done) {\n    setTimeout(() => {\n        pm.expect(pm.response.code).to.equal(200);\n        done();\n    }, 1500);\n  });\npm.test.index() ：从特定位置获取总数测试\n```\n## 9.pm.expect\n格式：pm.expect(assertion:*)\n\npm.expect是一个通用的断言函数。这是ChaiJS期望的BDD库的基础。使用该库，可以很容易地编写语法易读的测试。\n\n此功能对于处理来自response或的数据断言很有用variables。有关使用的断言测试示例pm.expect。\n\n测试脚本中提供了Response Assertion API\n\n- pm.response.to.have.status(code:Number)\n\t\n- pm.response.to.have.status(reason:String)\n\n- pm.response.to.have.header(key:String)\n\n- pm.response.to.have.header(key:String, optionalValue:String)\n\n- pm.response.to.have.body()\n\n- pm.response.to.have.body(optionalValue:String)\n\n- pm.response.to.have.body(optionalValue:RegExp)\n\n- pm.response.to.have.jsonBody()\n\n- pm.response.to.have.jsonBody(optionalExpectEqual:Object)\n\n- pm.response.to.have.jsonBody(optionalExpectPath:String)\n\n- pm.response.to.have.jsonBody(optionalExpectPath:String, optionalValue:*)\n\n- pm.response.to.have.jsonSchema(schema:Object)\n\n- pm.response.to.have.jsonSchema(schema:Object, ajvOptions:Object)","slug":"Postman/〖postman〗接口测试17-pm对象解析","published":1,"updated":"2022-02-26T05:16:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xk002yn4ep1mzgedch","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>pm对象包含了正在执行的脚本有关的所有信息，并允许一个对象访问正在发送的请求或已收到的响应数据。它还允许设置环境和全局变量 。 <a id=\"more\"></a> </p>\n</blockquote>\n<h2 id=\"1-pm-sendRequest\"><a href=\"#1-pm-sendRequest\" class=\"headerlink\" title=\"1.pm.sendRequest:\"></a>1.pm.sendRequest:</h2><p>该功能允许发送HTTP/HTTPS请求。并且要求在Pre-request Script或Tests标签中使用。</p>\n<p>发送一个get请求</p>\n<p>//发送一个get请求，请求成功后设置一个环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.sendRequest(&#39;http:&#x2F;&#x2F;cx.shouji.360.cn&#x2F;phonearea.php?number&#x3D;13012345678&#39;, function (err, res) &#123;</span><br><span class=\"line\">    if (err) &#123;</span><br><span class=\"line\">        console.log(err);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        pm.environment.set(&quot;xab&quot;, &quot;123&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>发送一个post请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PostRequest &#x3D; &#123;</span><br><span class=\"line\">  url: &#39;http:&#x2F;&#x2F;ihrm-test.itheima.net&#x2F;api&#x2F;sys&#x2F;login&#39;,</span><br><span class=\"line\">  method: &#39;POST&#39;,</span><br><span class=\"line\">  header: &#39;Content-Type:application&#x2F;json&#39;,</span><br><span class=\"line\">  body: &#123;</span><br><span class=\"line\">    mode: &#39;raw&#39;,</span><br><span class=\"line\">    raw: JSON.stringify(&#123; &quot;mobile&quot;: &#39;13800000002&#39;,&quot;password&quot;:&quot;123456&quot; &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">pm.sendRequest(PostRequest, function (err, res) &#123;</span><br><span class=\"line\">  console.log(err ? err : res.json());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>发送的请求中添加断言</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.sendRequest(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;, function (err, res) &#123;</span><br><span class=\"line\">  if (err) &#123; console.log(err); &#125;</span><br><span class=\"line\">  pm.test(&#39;断言响应数据&#39;, function () &#123;</span><br><span class=\"line\">    pm.expect(err).to.equal(null);</span><br><span class=\"line\">    pm.expect(res).to.have.property(&#39;code&#39;, 200);</span><br><span class=\"line\">    pm.expect(res).to.have.property(&#39;status&#39;, &#39;OK&#39;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个功能也非常的有用，具体使用场景我们在后面的章节后详细介绍 。</p>\n<h2 id=\"2-pm-variables\"><a href=\"#2-pm-variables\" class=\"headerlink\" title=\"2.pm.variables\"></a>2.pm.variables</h2><p>局部变量，作用范围更小，定义的变量想要在一个请求中使用，就可以使用这个变量 。</p>\n<ul>\n<li><p>pm.variables.has(“var_name”) ：检查当前作用域内是否存在变量var_name，返回boolean类型</p>\n</li>\n<li><p>pm.variables.get(“var_name”) ：获取局部变量var_name的值</p>\n</li>\n<li><p>pm.variables.set(“var_name”, “value”) : 设置局部变量var_name的值为value</p>\n</li>\n<li><p>pm.variables.toObject() ：返回包含本地范围内所有变量的对象</p>\n</li>\n</ul>\n<h2 id=\"3-pm-environment\"><a href=\"#3-pm-environment\" class=\"headerlink\" title=\"3.pm.environment\"></a>3.pm.environment</h2><p>环境变量，如果某个集合导入环境后，该集合下的请求都可以使用环境变量 。</p>\n<ul>\n<li><p>pm.environment.name : 获取当前环境的名字</p>\n</li>\n<li><p>pm.environment.has(“var_name”):检查环境变量中是否存在变量var_name，返回boolean类型。</p>\n</li>\n<li><p>pm.environment.get(“var_name”) :获取环境变量var_name的值</p>\n</li>\n<li><p>pm.environment.set(“var_name”,”value”) :设置环境变量var_name的值为value</p>\n</li>\n<li><p>pm.environment.replaceIn(“var_name”) :将动态变量语法替换为其实际的解析值</p>\n</li>\n<li><p>pm.environment.toObject() :以单个对象的形式返回所有环境变量</p>\n</li>\n<li><p>pm.environment.unset(“var_name”) 在当前选定的环境中删除具有给定名称的变量。</p>\n</li>\n<li><p>pm.environment.clear() : 清除当前所选环境中的所有变量。</p>\n</li>\n</ul>\n<h2 id=\"4-pm-collectionVariables\"><a href=\"#4-pm-collectionVariables\" class=\"headerlink\" title=\"4.pm.collectionVariables\"></a>4.pm.collectionVariables</h2><p>集合变量，只是针对集合有效的变量 。</p>\n<ul>\n<li><p>pm.collectionVariables.has(“var_name”) :检查集合变量中是否存在变量var_name，返回boolean类型</p>\n</li>\n<li><p>pm.collectionVariables.get(“var_name”) : 获取集合变量var_name的值</p>\n</li>\n<li><p>pm.collectionVariables.set(“var_name”, “value”) :设置集合变量var_name的值为value</p>\n</li>\n<li><p>pm.collectionVariables.replaceIn(“var_name”) :将动态变量语法替换为其实际的解析值</p>\n</li>\n<li><p>pm.collectionVariables.toObject():以对象的形式返回变量及其值的列表。</p>\n</li>\n<li><p>pm.collectionVariables.unset(“var_name”) : 清除指定的集合变量</p>\n</li>\n<li><p>pm.collectionVariables.clear() : 清除所有集合变量。</p>\n</li>\n</ul>\n<h2 id=\"5-pm-globals\"><a href=\"#5-pm-globals\" class=\"headerlink\" title=\"5.pm.globals\"></a>5.pm.globals</h2><p>全局变量，只要申明了全局变量，对postman工具内的任何请求和集合都有效 。</p>\n<ul>\n<li><p>pm.globals.has(“var_name”) : 检查全局变量中是否存在变量var_name，返回boolean类型</p>\n</li>\n<li><p>pm.globals.get(“var_name”) ： 获取全局变量var_name的值</p>\n</li>\n<li><p>pm.globals.set(“var_name”, “value”) : 设置全局变量var_name的值为value</p>\n</li>\n<li><p>pm.globals.replaceIn(“var_name”) : 将动态变量语法替换为其实际的解析值</p>\n</li>\n<li><p>pm.globals.toObject() : 以对象的形式返回变量及其值的列表。</p>\n</li>\n<li><p>pm.globals.unset(“var_name”) : 清除指定的全局变量。</p>\n</li>\n<li><p>pm.globals.clear() :清除所有全局变量。</p>\n</li>\n</ul>\n<h2 id=\"6-pm-request\"><a href=\"#6-pm-request\" class=\"headerlink\" title=\"6.pm.request\"></a>6.pm.request</h2><p>request为脚本执行请求。对于前置脚本，这是将要发送的请求，在测试脚本中，这是已发送的请求 。</p>\n<p>request包含以下结构信息：</p>\n<ul>\n<li><p>pm.requests.url: 包含发出请求的URL，返回json数据，主要包括了url中的protocol,host,path,query,variable部分 。可以通过.解析出每一部分 。</p>\n</li>\n<li><p>pm.request.headers ：包含发送请求的headers ，返回列表数据 。</p>\n</li>\n<li><p>pm.request.method ： 发送的请求方法</p>\n</li>\n<li><p>pm.request.body ：包含与请求正文相关的所有数据</p>\n</li>\n<li><p>pm.request.headers.add(headerName）：为当前请求添加请求头headerName</p>\n</li>\n<li><p>pm.request.headers.remove (headerName)：删除请求头中的headerName</p>\n</li>\n<li><p>pm.request.headers.upsert({ key: headerName:String, value: headerValue:String}) : 插入给定当前请求的键值对 。（如果该键不存在，否则将已存在的键值更新为新值）</p>\n</li>\n</ul>\n<h2 id=\"7-pm-response\"><a href=\"#7-pm-response\" class=\"headerlink\" title=\"7.pm.response\"></a>7.pm.response</h2><p>pm.response对象包含与收到的响应有关的所有信息 。响应信息格式如下：</p>\n<ul>\n<li><p>pm.response.code : 返回响应状态码</p>\n</li>\n<li><p>pm.response.status : 返回响应状态消息</p>\n</li>\n<li><p>pm.response.headers：返回响应头</p>\n</li>\n<li><p>pm.response.responseTime ： 返回响应时间</p>\n</li>\n<li><p>pm.response.responseSize： 返回响应大小</p>\n</li>\n<li><p>pm.response.text()：返回响应体的文本数据</p>\n</li>\n<li><p>pm.response.json() ：返回响应体的json数据</p>\n</li>\n</ul>\n<h2 id=\"8-pm-test\"><a href=\"#8-pm-test\" class=\"headerlink\" title=\"8.pm.test\"></a>8.pm.test</h2><p>格式：pm.test(testName:String, specFunction:Function)</p>\n<p>我们可以使用此方法在Pre-request Script 或Tests标签中，即使该方法内部存在错误，也可以确保脚本的其余部分不会被阻塞。</p>\n<p>示例：</p>\n<p>测试异步：done可以将可选的回调添加到pm.test</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> pm.test(&#39;async test&#39;, function (done) &#123;</span><br><span class=\"line\">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">        pm.expect(pm.response.code).to.equal(200);</span><br><span class=\"line\">        done();</span><br><span class=\"line\">    &#125;, 1500);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">pm.test.index() ：从特定位置获取总数测试</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-pm-expect\"><a href=\"#9-pm-expect\" class=\"headerlink\" title=\"9.pm.expect\"></a>9.pm.expect</h2><p>格式：pm.expect(assertion:*)</p>\n<p>pm.expect是一个通用的断言函数。这是ChaiJS期望的BDD库的基础。使用该库，可以很容易地编写语法易读的测试。</p>\n<p>此功能对于处理来自response或的数据断言很有用variables。有关使用的断言测试示例pm.expect。</p>\n<p>测试脚本中提供了Response Assertion API</p>\n<ul>\n<li><p>pm.response.to.have.status(code:Number)</p>\n</li>\n<li><p>pm.response.to.have.status(reason:String)</p>\n</li>\n<li><p>pm.response.to.have.header(key:String)</p>\n</li>\n<li><p>pm.response.to.have.header(key:String, optionalValue:String)</p>\n</li>\n<li><p>pm.response.to.have.body()</p>\n</li>\n<li><p>pm.response.to.have.body(optionalValue:String)</p>\n</li>\n<li><p>pm.response.to.have.body(optionalValue:RegExp)</p>\n</li>\n<li><p>pm.response.to.have.jsonBody()</p>\n</li>\n<li><p>pm.response.to.have.jsonBody(optionalExpectEqual:Object)</p>\n</li>\n<li><p>pm.response.to.have.jsonBody(optionalExpectPath:String)</p>\n</li>\n<li><p>pm.response.to.have.jsonBody(optionalExpectPath:String, optionalValue:*)</p>\n</li>\n<li><p>pm.response.to.have.jsonSchema(schema:Object)</p>\n</li>\n<li><p>pm.response.to.have.jsonSchema(schema:Object, ajvOptions:Object)</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>pm对象包含了正在执行的脚本有关的所有信息，并允许一个对象访问正在发送的请求或已收到的响应数据。它还允许设置环境和全局变量 。","more":"</p>\n</blockquote>\n<h2 id=\"1-pm-sendRequest\"><a href=\"#1-pm-sendRequest\" class=\"headerlink\" title=\"1.pm.sendRequest:\"></a>1.pm.sendRequest:</h2><p>该功能允许发送HTTP/HTTPS请求。并且要求在Pre-request Script或Tests标签中使用。</p>\n<p>发送一个get请求</p>\n<p>//发送一个get请求，请求成功后设置一个环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.sendRequest(&#39;http:&#x2F;&#x2F;cx.shouji.360.cn&#x2F;phonearea.php?number&#x3D;13012345678&#39;, function (err, res) &#123;</span><br><span class=\"line\">    if (err) &#123;</span><br><span class=\"line\">        console.log(err);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        pm.environment.set(&quot;xab&quot;, &quot;123&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>发送一个post请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PostRequest &#x3D; &#123;</span><br><span class=\"line\">  url: &#39;http:&#x2F;&#x2F;ihrm-test.itheima.net&#x2F;api&#x2F;sys&#x2F;login&#39;,</span><br><span class=\"line\">  method: &#39;POST&#39;,</span><br><span class=\"line\">  header: &#39;Content-Type:application&#x2F;json&#39;,</span><br><span class=\"line\">  body: &#123;</span><br><span class=\"line\">    mode: &#39;raw&#39;,</span><br><span class=\"line\">    raw: JSON.stringify(&#123; &quot;mobile&quot;: &#39;13800000002&#39;,&quot;password&quot;:&quot;123456&quot; &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">pm.sendRequest(PostRequest, function (err, res) &#123;</span><br><span class=\"line\">  console.log(err ? err : res.json());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>发送的请求中添加断言</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.sendRequest(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;, function (err, res) &#123;</span><br><span class=\"line\">  if (err) &#123; console.log(err); &#125;</span><br><span class=\"line\">  pm.test(&#39;断言响应数据&#39;, function () &#123;</span><br><span class=\"line\">    pm.expect(err).to.equal(null);</span><br><span class=\"line\">    pm.expect(res).to.have.property(&#39;code&#39;, 200);</span><br><span class=\"line\">    pm.expect(res).to.have.property(&#39;status&#39;, &#39;OK&#39;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这个功能也非常的有用，具体使用场景我们在后面的章节后详细介绍 。</p>\n<h2 id=\"2-pm-variables\"><a href=\"#2-pm-variables\" class=\"headerlink\" title=\"2.pm.variables\"></a>2.pm.variables</h2><p>局部变量，作用范围更小，定义的变量想要在一个请求中使用，就可以使用这个变量 。</p>\n<ul>\n<li><p>pm.variables.has(“var_name”) ：检查当前作用域内是否存在变量var_name，返回boolean类型</p>\n</li>\n<li><p>pm.variables.get(“var_name”) ：获取局部变量var_name的值</p>\n</li>\n<li><p>pm.variables.set(“var_name”, “value”) : 设置局部变量var_name的值为value</p>\n</li>\n<li><p>pm.variables.toObject() ：返回包含本地范围内所有变量的对象</p>\n</li>\n</ul>\n<h2 id=\"3-pm-environment\"><a href=\"#3-pm-environment\" class=\"headerlink\" title=\"3.pm.environment\"></a>3.pm.environment</h2><p>环境变量，如果某个集合导入环境后，该集合下的请求都可以使用环境变量 。</p>\n<ul>\n<li><p>pm.environment.name : 获取当前环境的名字</p>\n</li>\n<li><p>pm.environment.has(“var_name”):检查环境变量中是否存在变量var_name，返回boolean类型。</p>\n</li>\n<li><p>pm.environment.get(“var_name”) :获取环境变量var_name的值</p>\n</li>\n<li><p>pm.environment.set(“var_name”,”value”) :设置环境变量var_name的值为value</p>\n</li>\n<li><p>pm.environment.replaceIn(“var_name”) :将动态变量语法替换为其实际的解析值</p>\n</li>\n<li><p>pm.environment.toObject() :以单个对象的形式返回所有环境变量</p>\n</li>\n<li><p>pm.environment.unset(“var_name”) 在当前选定的环境中删除具有给定名称的变量。</p>\n</li>\n<li><p>pm.environment.clear() : 清除当前所选环境中的所有变量。</p>\n</li>\n</ul>\n<h2 id=\"4-pm-collectionVariables\"><a href=\"#4-pm-collectionVariables\" class=\"headerlink\" title=\"4.pm.collectionVariables\"></a>4.pm.collectionVariables</h2><p>集合变量，只是针对集合有效的变量 。</p>\n<ul>\n<li><p>pm.collectionVariables.has(“var_name”) :检查集合变量中是否存在变量var_name，返回boolean类型</p>\n</li>\n<li><p>pm.collectionVariables.get(“var_name”) : 获取集合变量var_name的值</p>\n</li>\n<li><p>pm.collectionVariables.set(“var_name”, “value”) :设置集合变量var_name的值为value</p>\n</li>\n<li><p>pm.collectionVariables.replaceIn(“var_name”) :将动态变量语法替换为其实际的解析值</p>\n</li>\n<li><p>pm.collectionVariables.toObject():以对象的形式返回变量及其值的列表。</p>\n</li>\n<li><p>pm.collectionVariables.unset(“var_name”) : 清除指定的集合变量</p>\n</li>\n<li><p>pm.collectionVariables.clear() : 清除所有集合变量。</p>\n</li>\n</ul>\n<h2 id=\"5-pm-globals\"><a href=\"#5-pm-globals\" class=\"headerlink\" title=\"5.pm.globals\"></a>5.pm.globals</h2><p>全局变量，只要申明了全局变量，对postman工具内的任何请求和集合都有效 。</p>\n<ul>\n<li><p>pm.globals.has(“var_name”) : 检查全局变量中是否存在变量var_name，返回boolean类型</p>\n</li>\n<li><p>pm.globals.get(“var_name”) ： 获取全局变量var_name的值</p>\n</li>\n<li><p>pm.globals.set(“var_name”, “value”) : 设置全局变量var_name的值为value</p>\n</li>\n<li><p>pm.globals.replaceIn(“var_name”) : 将动态变量语法替换为其实际的解析值</p>\n</li>\n<li><p>pm.globals.toObject() : 以对象的形式返回变量及其值的列表。</p>\n</li>\n<li><p>pm.globals.unset(“var_name”) : 清除指定的全局变量。</p>\n</li>\n<li><p>pm.globals.clear() :清除所有全局变量。</p>\n</li>\n</ul>\n<h2 id=\"6-pm-request\"><a href=\"#6-pm-request\" class=\"headerlink\" title=\"6.pm.request\"></a>6.pm.request</h2><p>request为脚本执行请求。对于前置脚本，这是将要发送的请求，在测试脚本中，这是已发送的请求 。</p>\n<p>request包含以下结构信息：</p>\n<ul>\n<li><p>pm.requests.url: 包含发出请求的URL，返回json数据，主要包括了url中的protocol,host,path,query,variable部分 。可以通过.解析出每一部分 。</p>\n</li>\n<li><p>pm.request.headers ：包含发送请求的headers ，返回列表数据 。</p>\n</li>\n<li><p>pm.request.method ： 发送的请求方法</p>\n</li>\n<li><p>pm.request.body ：包含与请求正文相关的所有数据</p>\n</li>\n<li><p>pm.request.headers.add(headerName）：为当前请求添加请求头headerName</p>\n</li>\n<li><p>pm.request.headers.remove (headerName)：删除请求头中的headerName</p>\n</li>\n<li><p>pm.request.headers.upsert({ key: headerName:String, value: headerValue:String}) : 插入给定当前请求的键值对 。（如果该键不存在，否则将已存在的键值更新为新值）</p>\n</li>\n</ul>\n<h2 id=\"7-pm-response\"><a href=\"#7-pm-response\" class=\"headerlink\" title=\"7.pm.response\"></a>7.pm.response</h2><p>pm.response对象包含与收到的响应有关的所有信息 。响应信息格式如下：</p>\n<ul>\n<li><p>pm.response.code : 返回响应状态码</p>\n</li>\n<li><p>pm.response.status : 返回响应状态消息</p>\n</li>\n<li><p>pm.response.headers：返回响应头</p>\n</li>\n<li><p>pm.response.responseTime ： 返回响应时间</p>\n</li>\n<li><p>pm.response.responseSize： 返回响应大小</p>\n</li>\n<li><p>pm.response.text()：返回响应体的文本数据</p>\n</li>\n<li><p>pm.response.json() ：返回响应体的json数据</p>\n</li>\n</ul>\n<h2 id=\"8-pm-test\"><a href=\"#8-pm-test\" class=\"headerlink\" title=\"8.pm.test\"></a>8.pm.test</h2><p>格式：pm.test(testName:String, specFunction:Function)</p>\n<p>我们可以使用此方法在Pre-request Script 或Tests标签中，即使该方法内部存在错误，也可以确保脚本的其余部分不会被阻塞。</p>\n<p>示例：</p>\n<p>测试异步：done可以将可选的回调添加到pm.test</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> pm.test(&#39;async test&#39;, function (done) &#123;</span><br><span class=\"line\">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">        pm.expect(pm.response.code).to.equal(200);</span><br><span class=\"line\">        done();</span><br><span class=\"line\">    &#125;, 1500);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">pm.test.index() ：从特定位置获取总数测试</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-pm-expect\"><a href=\"#9-pm-expect\" class=\"headerlink\" title=\"9.pm.expect\"></a>9.pm.expect</h2><p>格式：pm.expect(assertion:*)</p>\n<p>pm.expect是一个通用的断言函数。这是ChaiJS期望的BDD库的基础。使用该库，可以很容易地编写语法易读的测试。</p>\n<p>此功能对于处理来自response或的数据断言很有用variables。有关使用的断言测试示例pm.expect。</p>\n<p>测试脚本中提供了Response Assertion API</p>\n<ul>\n<li><p>pm.response.to.have.status(code:Number)</p>\n</li>\n<li><p>pm.response.to.have.status(reason:String)</p>\n</li>\n<li><p>pm.response.to.have.header(key:String)</p>\n</li>\n<li><p>pm.response.to.have.header(key:String, optionalValue:String)</p>\n</li>\n<li><p>pm.response.to.have.body()</p>\n</li>\n<li><p>pm.response.to.have.body(optionalValue:String)</p>\n</li>\n<li><p>pm.response.to.have.body(optionalValue:RegExp)</p>\n</li>\n<li><p>pm.response.to.have.jsonBody()</p>\n</li>\n<li><p>pm.response.to.have.jsonBody(optionalExpectEqual:Object)</p>\n</li>\n<li><p>pm.response.to.have.jsonBody(optionalExpectPath:String)</p>\n</li>\n<li><p>pm.response.to.have.jsonBody(optionalExpectPath:String, optionalValue:*)</p>\n</li>\n<li><p>pm.response.to.have.jsonSchema(schema:Object)</p>\n</li>\n<li><p>pm.response.to.have.jsonSchema(schema:Object, ajvOptions:Object)</p>\n</li>\n</ul>"},{"title":"〖postman〗接口测试18-动态变量","abbrlink":"69ae7450","date":"2022-02-26T15:31:48.000Z","_content":"\n>  动态变量列表，其动态值在请求运行期间随机生成 。随机生成的值可用于请求的参数值 。\n\n <!-- more --> 要想使用动态变量，必须使用：pm.variables.replaceIn(),\n##### 例如：\n\n\tpm.variables.replaceIn(‘{undefined{$randomFirstName}}’), \n\n需要注意的是，只能在前置脚本或断言中使用动态变量 。\n\n### postman内置了非常多的动态变量，下面就列出一些常用的变量。\n\n| 变量名                   | `描述....................`   | 例子                                                         |\n| :----------------------- | :--------------------------- | :----------------------------------------------------------- |\n| $guid                    | 一个uuid-v4风格GUID          | \"611c2e81-2ccb-42d8-9ddc-2d0bfa65c1b4\"                       |\n| $timestamp               | 当前UNIX时间戳(以秒为单元)   | 1562757107                                                   |\n| $randomUUID              | 随机的36个字符的UUID         | \"6929bb52-3ab2-448a-9796-d6480ecad36b\"                       |\n| $randomAlphaNumeric      | 随机字母数字字符             | 6`，`\"y\"`，`\"z\"                                              |\n| $randomBoolean           | 随机布尔值（真/假）          | true,false                                                   |\n| $randomInt               | 1到1000之间的随机整数        | 302,454,921                                                  |\n| $randomIP                | 随机的IPV4地址               | 241.102.234.100`，`216.7.27.38                               |\n| $randomPassword          | 随机的15个字符的字母数字密码 | t9iXe7COoDKv8k3`，`QAzNFQtvR9cg2rq                           |\n| $randomUserAgent         | 随机用户代理                 | Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.9.8; rv:15.6) Gecko/20100101 Firefox/15.6.6 |\n| $randomFirstName         | 随机名字                     | Ethan`，`Chandler`，`Megane                                  |\n| **`$randomLastName`**    | 随机姓氏                     | `Schaden`，`Schneider`，`Willms`                             |\n| **`$randomFullName`**    | 随机的名字和姓氏             | `Connie Runolfsdottir`，`Sylvan Fay`，`Jonathon Kunze`       |\n| **`$randomNamePrefix`**  | 随机名称前缀                 | `Dr.`，`Ms.`，`Mr.`                                          |\n| **`$randomNameSuffix`**  | 随机名称后缀                 | `I`，`MD`，`DDS`                                             |\n| **`$randomAvatarImage`** | 随机头像                     | `https://s3.amazonaws.com/uifaces/faces/twitter/johnsmithagency/128.jpg` |\n| **`$randomWeekday`**     | 随机工作日                   | `Thursday`，`Friday`，`Monday`                               |\n| **`$randomMonth`**       | 随机月份                     | `February`，`May`，`January`                                 |\n| **`$randomDomainName`**  | 随机域名                     | `gracie.biz`，`armando.biz`，`trevor.info`                   |\n| **`$randomEmail`**       | 随机电子邮件地址             | `Pablo62@gmail.com`，`Ruthe42@hotmail.com`，`Iva.Kovacek61@hotmail.com` |\n| **`$randomUserName`**    | 随机用户名                   | `Jarrell.Gutkowski`，`Lottie.Smitham24`，`Alia99`            |\n| **`$randomUrl`**         | 随机网址                     | `https://anais.net`，`https://tristin.net`，`http://jakob.name` |\n\n接下来通过一张图来展示生成的随机数 。\n\n ![img](/img/blog/postman/18/018-01.png) \n\n 很多请求输入的参数值，填写的是固定的，如果想每次请求生成随机数，就可以用这个动态变量 。","source":"_posts/Postman/〖postman〗接口测试18-动态变量.md","raw":"---\ntitle: 〖postman〗接口测试18-动态变量\nabbrlink: 69ae7450\ndate: 2022-02-26 23:31:48\ntags:\n - postman\ncategories:\n  - postman\n---\n\n>  动态变量列表，其动态值在请求运行期间随机生成 。随机生成的值可用于请求的参数值 。\n\n <!-- more --> 要想使用动态变量，必须使用：pm.variables.replaceIn(),\n##### 例如：\n\n\tpm.variables.replaceIn(‘{undefined{$randomFirstName}}’), \n\n需要注意的是，只能在前置脚本或断言中使用动态变量 。\n\n### postman内置了非常多的动态变量，下面就列出一些常用的变量。\n\n| 变量名                   | `描述....................`   | 例子                                                         |\n| :----------------------- | :--------------------------- | :----------------------------------------------------------- |\n| $guid                    | 一个uuid-v4风格GUID          | \"611c2e81-2ccb-42d8-9ddc-2d0bfa65c1b4\"                       |\n| $timestamp               | 当前UNIX时间戳(以秒为单元)   | 1562757107                                                   |\n| $randomUUID              | 随机的36个字符的UUID         | \"6929bb52-3ab2-448a-9796-d6480ecad36b\"                       |\n| $randomAlphaNumeric      | 随机字母数字字符             | 6`，`\"y\"`，`\"z\"                                              |\n| $randomBoolean           | 随机布尔值（真/假）          | true,false                                                   |\n| $randomInt               | 1到1000之间的随机整数        | 302,454,921                                                  |\n| $randomIP                | 随机的IPV4地址               | 241.102.234.100`，`216.7.27.38                               |\n| $randomPassword          | 随机的15个字符的字母数字密码 | t9iXe7COoDKv8k3`，`QAzNFQtvR9cg2rq                           |\n| $randomUserAgent         | 随机用户代理                 | Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.9.8; rv:15.6) Gecko/20100101 Firefox/15.6.6 |\n| $randomFirstName         | 随机名字                     | Ethan`，`Chandler`，`Megane                                  |\n| **`$randomLastName`**    | 随机姓氏                     | `Schaden`，`Schneider`，`Willms`                             |\n| **`$randomFullName`**    | 随机的名字和姓氏             | `Connie Runolfsdottir`，`Sylvan Fay`，`Jonathon Kunze`       |\n| **`$randomNamePrefix`**  | 随机名称前缀                 | `Dr.`，`Ms.`，`Mr.`                                          |\n| **`$randomNameSuffix`**  | 随机名称后缀                 | `I`，`MD`，`DDS`                                             |\n| **`$randomAvatarImage`** | 随机头像                     | `https://s3.amazonaws.com/uifaces/faces/twitter/johnsmithagency/128.jpg` |\n| **`$randomWeekday`**     | 随机工作日                   | `Thursday`，`Friday`，`Monday`                               |\n| **`$randomMonth`**       | 随机月份                     | `February`，`May`，`January`                                 |\n| **`$randomDomainName`**  | 随机域名                     | `gracie.biz`，`armando.biz`，`trevor.info`                   |\n| **`$randomEmail`**       | 随机电子邮件地址             | `Pablo62@gmail.com`，`Ruthe42@hotmail.com`，`Iva.Kovacek61@hotmail.com` |\n| **`$randomUserName`**    | 随机用户名                   | `Jarrell.Gutkowski`，`Lottie.Smitham24`，`Alia99`            |\n| **`$randomUrl`**         | 随机网址                     | `https://anais.net`，`https://tristin.net`，`http://jakob.name` |\n\n接下来通过一张图来展示生成的随机数 。\n\n ![img](/img/blog/postman/18/018-01.png) \n\n 很多请求输入的参数值，填写的是固定的，如果想每次请求生成随机数，就可以用这个动态变量 。","slug":"Postman/〖postman〗接口测试18-动态变量","published":1,"updated":"2022-02-26T15:31:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xl0031n4ep89oo5bkc","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p> 动态变量列表，其动态值在请求运行期间随机生成 。随机生成的值可用于请求的参数值 。</p>\n</blockquote>\n <a id=\"more\"></a> 要想使用动态变量，必须使用：pm.variables.replaceIn(),\n<h5 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h5><pre><code>pm.variables.replaceIn(‘{undefined{$randomFirstName}}’), </code></pre><p>需要注意的是，只能在前置脚本或断言中使用动态变量 。</p>\n<h3 id=\"postman内置了非常多的动态变量，下面就列出一些常用的变量。\"><a href=\"#postman内置了非常多的动态变量，下面就列出一些常用的变量。\" class=\"headerlink\" title=\"postman内置了非常多的动态变量，下面就列出一些常用的变量。\"></a>postman内置了非常多的动态变量，下面就列出一些常用的变量。</h3><table>\n<thead>\n<tr>\n<th align=\"left\">变量名</th>\n<th align=\"left\"><code>描述....................</code></th>\n<th align=\"left\">例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">$guid</td>\n<td align=\"left\">一个uuid-v4风格GUID</td>\n<td align=\"left\">“611c2e81-2ccb-42d8-9ddc-2d0bfa65c1b4”</td>\n</tr>\n<tr>\n<td align=\"left\">$timestamp</td>\n<td align=\"left\">当前UNIX时间戳(以秒为单元)</td>\n<td align=\"left\">1562757107</td>\n</tr>\n<tr>\n<td align=\"left\">$randomUUID</td>\n<td align=\"left\">随机的36个字符的UUID</td>\n<td align=\"left\">“6929bb52-3ab2-448a-9796-d6480ecad36b”</td>\n</tr>\n<tr>\n<td align=\"left\">$randomAlphaNumeric</td>\n<td align=\"left\">随机字母数字字符</td>\n<td align=\"left\">6<code>，</code>“y”<code>，</code>“z”</td>\n</tr>\n<tr>\n<td align=\"left\">$randomBoolean</td>\n<td align=\"left\">随机布尔值（真/假）</td>\n<td align=\"left\">true,false</td>\n</tr>\n<tr>\n<td align=\"left\">$randomInt</td>\n<td align=\"left\">1到1000之间的随机整数</td>\n<td align=\"left\">302,454,921</td>\n</tr>\n<tr>\n<td align=\"left\">$randomIP</td>\n<td align=\"left\">随机的IPV4地址</td>\n<td align=\"left\">241.102.234.100<code>，</code>216.7.27.38</td>\n</tr>\n<tr>\n<td align=\"left\">$randomPassword</td>\n<td align=\"left\">随机的15个字符的字母数字密码</td>\n<td align=\"left\">t9iXe7COoDKv8k3<code>，</code>QAzNFQtvR9cg2rq</td>\n</tr>\n<tr>\n<td align=\"left\">$randomUserAgent</td>\n<td align=\"left\">随机用户代理</td>\n<td align=\"left\">Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.9.8; rv:15.6) Gecko/20100101 Firefox/15.6.6</td>\n</tr>\n<tr>\n<td align=\"left\">$randomFirstName</td>\n<td align=\"left\">随机名字</td>\n<td align=\"left\">Ethan<code>，</code>Chandler<code>，</code>Megane</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomLastName</code></strong></td>\n<td align=\"left\">随机姓氏</td>\n<td align=\"left\"><code>Schaden</code>，<code>Schneider</code>，<code>Willms</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomFullName</code></strong></td>\n<td align=\"left\">随机的名字和姓氏</td>\n<td align=\"left\"><code>Connie Runolfsdottir</code>，<code>Sylvan Fay</code>，<code>Jonathon Kunze</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomNamePrefix</code></strong></td>\n<td align=\"left\">随机名称前缀</td>\n<td align=\"left\"><code>Dr.</code>，<code>Ms.</code>，<code>Mr.</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomNameSuffix</code></strong></td>\n<td align=\"left\">随机名称后缀</td>\n<td align=\"left\"><code>I</code>，<code>MD</code>，<code>DDS</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomAvatarImage</code></strong></td>\n<td align=\"left\">随机头像</td>\n<td align=\"left\"><code>https://s3.amazonaws.com/uifaces/faces/twitter/johnsmithagency/128.jpg</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomWeekday</code></strong></td>\n<td align=\"left\">随机工作日</td>\n<td align=\"left\"><code>Thursday</code>，<code>Friday</code>，<code>Monday</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomMonth</code></strong></td>\n<td align=\"left\">随机月份</td>\n<td align=\"left\"><code>February</code>，<code>May</code>，<code>January</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomDomainName</code></strong></td>\n<td align=\"left\">随机域名</td>\n<td align=\"left\"><code>gracie.biz</code>，<code>armando.biz</code>，<code>trevor.info</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomEmail</code></strong></td>\n<td align=\"left\">随机电子邮件地址</td>\n<td align=\"left\"><code>Pablo62@gmail.com</code>，<code>Ruthe42@hotmail.com</code>，<code>Iva.Kovacek61@hotmail.com</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomUserName</code></strong></td>\n<td align=\"left\">随机用户名</td>\n<td align=\"left\"><code>Jarrell.Gutkowski</code>，<code>Lottie.Smitham24</code>，<code>Alia99</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomUrl</code></strong></td>\n<td align=\"left\">随机网址</td>\n<td align=\"left\"><code>https://anais.net</code>，<code>https://tristin.net</code>，<code>http://jakob.name</code></td>\n</tr>\n</tbody></table>\n<p>接下来通过一张图来展示生成的随机数 。</p>\n<p> <img src=\"/img/blog/postman/18/018-01.png\" alt=\"img\"> </p>\n<p> 很多请求输入的参数值，填写的是固定的，如果想每次请求生成随机数，就可以用这个动态变量 。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p> 动态变量列表，其动态值在请求运行期间随机生成 。随机生成的值可用于请求的参数值 。</p>\n</blockquote>","more":"要想使用动态变量，必须使用：pm.variables.replaceIn(),\n<h5 id=\"例如：\"><a href=\"#例如：\" class=\"headerlink\" title=\"例如：\"></a>例如：</h5><pre><code>pm.variables.replaceIn(‘{undefined{$randomFirstName}}’), </code></pre><p>需要注意的是，只能在前置脚本或断言中使用动态变量 。</p>\n<h3 id=\"postman内置了非常多的动态变量，下面就列出一些常用的变量。\"><a href=\"#postman内置了非常多的动态变量，下面就列出一些常用的变量。\" class=\"headerlink\" title=\"postman内置了非常多的动态变量，下面就列出一些常用的变量。\"></a>postman内置了非常多的动态变量，下面就列出一些常用的变量。</h3><table>\n<thead>\n<tr>\n<th align=\"left\">变量名</th>\n<th align=\"left\"><code>描述....................</code></th>\n<th align=\"left\">例子</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">$guid</td>\n<td align=\"left\">一个uuid-v4风格GUID</td>\n<td align=\"left\">“611c2e81-2ccb-42d8-9ddc-2d0bfa65c1b4”</td>\n</tr>\n<tr>\n<td align=\"left\">$timestamp</td>\n<td align=\"left\">当前UNIX时间戳(以秒为单元)</td>\n<td align=\"left\">1562757107</td>\n</tr>\n<tr>\n<td align=\"left\">$randomUUID</td>\n<td align=\"left\">随机的36个字符的UUID</td>\n<td align=\"left\">“6929bb52-3ab2-448a-9796-d6480ecad36b”</td>\n</tr>\n<tr>\n<td align=\"left\">$randomAlphaNumeric</td>\n<td align=\"left\">随机字母数字字符</td>\n<td align=\"left\">6<code>，</code>“y”<code>，</code>“z”</td>\n</tr>\n<tr>\n<td align=\"left\">$randomBoolean</td>\n<td align=\"left\">随机布尔值（真/假）</td>\n<td align=\"left\">true,false</td>\n</tr>\n<tr>\n<td align=\"left\">$randomInt</td>\n<td align=\"left\">1到1000之间的随机整数</td>\n<td align=\"left\">302,454,921</td>\n</tr>\n<tr>\n<td align=\"left\">$randomIP</td>\n<td align=\"left\">随机的IPV4地址</td>\n<td align=\"left\">241.102.234.100<code>，</code>216.7.27.38</td>\n</tr>\n<tr>\n<td align=\"left\">$randomPassword</td>\n<td align=\"left\">随机的15个字符的字母数字密码</td>\n<td align=\"left\">t9iXe7COoDKv8k3<code>，</code>QAzNFQtvR9cg2rq</td>\n</tr>\n<tr>\n<td align=\"left\">$randomUserAgent</td>\n<td align=\"left\">随机用户代理</td>\n<td align=\"left\">Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.9.8; rv:15.6) Gecko/20100101 Firefox/15.6.6</td>\n</tr>\n<tr>\n<td align=\"left\">$randomFirstName</td>\n<td align=\"left\">随机名字</td>\n<td align=\"left\">Ethan<code>，</code>Chandler<code>，</code>Megane</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomLastName</code></strong></td>\n<td align=\"left\">随机姓氏</td>\n<td align=\"left\"><code>Schaden</code>，<code>Schneider</code>，<code>Willms</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomFullName</code></strong></td>\n<td align=\"left\">随机的名字和姓氏</td>\n<td align=\"left\"><code>Connie Runolfsdottir</code>，<code>Sylvan Fay</code>，<code>Jonathon Kunze</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomNamePrefix</code></strong></td>\n<td align=\"left\">随机名称前缀</td>\n<td align=\"left\"><code>Dr.</code>，<code>Ms.</code>，<code>Mr.</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomNameSuffix</code></strong></td>\n<td align=\"left\">随机名称后缀</td>\n<td align=\"left\"><code>I</code>，<code>MD</code>，<code>DDS</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomAvatarImage</code></strong></td>\n<td align=\"left\">随机头像</td>\n<td align=\"left\"><code>https://s3.amazonaws.com/uifaces/faces/twitter/johnsmithagency/128.jpg</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomWeekday</code></strong></td>\n<td align=\"left\">随机工作日</td>\n<td align=\"left\"><code>Thursday</code>，<code>Friday</code>，<code>Monday</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomMonth</code></strong></td>\n<td align=\"left\">随机月份</td>\n<td align=\"left\"><code>February</code>，<code>May</code>，<code>January</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomDomainName</code></strong></td>\n<td align=\"left\">随机域名</td>\n<td align=\"left\"><code>gracie.biz</code>，<code>armando.biz</code>，<code>trevor.info</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomEmail</code></strong></td>\n<td align=\"left\">随机电子邮件地址</td>\n<td align=\"left\"><code>Pablo62@gmail.com</code>，<code>Ruthe42@hotmail.com</code>，<code>Iva.Kovacek61@hotmail.com</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomUserName</code></strong></td>\n<td align=\"left\">随机用户名</td>\n<td align=\"left\"><code>Jarrell.Gutkowski</code>，<code>Lottie.Smitham24</code>，<code>Alia99</code></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>$randomUrl</code></strong></td>\n<td align=\"left\">随机网址</td>\n<td align=\"left\"><code>https://anais.net</code>，<code>https://tristin.net</code>，<code>http://jakob.name</code></td>\n</tr>\n</tbody></table>\n<p>接下来通过一张图来展示生成的随机数 。</p>\n<p> <img src=\"/img/blog/postman/18/018-01.png\" alt=\"img\"> </p>\n<p> 很多请求输入的参数值，填写的是固定的，如果想每次请求生成随机数，就可以用这个动态变量 。</p>"},{"title":"〖postman〗接口测试19-Collection-Runner","abbrlink":"6556c33b","date":"2022-02-27T10:44:07.000Z","_content":"\n> 经常我们要把编写好的用例进行回归测试，这时我们就可以通过Runner来选择我们要运行的测试集进行回归。\n\n <!-- more --> \n\n\n进入Runner有俩个入口，第一个就是选择一个<font color=\"#CD7F32\">集合</font> ，点击右三角进入（批量执行用例），第二个就是在postman的导航栏左侧 （如图），打开的界面如下。\n\n![img](/img/blog/postman/19/019-01.png)\n\n![img](/img/blog/postman/19/019-02.png)\n\n功能说明：\n\n- All Collections : 列出所有集合，可以选择一个集合运行\n- Environment : 环境列表 ，当选择的集合使用到了环境，这里就必须选择 ,反之，可不选。\n- Iterations :迭代次数，这里面更多的使用场景读取外部文件进行参数化 。当然一个集合也可以重复运行。\n- Delay ：请求间的间隔时间，默认为0也就是没有间隔 。\n- Data ： 读取数据文件进行参数化的选项 。\n- Save Seponses : 保存响应数据，默认情况不开启 ，但是当集合中有请求报错时，我们打开此选项 。就可以在Run Result查看每个请求的响应结果 。\n- keep variable values : 持久变量，默认为开启状态，开启后，前面请求的变量设置的值，后面有请求修改此值，会覆盖此值 。\n- run collection without using stord cookies : 不使用cookies保存的值运行\n- Save cookies after collection run : 集合中的请求在执行期间创建/更新cookie 。打开此选项，可以将cookie保存到cookie管理器，从而覆盖任何现有的cookie。\n- Recent RUN ：右侧是保存了最近运行的结果，可以点击打开查看 。也可以下载 和删除 。\n- Import/Export :可以将运行结果导出后再导入结果进行查看 。","source":"_posts/Postman/〖postman〗接口测试19-Collection-Runner.md","raw":"---\ntitle: 〖postman〗接口测试19-Collection-Runner\nabbrlink: 6556c33b\ndate: 2022-02-27 18:44:07\ntags:\n - postman\ncategories:\n  - postman\n---\n\n> 经常我们要把编写好的用例进行回归测试，这时我们就可以通过Runner来选择我们要运行的测试集进行回归。\n\n <!-- more --> \n\n\n进入Runner有俩个入口，第一个就是选择一个<font color=\"#CD7F32\">集合</font> ，点击右三角进入（批量执行用例），第二个就是在postman的导航栏左侧 （如图），打开的界面如下。\n\n![img](/img/blog/postman/19/019-01.png)\n\n![img](/img/blog/postman/19/019-02.png)\n\n功能说明：\n\n- All Collections : 列出所有集合，可以选择一个集合运行\n- Environment : 环境列表 ，当选择的集合使用到了环境，这里就必须选择 ,反之，可不选。\n- Iterations :迭代次数，这里面更多的使用场景读取外部文件进行参数化 。当然一个集合也可以重复运行。\n- Delay ：请求间的间隔时间，默认为0也就是没有间隔 。\n- Data ： 读取数据文件进行参数化的选项 。\n- Save Seponses : 保存响应数据，默认情况不开启 ，但是当集合中有请求报错时，我们打开此选项 。就可以在Run Result查看每个请求的响应结果 。\n- keep variable values : 持久变量，默认为开启状态，开启后，前面请求的变量设置的值，后面有请求修改此值，会覆盖此值 。\n- run collection without using stord cookies : 不使用cookies保存的值运行\n- Save cookies after collection run : 集合中的请求在执行期间创建/更新cookie 。打开此选项，可以将cookie保存到cookie管理器，从而覆盖任何现有的cookie。\n- Recent RUN ：右侧是保存了最近运行的结果，可以点击打开查看 。也可以下载 和删除 。\n- Import/Export :可以将运行结果导出后再导入结果进行查看 。","slug":"Postman/〖postman〗接口测试19-Collection-Runner","published":1,"updated":"2022-02-27T10:44:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xm0036n4epcgqpf40h","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>经常我们要把编写好的用例进行回归测试，这时我们就可以通过Runner来选择我们要运行的测试集进行回归。</p>\n</blockquote>\n <a id=\"more\"></a> \n\n\n<p>进入Runner有俩个入口，第一个就是选择一个<font color=\"#CD7F32\">集合</font> ，点击右三角进入（批量执行用例），第二个就是在postman的导航栏左侧 （如图），打开的界面如下。</p>\n<p><img src=\"/img/blog/postman/19/019-01.png\" alt=\"img\"></p>\n<p><img src=\"/img/blog/postman/19/019-02.png\" alt=\"img\"></p>\n<p>功能说明：</p>\n<ul>\n<li>All Collections : 列出所有集合，可以选择一个集合运行</li>\n<li>Environment : 环境列表 ，当选择的集合使用到了环境，这里就必须选择 ,反之，可不选。</li>\n<li>Iterations :迭代次数，这里面更多的使用场景读取外部文件进行参数化 。当然一个集合也可以重复运行。</li>\n<li>Delay ：请求间的间隔时间，默认为0也就是没有间隔 。</li>\n<li>Data ： 读取数据文件进行参数化的选项 。</li>\n<li>Save Seponses : 保存响应数据，默认情况不开启 ，但是当集合中有请求报错时，我们打开此选项 。就可以在Run Result查看每个请求的响应结果 。</li>\n<li>keep variable values : 持久变量，默认为开启状态，开启后，前面请求的变量设置的值，后面有请求修改此值，会覆盖此值 。</li>\n<li>run collection without using stord cookies : 不使用cookies保存的值运行</li>\n<li>Save cookies after collection run : 集合中的请求在执行期间创建/更新cookie 。打开此选项，可以将cookie保存到cookie管理器，从而覆盖任何现有的cookie。</li>\n<li>Recent RUN ：右侧是保存了最近运行的结果，可以点击打开查看 。也可以下载 和删除 。</li>\n<li>Import/Export :可以将运行结果导出后再导入结果进行查看 。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>经常我们要把编写好的用例进行回归测试，这时我们就可以通过Runner来选择我们要运行的测试集进行回归。</p>\n</blockquote>","more":"<p>进入Runner有俩个入口，第一个就是选择一个<font color=\"#CD7F32\">集合</font> ，点击右三角进入（批量执行用例），第二个就是在postman的导航栏左侧 （如图），打开的界面如下。</p>\n<p><img src=\"/img/blog/postman/19/019-01.png\" alt=\"img\"></p>\n<p><img src=\"/img/blog/postman/19/019-02.png\" alt=\"img\"></p>\n<p>功能说明：</p>\n<ul>\n<li>All Collections : 列出所有集合，可以选择一个集合运行</li>\n<li>Environment : 环境列表 ，当选择的集合使用到了环境，这里就必须选择 ,反之，可不选。</li>\n<li>Iterations :迭代次数，这里面更多的使用场景读取外部文件进行参数化 。当然一个集合也可以重复运行。</li>\n<li>Delay ：请求间的间隔时间，默认为0也就是没有间隔 。</li>\n<li>Data ： 读取数据文件进行参数化的选项 。</li>\n<li>Save Seponses : 保存响应数据，默认情况不开启 ，但是当集合中有请求报错时，我们打开此选项 。就可以在Run Result查看每个请求的响应结果 。</li>\n<li>keep variable values : 持久变量，默认为开启状态，开启后，前面请求的变量设置的值，后面有请求修改此值，会覆盖此值 。</li>\n<li>run collection without using stord cookies : 不使用cookies保存的值运行</li>\n<li>Save cookies after collection run : 集合中的请求在执行期间创建/更新cookie 。打开此选项，可以将cookie保存到cookie管理器，从而覆盖任何现有的cookie。</li>\n<li>Recent RUN ：右侧是保存了最近运行的结果，可以点击打开查看 。也可以下载 和删除 。</li>\n<li>Import/Export :可以将运行结果导出后再导入结果进行查看 。</li>\n</ul>"},{"title":"〖postman〗接口测试21-读取外部文件进行数据参数化","abbrlink":"f46b70d8","date":"2022-02-27T13:11:53.000Z","_content":"\n测试过程中，常会遇到一个接口要验证很多的测试[数据](/posts/f46b70d8/)，而所输入的参数和验证的参数又几乎是一样的。这样我们就会首先想到数据参数化，在postman中也提供了数据参数化功能。 <!-- more --> 它需要把数据单独的存放在一个文件中管理，然后通过读取这个文件实现所有的数据的验证，具体如下：\n\n### 实现步骤 。\n\n1. 创建数据文件，支持数据格式文件分别为[csv](/posts/f46b70d8/)和接送\n2. 请求中替换[参数](/posts/f46b70d8/)变量，定义到文件中的参数名需要在请求中替换\n   - 请求参数中替换通过:{undefined{参数名}}\n   - 代码中替换通过:data.参数名\n3. 通过Runner-Data读取数据文件来运行。\n\n### 案例说明\n\n- 请求天气接口，输入不同的城市id，会返回不同的城市和天气情况 ，需对返回城市和天气进行验证 。\n\n##### 1.创建city.json 或 city.json ,格式如下\n\n   ![img](/img/blog/postman/21/021-01.png)\n\n   ![img](/img/blog/postman/21/021-02.png)\n\n​    \n\n##### 2.在请求中替换参数：city_id,city,weather .\n\n   > 其中city_id在[URL](/posts/f46b70d8/)中替换，故通过{undefined{}}替换 。\n   >\n   > city和weather在Tests中替换，需要通过data.city , data.weather\n\n   ![img](/img/blog/postman/21/021-03.png)\n\n​    \n\n##### 3.选择数据文件导入\n![img](/img/blog/postman/21/021-04.png)\n\n##### 4.查询运行结果 \n\n![img](/img/blog/postman/21/021-05.png)\n\n需要说明的是，通过数据参数化的脚本，就不能通过点击Send按钮正常去发送请求验证了，如果点击Send按钮，脚本读取不到参数会报错 。 ","source":"_posts/Postman/〖postman〗接口测试21-读取外部文件进行数据参数化.md","raw":"---\ntitle: 〖postman〗接口测试21-读取外部文件进行数据参数化\nabbrlink: f46b70d8\ndate: 2022-02-27 21:11:53\ntags:\n - postman\ncategories:\n  - postman\n---\n\n测试过程中，常会遇到一个接口要验证很多的测试[数据](/posts/f46b70d8/)，而所输入的参数和验证的参数又几乎是一样的。这样我们就会首先想到数据参数化，在postman中也提供了数据参数化功能。 <!-- more --> 它需要把数据单独的存放在一个文件中管理，然后通过读取这个文件实现所有的数据的验证，具体如下：\n\n### 实现步骤 。\n\n1. 创建数据文件，支持数据格式文件分别为[csv](/posts/f46b70d8/)和接送\n2. 请求中替换[参数](/posts/f46b70d8/)变量，定义到文件中的参数名需要在请求中替换\n   - 请求参数中替换通过:{undefined{参数名}}\n   - 代码中替换通过:data.参数名\n3. 通过Runner-Data读取数据文件来运行。\n\n### 案例说明\n\n- 请求天气接口，输入不同的城市id，会返回不同的城市和天气情况 ，需对返回城市和天气进行验证 。\n\n##### 1.创建city.json 或 city.json ,格式如下\n\n   ![img](/img/blog/postman/21/021-01.png)\n\n   ![img](/img/blog/postman/21/021-02.png)\n\n​    \n\n##### 2.在请求中替换参数：city_id,city,weather .\n\n   > 其中city_id在[URL](/posts/f46b70d8/)中替换，故通过{undefined{}}替换 。\n   >\n   > city和weather在Tests中替换，需要通过data.city , data.weather\n\n   ![img](/img/blog/postman/21/021-03.png)\n\n​    \n\n##### 3.选择数据文件导入\n![img](/img/blog/postman/21/021-04.png)\n\n##### 4.查询运行结果 \n\n![img](/img/blog/postman/21/021-05.png)\n\n需要说明的是，通过数据参数化的脚本，就不能通过点击Send按钮正常去发送请求验证了，如果点击Send按钮，脚本读取不到参数会报错 。 ","slug":"Postman/〖postman〗接口测试21-读取外部文件进行数据参数化","published":1,"updated":"2022-02-27T13:11:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xn0039n4epa5jig2od","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>测试过程中，常会遇到一个接口要验证很多的测试<a href=\"/posts/f46b70d8/\">数据</a>，而所输入的参数和验证的参数又几乎是一样的。这样我们就会首先想到数据参数化，在postman中也提供了数据参数化功能。 <a id=\"more\"></a> 它需要把数据单独的存放在一个文件中管理，然后通过读取这个文件实现所有的数据的验证，具体如下：</p>\n<h3 id=\"实现步骤-。\"><a href=\"#实现步骤-。\" class=\"headerlink\" title=\"实现步骤 。\"></a>实现步骤 。</h3><ol>\n<li>创建数据文件，支持数据格式文件分别为<a href=\"/posts/f46b70d8/\">csv</a>和接送</li>\n<li>请求中替换<a href=\"/posts/f46b70d8/\">参数</a>变量，定义到文件中的参数名需要在请求中替换<ul>\n<li>请求参数中替换通过:{undefined{参数名}}</li>\n<li>代码中替换通过:data.参数名</li>\n</ul>\n</li>\n<li>通过Runner-Data读取数据文件来运行。</li>\n</ol>\n<h3 id=\"案例说明\"><a href=\"#案例说明\" class=\"headerlink\" title=\"案例说明\"></a>案例说明</h3><ul>\n<li>请求天气接口，输入不同的城市id，会返回不同的城市和天气情况 ，需对返回城市和天气进行验证 。</li>\n</ul>\n<h5 id=\"1-创建city-json-或-city-json-格式如下\"><a href=\"#1-创建city-json-或-city-json-格式如下\" class=\"headerlink\" title=\"1.创建city.json 或 city.json ,格式如下\"></a>1.创建city.json 或 city.json ,格式如下</h5><p>   <img src=\"/img/blog/postman/21/021-01.png\" alt=\"img\"></p>\n<p>   <img src=\"/img/blog/postman/21/021-02.png\" alt=\"img\"></p>\n<p>​    </p>\n<h5 id=\"2-在请求中替换参数：city-id-city-weather\"><a href=\"#2-在请求中替换参数：city-id-city-weather\" class=\"headerlink\" title=\"2.在请求中替换参数：city_id,city,weather .\"></a>2.在请求中替换参数：city_id,city,weather .</h5><blockquote>\n<p>其中city_id在<a href=\"/posts/f46b70d8/\">URL</a>中替换，故通过{undefined{}}替换 。</p>\n<p>city和weather在Tests中替换，需要通过data.city , data.weather</p>\n</blockquote>\n<p>   <img src=\"/img/blog/postman/21/021-03.png\" alt=\"img\"></p>\n<p>​    </p>\n<h5 id=\"3-选择数据文件导入\"><a href=\"#3-选择数据文件导入\" class=\"headerlink\" title=\"3.选择数据文件导入\"></a>3.选择数据文件导入</h5><p><img src=\"/img/blog/postman/21/021-04.png\" alt=\"img\"></p>\n<h5 id=\"4-查询运行结果\"><a href=\"#4-查询运行结果\" class=\"headerlink\" title=\"4.查询运行结果\"></a>4.查询运行结果</h5><p><img src=\"/img/blog/postman/21/021-05.png\" alt=\"img\"></p>\n<p>需要说明的是，通过数据参数化的脚本，就不能通过点击Send按钮正常去发送请求验证了，如果点击Send按钮，脚本读取不到参数会报错 。 </p>\n","site":{"data":{}},"excerpt":"<p>测试过程中，常会遇到一个接口要验证很多的测试<a href=\"/posts/f46b70d8/\">数据</a>，而所输入的参数和验证的参数又几乎是一样的。这样我们就会首先想到数据参数化，在postman中也提供了数据参数化功能。","more":"它需要把数据单独的存放在一个文件中管理，然后通过读取这个文件实现所有的数据的验证，具体如下：</p>\n<h3 id=\"实现步骤-。\"><a href=\"#实现步骤-。\" class=\"headerlink\" title=\"实现步骤 。\"></a>实现步骤 。</h3><ol>\n<li>创建数据文件，支持数据格式文件分别为<a href=\"/posts/f46b70d8/\">csv</a>和接送</li>\n<li>请求中替换<a href=\"/posts/f46b70d8/\">参数</a>变量，定义到文件中的参数名需要在请求中替换<ul>\n<li>请求参数中替换通过:{undefined{参数名}}</li>\n<li>代码中替换通过:data.参数名</li>\n</ul>\n</li>\n<li>通过Runner-Data读取数据文件来运行。</li>\n</ol>\n<h3 id=\"案例说明\"><a href=\"#案例说明\" class=\"headerlink\" title=\"案例说明\"></a>案例说明</h3><ul>\n<li>请求天气接口，输入不同的城市id，会返回不同的城市和天气情况 ，需对返回城市和天气进行验证 。</li>\n</ul>\n<h5 id=\"1-创建city-json-或-city-json-格式如下\"><a href=\"#1-创建city-json-或-city-json-格式如下\" class=\"headerlink\" title=\"1.创建city.json 或 city.json ,格式如下\"></a>1.创建city.json 或 city.json ,格式如下</h5><p>   <img src=\"/img/blog/postman/21/021-01.png\" alt=\"img\"></p>\n<p>   <img src=\"/img/blog/postman/21/021-02.png\" alt=\"img\"></p>\n<p>​    </p>\n<h5 id=\"2-在请求中替换参数：city-id-city-weather\"><a href=\"#2-在请求中替换参数：city-id-city-weather\" class=\"headerlink\" title=\"2.在请求中替换参数：city_id,city,weather .\"></a>2.在请求中替换参数：city_id,city,weather .</h5><blockquote>\n<p>其中city_id在<a href=\"/posts/f46b70d8/\">URL</a>中替换，故通过{undefined{}}替换 。</p>\n<p>city和weather在Tests中替换，需要通过data.city , data.weather</p>\n</blockquote>\n<p>   <img src=\"/img/blog/postman/21/021-03.png\" alt=\"img\"></p>\n<p>​    </p>\n<h5 id=\"3-选择数据文件导入\"><a href=\"#3-选择数据文件导入\" class=\"headerlink\" title=\"3.选择数据文件导入\"></a>3.选择数据文件导入</h5><p><img src=\"/img/blog/postman/21/021-04.png\" alt=\"img\"></p>\n<h5 id=\"4-查询运行结果\"><a href=\"#4-查询运行结果\" class=\"headerlink\" title=\"4.查询运行结果\"></a>4.查询运行结果</h5><p><img src=\"/img/blog/postman/21/021-05.png\" alt=\"img\"></p>\n<p>需要说明的是，通过数据参数化的脚本，就不能通过点击Send按钮正常去发送请求验证了，如果点击Send按钮，脚本读取不到参数会报错 。 </p>"},{"title":"〖postman〗接口测试20-建立工作流","abbrlink":"ab3b7c7","date":"2022-02-27T11:00:43.000Z","_content":"\n在前面讲的Runner，如果运行集合中的请求，则是按照顺序运行所有请求 。 <!-- more --> 如下图，有4个请求，通过runner运行的话，会顺序这4个请求 。\n\n![img](/img/blog/postman/20/020-01.png)\n\n接下来要学习的这个功能，在脚本中就可以控制脚本的执行顺序，我们来看下这个函数：postman.setNextRequest()，它需要带一个参数 。该参数是要运行的请求名称或ID 。这个函数的功能可以控制请求的执行顺序。\n\n---\n\n**案例**：在登录用例中添加setNextRequest() ，判断登录接口返回值当code=0，就直接请求充值接口。\n再次运行该集合，运行完登录接口，\n- 当code=0，就会直接请求充值接口 ，只会运行3个接口，会跳过注册接口\n![img](/img/blog/postman/20/020-02.png)\n\n- 当code!=0，就会请求注册接口然后依次执行\n![img](/img/blog/postman/20/020-03.png)\n\n\n同样的4个请求，在接口中添加了postman.setNextRequest(\"xxx\")功能后，执行完这个接口就会执行指定的接口，会跳过中间的接口 。","source":"_posts/Postman/〖postman〗接口测试20-建立工作流.md","raw":"---\ntitle: 〖postman〗接口测试20-建立工作流\nabbrlink: ab3b7c7\ndate: 2022-02-27 19:00:43\ntags:\n - postman\ncategories:\n  - postman\n---\n\n在前面讲的Runner，如果运行集合中的请求，则是按照顺序运行所有请求 。 <!-- more --> 如下图，有4个请求，通过runner运行的话，会顺序这4个请求 。\n\n![img](/img/blog/postman/20/020-01.png)\n\n接下来要学习的这个功能，在脚本中就可以控制脚本的执行顺序，我们来看下这个函数：postman.setNextRequest()，它需要带一个参数 。该参数是要运行的请求名称或ID 。这个函数的功能可以控制请求的执行顺序。\n\n---\n\n**案例**：在登录用例中添加setNextRequest() ，判断登录接口返回值当code=0，就直接请求充值接口。\n再次运行该集合，运行完登录接口，\n- 当code=0，就会直接请求充值接口 ，只会运行3个接口，会跳过注册接口\n![img](/img/blog/postman/20/020-02.png)\n\n- 当code!=0，就会请求注册接口然后依次执行\n![img](/img/blog/postman/20/020-03.png)\n\n\n同样的4个请求，在接口中添加了postman.setNextRequest(\"xxx\")功能后，执行完这个接口就会执行指定的接口，会跳过中间的接口 。","slug":"Postman/〖postman〗接口测试20-建立工作流","published":1,"updated":"2022-02-27T11:00:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xp003en4epds537rqg","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>在前面讲的Runner，如果运行集合中的请求，则是按照顺序运行所有请求 。 <a id=\"more\"></a> 如下图，有4个请求，通过runner运行的话，会顺序这4个请求 。</p>\n<p><img src=\"/img/blog/postman/20/020-01.png\" alt=\"img\"></p>\n<p>接下来要学习的这个功能，在脚本中就可以控制脚本的执行顺序，我们来看下这个函数：postman.setNextRequest()，它需要带一个参数 。该参数是要运行的请求名称或ID 。这个函数的功能可以控制请求的执行顺序。</p>\n<hr>\n<p><strong>案例</strong>：在登录用例中添加setNextRequest() ，判断登录接口返回值当code=0，就直接请求充值接口。<br>再次运行该集合，运行完登录接口，</p>\n<ul>\n<li><p>当code=0，就会直接请求充值接口 ，只会运行3个接口，会跳过注册接口<br><img src=\"/img/blog/postman/20/020-02.png\" alt=\"img\"></p>\n</li>\n<li><p>当code!=0，就会请求注册接口然后依次执行<br><img src=\"/img/blog/postman/20/020-03.png\" alt=\"img\"></p>\n</li>\n</ul>\n<p>同样的4个请求，在接口中添加了postman.setNextRequest(“xxx”)功能后，执行完这个接口就会执行指定的接口，会跳过中间的接口 。</p>\n","site":{"data":{}},"excerpt":"<p>在前面讲的Runner，如果运行集合中的请求，则是按照顺序运行所有请求 。","more":"如下图，有4个请求，通过runner运行的话，会顺序这4个请求 。</p>\n<p><img src=\"/img/blog/postman/20/020-01.png\" alt=\"img\"></p>\n<p>接下来要学习的这个功能，在脚本中就可以控制脚本的执行顺序，我们来看下这个函数：postman.setNextRequest()，它需要带一个参数 。该参数是要运行的请求名称或ID 。这个函数的功能可以控制请求的执行顺序。</p>\n<hr>\n<p><strong>案例</strong>：在登录用例中添加setNextRequest() ，判断登录接口返回值当code=0，就直接请求充值接口。<br>再次运行该集合，运行完登录接口，</p>\n<ul>\n<li><p>当code=0，就会直接请求充值接口 ，只会运行3个接口，会跳过注册接口<br><img src=\"/img/blog/postman/20/020-02.png\" alt=\"img\"></p>\n</li>\n<li><p>当code!=0，就会请求注册接口然后依次执行<br><img src=\"/img/blog/postman/20/020-03.png\" alt=\"img\"></p>\n</li>\n</ul>\n<p>同样的4个请求，在接口中添加了postman.setNextRequest(“xxx”)功能后，执行完这个接口就会执行指定的接口，会跳过中间的接口 。</p>"},{"title":"02 requests初体验，学习get、post怎么发送请求-使用Python+requests做接口测试","abbrlink":"69423a58","date":"2022-05-05T07:11:34.000Z","_content":"\n# requests库基本使用\n**发送一个请求分3步：**\n\n1. 拼接请求： 请求包含url，params(url参数) [data(请求数据)]  [headers(请求头)] [cookies]等\n2. 发送请求，获取响应：支持get，post等各种方法发送，返回的是一个响应对象\n3. 解析响应: 打印响应内容<!-- more --> \n\n### 一、一个最简单的GET请求\n打开Pycharm，新建一个demo项目，项目下新建一个Python文件，输入以下内容：\n\n```python\n# 导入requests包\nimport requests \n\n# 1. 拼接请求\nurl = \"http://httpbin.org/get\"  # 这里只有url，字符串格式\n# 2. 发送请求，获取响应\nres = requests.get(url) # res即返回的响应对象\n# 3. 解析响应，打印相应内容\nprint(res.text)  # 输出响应的文本\n```\n\n### 二、带参数的GET请求\n1、请求参数拼接到URL后面\n\n```python\nimport requests \n\nurl = \"http://httpbin.org/get?key=ec961279f453&find=helloword\"  # 参数可以写到url里\nres = requests.get(url=url) # 第一个url指get方法的参数，第二个url指上一行我们定义的接口地址\nprint(res.text)  \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bb2ea127b4bc43ab8fa90e00acee3641.png)\n\n2、请求参数写到params里\n\n```python\nimport requests \n\nurl = \"http://httpbin.org/get\"\nparams = {\"key\":\"ec961279f453\",\"find\":\"hello word\"} # 字典格式，单独提出来，方便参数的添加修改等操作\nres = requests.get(url=url, params=params) \nprint(res.text)  \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6b1e0f23f6de41d39ef20e7e05b9b3df.png)\n\n### 三、传统表单类POST请求（x-www-form-urlencoded）\n```python\nimport requests\n\nurl = \"http://httpbin.org/post\"\ndata = {\"name\": \"xiajian\", \"age\": 22}  # Post请求发送的数据，字典格式\nres = requests.post(url=url, data=data)  # 这里使用post方法，参数和get方法一样\nprint(res.text)\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c705000a8b4d40fdaffc0c38902fbaca.png)\n\n### 四、JSON类型的POST请求（application/json）\n1、使用字符串入参去请求post请求\n\n```python\nimport requests\n\nurl = \"http://httpbin.org/post\"\n# 字符串入参\ndata = '''{\n    \"name\": \"xiajian\",\n    \"age\": 22\n            }'''  # 多行文本, 字符串格式，也可以单行（注意外层有引号，为字符串） data = '{\"name\": \"xiajian\", \"age\": 22}'\nprint(type(data))  # 打印data数据类型\nres = requests.post(url=url, data=data)  # data支持字典或字符串\nprint(res.text) \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/48d84e40caf24c52b6fb6a0fe90c1ffa.png)\n\n> data请求参数支持字典也支持字符串，如果是字典格式，requests方法会将其按照默认表单urlencoded格式转换为字符串，如果是字符串则不转化\n\n如果data以字符串格式传输需要遵循以下几点：\n\n- 必须是严格的JSON格式字符串，里面必须用双引号，k-v之间必须有逗号，布尔值必须是小写的true/false等等\n- 不能有中文，直接传字符串不会自动编码\n---\n2、使用json去请求post请求\n\n```python\nimport requests\n\nurl = \"http://httpbin.org/post\"\ndata = {\n    \"name\": \"xiajian\",\n    \"age\": 22\n}  # 字典格式，方便添加\nres = requests.post(url=url, json=data)  # JSON参数会自动将字典格式转为合法的JSON文本并添加headers\nprint(res.text)\n  \n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d084c4abbf4d4352847b256b12db63d5.png)","source":"_posts/Python接口自动化测试/02 requests初体验，学习get、post怎么发送请求-使用Python+requests做接口测试.md","raw":"---\ntitle: 02 requests初体验，学习get、post怎么发送请求-使用Python+requests做接口测试\nabbrlink: 69423a58\ndate: 2022-05-05 15:11:34\ntags:\n  - Python接口自动化测试\ncategories:\n  - Python接口自动化测试\n---\n\n# requests库基本使用\n**发送一个请求分3步：**\n\n1. 拼接请求： 请求包含url，params(url参数) [data(请求数据)]  [headers(请求头)] [cookies]等\n2. 发送请求，获取响应：支持get，post等各种方法发送，返回的是一个响应对象\n3. 解析响应: 打印响应内容<!-- more --> \n\n### 一、一个最简单的GET请求\n打开Pycharm，新建一个demo项目，项目下新建一个Python文件，输入以下内容：\n\n```python\n# 导入requests包\nimport requests \n\n# 1. 拼接请求\nurl = \"http://httpbin.org/get\"  # 这里只有url，字符串格式\n# 2. 发送请求，获取响应\nres = requests.get(url) # res即返回的响应对象\n# 3. 解析响应，打印相应内容\nprint(res.text)  # 输出响应的文本\n```\n\n### 二、带参数的GET请求\n1、请求参数拼接到URL后面\n\n```python\nimport requests \n\nurl = \"http://httpbin.org/get?key=ec961279f453&find=helloword\"  # 参数可以写到url里\nres = requests.get(url=url) # 第一个url指get方法的参数，第二个url指上一行我们定义的接口地址\nprint(res.text)  \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bb2ea127b4bc43ab8fa90e00acee3641.png)\n\n2、请求参数写到params里\n\n```python\nimport requests \n\nurl = \"http://httpbin.org/get\"\nparams = {\"key\":\"ec961279f453\",\"find\":\"hello word\"} # 字典格式，单独提出来，方便参数的添加修改等操作\nres = requests.get(url=url, params=params) \nprint(res.text)  \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/6b1e0f23f6de41d39ef20e7e05b9b3df.png)\n\n### 三、传统表单类POST请求（x-www-form-urlencoded）\n```python\nimport requests\n\nurl = \"http://httpbin.org/post\"\ndata = {\"name\": \"xiajian\", \"age\": 22}  # Post请求发送的数据，字典格式\nres = requests.post(url=url, data=data)  # 这里使用post方法，参数和get方法一样\nprint(res.text)\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/c705000a8b4d40fdaffc0c38902fbaca.png)\n\n### 四、JSON类型的POST请求（application/json）\n1、使用字符串入参去请求post请求\n\n```python\nimport requests\n\nurl = \"http://httpbin.org/post\"\n# 字符串入参\ndata = '''{\n    \"name\": \"xiajian\",\n    \"age\": 22\n            }'''  # 多行文本, 字符串格式，也可以单行（注意外层有引号，为字符串） data = '{\"name\": \"xiajian\", \"age\": 22}'\nprint(type(data))  # 打印data数据类型\nres = requests.post(url=url, data=data)  # data支持字典或字符串\nprint(res.text) \n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/48d84e40caf24c52b6fb6a0fe90c1ffa.png)\n\n> data请求参数支持字典也支持字符串，如果是字典格式，requests方法会将其按照默认表单urlencoded格式转换为字符串，如果是字符串则不转化\n\n如果data以字符串格式传输需要遵循以下几点：\n\n- 必须是严格的JSON格式字符串，里面必须用双引号，k-v之间必须有逗号，布尔值必须是小写的true/false等等\n- 不能有中文，直接传字符串不会自动编码\n---\n2、使用json去请求post请求\n\n```python\nimport requests\n\nurl = \"http://httpbin.org/post\"\ndata = {\n    \"name\": \"xiajian\",\n    \"age\": 22\n}  # 字典格式，方便添加\nres = requests.post(url=url, json=data)  # JSON参数会自动将字典格式转为合法的JSON文本并添加headers\nprint(res.text)\n  \n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d084c4abbf4d4352847b256b12db63d5.png)","slug":"Python接口自动化测试/02 requests初体验，学习get、post怎么发送请求-使用Python+requests做接口测试","published":1,"updated":"2022-05-05T07:11:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xp003hn4ep5qqrgxnx","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"requests库基本使用\"><a href=\"#requests库基本使用\" class=\"headerlink\" title=\"requests库基本使用\"></a>requests库基本使用</h1><p><strong>发送一个请求分3步：</strong></p>\n<ol>\n<li>拼接请求： 请求包含url，params(url参数) [data(请求数据)]  [headers(请求头)] [cookies]等</li>\n<li>发送请求，获取响应：支持get，post等各种方法发送，返回的是一个响应对象</li>\n<li>解析响应: 打印响应内容<a id=\"more\"></a> </li>\n</ol>\n<h3 id=\"一、一个最简单的GET请求\"><a href=\"#一、一个最简单的GET请求\" class=\"headerlink\" title=\"一、一个最简单的GET请求\"></a>一、一个最简单的GET请求</h3><p>打开Pycharm，新建一个demo项目，项目下新建一个Python文件，输入以下内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入requests包</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. 拼接请求</span></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/get\"</span>  <span class=\"comment\"># 这里只有url，字符串格式</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 发送请求，获取响应</span></span><br><span class=\"line\">res = requests.get(url) <span class=\"comment\"># res即返回的响应对象</span></span><br><span class=\"line\"><span class=\"comment\"># 3. 解析响应，打印相应内容</span></span><br><span class=\"line\">print(res.text)  <span class=\"comment\"># 输出响应的文本</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、带参数的GET请求\"><a href=\"#二、带参数的GET请求\" class=\"headerlink\" title=\"二、带参数的GET请求\"></a>二、带参数的GET请求</h3><p>1、请求参数拼接到URL后面</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/get?key=ec961279f453&amp;find=helloword\"</span>  <span class=\"comment\"># 参数可以写到url里</span></span><br><span class=\"line\">res = requests.get(url=url) <span class=\"comment\"># 第一个url指get方法的参数，第二个url指上一行我们定义的接口地址</span></span><br><span class=\"line\">print(res.text)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/bb2ea127b4bc43ab8fa90e00acee3641.png\" alt=\"在这里插入图片描述\"></p>\n<p>2、请求参数写到params里</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/get\"</span></span><br><span class=\"line\">params = &#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"ec961279f453\"</span>,<span class=\"string\">\"find\"</span>:<span class=\"string\">\"hello word\"</span>&#125; <span class=\"comment\"># 字典格式，单独提出来，方便参数的添加修改等操作</span></span><br><span class=\"line\">res = requests.get(url=url, params=params) </span><br><span class=\"line\">print(res.text)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/6b1e0f23f6de41d39ef20e7e05b9b3df.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"三、传统表单类POST请求（x-www-form-urlencoded）\"><a href=\"#三、传统表单类POST请求（x-www-form-urlencoded）\" class=\"headerlink\" title=\"三、传统表单类POST请求（x-www-form-urlencoded）\"></a>三、传统表单类POST请求（x-www-form-urlencoded）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/post\"</span></span><br><span class=\"line\">data = &#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"xiajian\"</span>, <span class=\"string\">\"age\"</span>: <span class=\"number\">22</span>&#125;  <span class=\"comment\"># Post请求发送的数据，字典格式</span></span><br><span class=\"line\">res = requests.post(url=url, data=data)  <span class=\"comment\"># 这里使用post方法，参数和get方法一样</span></span><br><span class=\"line\">print(res.text)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/c705000a8b4d40fdaffc0c38902fbaca.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"四、JSON类型的POST请求（application-json）\"><a href=\"#四、JSON类型的POST请求（application-json）\" class=\"headerlink\" title=\"四、JSON类型的POST请求（application/json）\"></a>四、JSON类型的POST请求（application/json）</h3><p>1、使用字符串入参去请求post请求</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/post\"</span></span><br><span class=\"line\"><span class=\"comment\"># 字符串入参</span></span><br><span class=\"line\">data = <span class=\"string\">'''&#123;</span></span><br><span class=\"line\"><span class=\"string\">    \"name\": \"xiajian\",</span></span><br><span class=\"line\"><span class=\"string\">    \"age\": 22</span></span><br><span class=\"line\"><span class=\"string\">            &#125;'''</span>  <span class=\"comment\"># 多行文本, 字符串格式，也可以单行（注意外层有引号，为字符串） data = '&#123;\"name\": \"xiajian\", \"age\": 22&#125;'</span></span><br><span class=\"line\">print(type(data))  <span class=\"comment\"># 打印data数据类型</span></span><br><span class=\"line\">res = requests.post(url=url, data=data)  <span class=\"comment\"># data支持字典或字符串</span></span><br><span class=\"line\">print(res.text)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/48d84e40caf24c52b6fb6a0fe90c1ffa.png\" alt=\"在这里插入图片描述\"></p>\n<blockquote>\n<p>data请求参数支持字典也支持字符串，如果是字典格式，requests方法会将其按照默认表单urlencoded格式转换为字符串，如果是字符串则不转化</p>\n</blockquote>\n<p>如果data以字符串格式传输需要遵循以下几点：</p>\n<ul>\n<li>必须是严格的JSON格式字符串，里面必须用双引号，k-v之间必须有逗号，布尔值必须是小写的true/false等等</li>\n<li>不能有中文，直接传字符串不会自动编码</li>\n</ul>\n<hr>\n<p>2、使用json去请求post请求</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/post\"</span></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"xiajian\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"age\"</span>: <span class=\"number\">22</span></span><br><span class=\"line\">&#125;  <span class=\"comment\"># 字典格式，方便添加</span></span><br><span class=\"line\">res = requests.post(url=url, json=data)  <span class=\"comment\"># JSON参数会自动将字典格式转为合法的JSON文本并添加headers</span></span><br><span class=\"line\">print(res.text)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/d084c4abbf4d4352847b256b12db63d5.png\" alt=\"在这里插入图片描述\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"requests库基本使用\"><a href=\"#requests库基本使用\" class=\"headerlink\" title=\"requests库基本使用\"></a>requests库基本使用</h1><p><strong>发送一个请求分3步：</strong></p>\n<ol>\n<li>拼接请求： 请求包含url，params(url参数) [data(请求数据)]  [headers(请求头)] [cookies]等</li>\n<li>发送请求，获取响应：支持get，post等各种方法发送，返回的是一个响应对象</li>\n<li>解析响应: 打印响应内容","more":"</li>\n</ol>\n<h3 id=\"一、一个最简单的GET请求\"><a href=\"#一、一个最简单的GET请求\" class=\"headerlink\" title=\"一、一个最简单的GET请求\"></a>一、一个最简单的GET请求</h3><p>打开Pycharm，新建一个demo项目，项目下新建一个Python文件，输入以下内容：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入requests包</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. 拼接请求</span></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/get\"</span>  <span class=\"comment\"># 这里只有url，字符串格式</span></span><br><span class=\"line\"><span class=\"comment\"># 2. 发送请求，获取响应</span></span><br><span class=\"line\">res = requests.get(url) <span class=\"comment\"># res即返回的响应对象</span></span><br><span class=\"line\"><span class=\"comment\"># 3. 解析响应，打印相应内容</span></span><br><span class=\"line\">print(res.text)  <span class=\"comment\"># 输出响应的文本</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、带参数的GET请求\"><a href=\"#二、带参数的GET请求\" class=\"headerlink\" title=\"二、带参数的GET请求\"></a>二、带参数的GET请求</h3><p>1、请求参数拼接到URL后面</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/get?key=ec961279f453&amp;find=helloword\"</span>  <span class=\"comment\"># 参数可以写到url里</span></span><br><span class=\"line\">res = requests.get(url=url) <span class=\"comment\"># 第一个url指get方法的参数，第二个url指上一行我们定义的接口地址</span></span><br><span class=\"line\">print(res.text)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/bb2ea127b4bc43ab8fa90e00acee3641.png\" alt=\"在这里插入图片描述\"></p>\n<p>2、请求参数写到params里</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests </span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/get\"</span></span><br><span class=\"line\">params = &#123;<span class=\"string\">\"key\"</span>:<span class=\"string\">\"ec961279f453\"</span>,<span class=\"string\">\"find\"</span>:<span class=\"string\">\"hello word\"</span>&#125; <span class=\"comment\"># 字典格式，单独提出来，方便参数的添加修改等操作</span></span><br><span class=\"line\">res = requests.get(url=url, params=params) </span><br><span class=\"line\">print(res.text)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/6b1e0f23f6de41d39ef20e7e05b9b3df.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"三、传统表单类POST请求（x-www-form-urlencoded）\"><a href=\"#三、传统表单类POST请求（x-www-form-urlencoded）\" class=\"headerlink\" title=\"三、传统表单类POST请求（x-www-form-urlencoded）\"></a>三、传统表单类POST请求（x-www-form-urlencoded）</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/post\"</span></span><br><span class=\"line\">data = &#123;<span class=\"string\">\"name\"</span>: <span class=\"string\">\"xiajian\"</span>, <span class=\"string\">\"age\"</span>: <span class=\"number\">22</span>&#125;  <span class=\"comment\"># Post请求发送的数据，字典格式</span></span><br><span class=\"line\">res = requests.post(url=url, data=data)  <span class=\"comment\"># 这里使用post方法，参数和get方法一样</span></span><br><span class=\"line\">print(res.text)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/c705000a8b4d40fdaffc0c38902fbaca.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"四、JSON类型的POST请求（application-json）\"><a href=\"#四、JSON类型的POST请求（application-json）\" class=\"headerlink\" title=\"四、JSON类型的POST请求（application/json）\"></a>四、JSON类型的POST请求（application/json）</h3><p>1、使用字符串入参去请求post请求</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/post\"</span></span><br><span class=\"line\"><span class=\"comment\"># 字符串入参</span></span><br><span class=\"line\">data = <span class=\"string\">'''&#123;</span></span><br><span class=\"line\"><span class=\"string\">    \"name\": \"xiajian\",</span></span><br><span class=\"line\"><span class=\"string\">    \"age\": 22</span></span><br><span class=\"line\"><span class=\"string\">            &#125;'''</span>  <span class=\"comment\"># 多行文本, 字符串格式，也可以单行（注意外层有引号，为字符串） data = '&#123;\"name\": \"xiajian\", \"age\": 22&#125;'</span></span><br><span class=\"line\">print(type(data))  <span class=\"comment\"># 打印data数据类型</span></span><br><span class=\"line\">res = requests.post(url=url, data=data)  <span class=\"comment\"># data支持字典或字符串</span></span><br><span class=\"line\">print(res.text)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/48d84e40caf24c52b6fb6a0fe90c1ffa.png\" alt=\"在这里插入图片描述\"></p>\n<blockquote>\n<p>data请求参数支持字典也支持字符串，如果是字典格式，requests方法会将其按照默认表单urlencoded格式转换为字符串，如果是字符串则不转化</p>\n</blockquote>\n<p>如果data以字符串格式传输需要遵循以下几点：</p>\n<ul>\n<li>必须是严格的JSON格式字符串，里面必须用双引号，k-v之间必须有逗号，布尔值必须是小写的true/false等等</li>\n<li>不能有中文，直接传字符串不会自动编码</li>\n</ul>\n<hr>\n<p>2、使用json去请求post请求</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">\"http://httpbin.org/post\"</span></span><br><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"xiajian\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"age\"</span>: <span class=\"number\">22</span></span><br><span class=\"line\">&#125;  <span class=\"comment\"># 字典格式，方便添加</span></span><br><span class=\"line\">res = requests.post(url=url, json=data)  <span class=\"comment\"># JSON参数会自动将字典格式转为合法的JSON文本并添加headers</span></span><br><span class=\"line\">print(res.text)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/d084c4abbf4d4352847b256b12db63d5.png\" alt=\"在这里插入图片描述\"></p>"},{"title":"01环境搭建-使用Python+requests做接口测试","abbrlink":"9d1414ba","date":"2022-05-03T15:55:01.000Z","_content":"\n## 一、为什么使用Python+requests做接口测试\n\n**选用合适的库做接口测试 为什么要重点学习requests模块，而不是urllib**\n\n- requests的底层实现就是urllib\n- requests在python2 和python3中通用，方法完全一样\n- requests简单易用\n- Requests能够自动帮助我们解压(gzip压缩的等)响应内容\n- Requests：让HTTP服务人类！\n\nOK，开始愉快的学习requests库吧，在python的标准库中，虽然提供了urllib,utllib2,httplib，但是做接口测试，requests真心好，正如官方说的，“让HTTP服务人类”，一言以蔽之，说明一切，关于它的方法论，这里不是讨论的重点，重点是我们要开始学习它。<!-- more --> \n\n## 二、安装request库\n安装request库的方式非常简单，安装命令为：\n\n\tpip  install requests\n\n![1651595044388](/img/blog/Python接口自动化测试/1651595044388.png)\n\n看到显示Successfully installed...表示安装成功。\n\n可以试验下，输入import requests然后回车，没有报错就确认时安装成功了。\n\n![1651595166002](/img/blog/Python接口自动化测试/1651595166002.png)\n\n\n\n## 三、在Pycharm里面做个小demo体验下\n\n```python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time : 2022/5/5 14:24\n# @Author : 夏见。\n# @File : test01.py\n\nimport requests\n\nres = requests.get('http://httpbin.org/get')\n\nprint(res.json())\n\n```\n\n![1651732273876](/img/blog/Python接口自动化测试/1651732273876.png)","source":"_posts/Python接口自动化测试/01环境搭建-使用Python+request做接口测试.md","raw":"---\ntitle: 01环境搭建-使用Python+requests做接口测试\nabbrlink: 9d1414ba\ndate: 2022-05-03 23:55:01\ntags:\n  - Python接口自动化测试\ncategories:\n  - Python接口自动化测试\n---\n\n## 一、为什么使用Python+requests做接口测试\n\n**选用合适的库做接口测试 为什么要重点学习requests模块，而不是urllib**\n\n- requests的底层实现就是urllib\n- requests在python2 和python3中通用，方法完全一样\n- requests简单易用\n- Requests能够自动帮助我们解压(gzip压缩的等)响应内容\n- Requests：让HTTP服务人类！\n\nOK，开始愉快的学习requests库吧，在python的标准库中，虽然提供了urllib,utllib2,httplib，但是做接口测试，requests真心好，正如官方说的，“让HTTP服务人类”，一言以蔽之，说明一切，关于它的方法论，这里不是讨论的重点，重点是我们要开始学习它。<!-- more --> \n\n## 二、安装request库\n安装request库的方式非常简单，安装命令为：\n\n\tpip  install requests\n\n![1651595044388](/img/blog/Python接口自动化测试/1651595044388.png)\n\n看到显示Successfully installed...表示安装成功。\n\n可以试验下，输入import requests然后回车，没有报错就确认时安装成功了。\n\n![1651595166002](/img/blog/Python接口自动化测试/1651595166002.png)\n\n\n\n## 三、在Pycharm里面做个小demo体验下\n\n```python\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n# @Time : 2022/5/5 14:24\n# @Author : 夏见。\n# @File : test01.py\n\nimport requests\n\nres = requests.get('http://httpbin.org/get')\n\nprint(res.json())\n\n```\n\n![1651732273876](/img/blog/Python接口自动化测试/1651732273876.png)","slug":"Python接口自动化测试/01环境搭建-使用Python+request做接口测试","published":1,"updated":"2022-05-03T15:55:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xr003mn4ep8g8n6dzl","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"一、为什么使用Python-requests做接口测试\"><a href=\"#一、为什么使用Python-requests做接口测试\" class=\"headerlink\" title=\"一、为什么使用Python+requests做接口测试\"></a>一、为什么使用Python+requests做接口测试</h2><p><strong>选用合适的库做接口测试 为什么要重点学习requests模块，而不是urllib</strong></p>\n<ul>\n<li>requests的底层实现就是urllib</li>\n<li>requests在python2 和python3中通用，方法完全一样</li>\n<li>requests简单易用</li>\n<li>Requests能够自动帮助我们解压(gzip压缩的等)响应内容</li>\n<li>Requests：让HTTP服务人类！</li>\n</ul>\n<p>OK，开始愉快的学习requests库吧，在python的标准库中，虽然提供了urllib,utllib2,httplib，但是做接口测试，requests真心好，正如官方说的，“让HTTP服务人类”，一言以蔽之，说明一切，关于它的方法论，这里不是讨论的重点，重点是我们要开始学习它。<a id=\"more\"></a> </p>\n<h2 id=\"二、安装request库\"><a href=\"#二、安装request库\" class=\"headerlink\" title=\"二、安装request库\"></a>二、安装request库</h2><p>安装request库的方式非常简单，安装命令为：</p>\n<pre><code>pip  install requests</code></pre><p><img src=\"/img/blog/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1651595044388.png\" alt=\"1651595044388\"></p>\n<p>看到显示Successfully installed…表示安装成功。</p>\n<p>可以试验下，输入import requests然后回车，没有报错就确认时安装成功了。</p>\n<p><img src=\"/img/blog/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1651595166002.png\" alt=\"1651595166002\"></p>\n<h2 id=\"三、在Pycharm里面做个小demo体验下\"><a href=\"#三、在Pycharm里面做个小demo体验下\" class=\"headerlink\" title=\"三、在Pycharm里面做个小demo体验下\"></a>三、在Pycharm里面做个小demo体验下</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># @Time : 2022/5/5 14:24</span></span><br><span class=\"line\"><span class=\"comment\"># @Author : 夏见。</span></span><br><span class=\"line\"><span class=\"comment\"># @File : test01.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">res = requests.get(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(res.json())</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/blog/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1651732273876.png\" alt=\"1651732273876\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、为什么使用Python-requests做接口测试\"><a href=\"#一、为什么使用Python-requests做接口测试\" class=\"headerlink\" title=\"一、为什么使用Python+requests做接口测试\"></a>一、为什么使用Python+requests做接口测试</h2><p><strong>选用合适的库做接口测试 为什么要重点学习requests模块，而不是urllib</strong></p>\n<ul>\n<li>requests的底层实现就是urllib</li>\n<li>requests在python2 和python3中通用，方法完全一样</li>\n<li>requests简单易用</li>\n<li>Requests能够自动帮助我们解压(gzip压缩的等)响应内容</li>\n<li>Requests：让HTTP服务人类！</li>\n</ul>\n<p>OK，开始愉快的学习requests库吧，在python的标准库中，虽然提供了urllib,utllib2,httplib，但是做接口测试，requests真心好，正如官方说的，“让HTTP服务人类”，一言以蔽之，说明一切，关于它的方法论，这里不是讨论的重点，重点是我们要开始学习它。","more":"</p>\n<h2 id=\"二、安装request库\"><a href=\"#二、安装request库\" class=\"headerlink\" title=\"二、安装request库\"></a>二、安装request库</h2><p>安装request库的方式非常简单，安装命令为：</p>\n<pre><code>pip  install requests</code></pre><p><img src=\"/img/blog/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1651595044388.png\" alt=\"1651595044388\"></p>\n<p>看到显示Successfully installed…表示安装成功。</p>\n<p>可以试验下，输入import requests然后回车，没有报错就确认时安装成功了。</p>\n<p><img src=\"/img/blog/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1651595166002.png\" alt=\"1651595166002\"></p>\n<h2 id=\"三、在Pycharm里面做个小demo体验下\"><a href=\"#三、在Pycharm里面做个小demo体验下\" class=\"headerlink\" title=\"三、在Pycharm里面做个小demo体验下\"></a>三、在Pycharm里面做个小demo体验下</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># @Time : 2022/5/5 14:24</span></span><br><span class=\"line\"><span class=\"comment\"># @Author : 夏见。</span></span><br><span class=\"line\"><span class=\"comment\"># @File : test01.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\">res = requests.get(<span class=\"string\">'http://httpbin.org/get'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(res.json())</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/img/blog/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1651732273876.png\" alt=\"1651732273876\"></p>"},{"title":"Python基础篇02-list和tuple常用操作","date":"2022-01-16T07:48:20.000Z","abbrlink":"d2331223","_content":"\nlist和tuple常用操作<!-- more -->\n\n\n# 列表\n\n- 列表用[]定义\n- 如果列表有多个元素,元素和元素用逗号隔开\n- 用[下标]方式访问列表中具体的元素\n- 下标从0开始\n  - 列表中第一个元素下标为0\n- 如果下标超过列表中元素的范围,程序出错\n\n## list常用方法\n\n- insert(索引, 值)\n  - 往列表指定的索引位置插入指定的值\n\n- append(值)\n  - 在列表的最后追加指定的值\n- extend(列表)\n  - 把指定列表追加到后面,相当于两个列表合并\n- 列表名[索引] = 值\n  - 修改列表元素的值\n\n### 代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\ndef list_add_method():\n    list_date = []\n    return list_date\n\n\n# 遍历输出列表所以内容\ndef get_all_data(data):\n    for n in data:\n        print(\"list_data第\", data.index(n), end=\"\")\n        print(\"个数据为：\", n)\n    print(\"_\" * 100)\n    print()\n\n\nif __name__ == '__main__':\n    data = list_add_method()\n    data.append(\"append在末尾添加数据\")\n    get_all_data(data)\n\n    data.insert(0, \"insert在指定索引位置增加数据\")\n    get_all_data(data)\n\n    list_extend_date = [\"飞花\", \"血月\"]\n    # extend方法 追加另一个列表的值到这个列表\n    data.extend(list_extend_date)\n    get_all_data(data)\n    \n    data[1] = \"修改index为1的数据为NONE\"\n    get_all_data(data)\n\n```\n\n\n\n## 删除列表元素\n\n- del(列表名[索引])\n  - 删除列表指定索引位置的元素\n- 列表名.remove(值)\n  - 删除列表中指定值\n- 列表名.pop()\n  - 删除最后一个元素\n- 列表名.pop(索引)\n  - 删除指定索引位置元素\n  - 类似于del\n- 列表名.clear()\n  - 删除列表所有元素\n\n### 代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\ndef list_del_method():\n    list_date = [\"采薇采薇，薇亦作止\", \"曰归曰归，岁亦莫止\", \"靡室靡家，猃狁之故\", \"不遑启居，猃狁之故\"]\n    return list_date\n\n\n# 遍历输出列表所以内容\ndef get_all_data(data):\n    for n in data:\n        print(\"list_data第\", data.index(n), end=\"\")\n        print(\"个数据为：\", n)\n    print(\"_\" * 100)\n    print()\n\n\nif __name__ == '__main__':\n    data = list_del_method()\n    get_all_data(data)\n\n    del (data[0])  # 删除指定索引的数据\n    get_all_data(data)\n\n    data.pop(1)  # 删除指定索引数据\n    get_all_data(data)\n\n    data.pop()  # 删除末尾数据\n    get_all_data(data)\n\n    data.clear()  # 清空列表\n    get_all_data(data)\n\n```\n\n\n\n## 统计列表元素\n\n- 列表名.count(值)\n  \n  - 统计指定值在列表中出现的次数\n  \n- 列表名.index(值)\n  - 计算指定值的下标\n  - 如果有多个相同的值,返回第一个值的下标\n  - 如果值不存在,程序出错\n\n###  代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\ndef list_del_method():\n    list_date = [5, 5, 4, 1, 7, 4, 5, 1, 6, 8, 8, 6, 6]\n    return list_date\n\n\n# 遍历输出列表所以内容\ndef get_all_data(data):\n    for n in data:\n        # 列表index函数，获取当前下标的值\n        print(\"list_data第\", data.index(n), end=\"\")\n        print(\"个数据为：\", n)\n    print(\"_\" * 100)\n    print()\n\n\nif __name__ == '__main__':\n    data = list_del_method()\n    print(\"_\" * 100)\n\n    # 打印6在列表中出现了几次\n    print(\"6在列表中出现了\", data.count(6), \"次\")\n    print(\"_\" * 100)\n\n```\n\n\n## 列表排序\n\n- 列表名.sort()\n  - 升序排序\n- 列表名.sort(reverse=True)\n  - 降序排序\n- 列表名.reverse()\n  - 逆置,把列表中所有的元素颠倒过来\n\n###  代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\ndef list_del_method():\n    list_date = [5, 5, 4, 1, 7, 4, 5, 1, 6, 8, 8, 6, 6]\n    return list_date\n\n\n# 遍历输出列表所以内容\ndef get_all_data(data):\n    for n in data:\n        # 列表index函数，获取当前下标的值\n        print(\"list_data第\", data.index(n), end=\"\")\n        print(\"个数据为：\", n)\n    print(\"_\" * 100)\n    print()\n\n\nif __name__ == '__main__':\n    data = list_del_method()\n    print(\"_\" * 100)\n\n    print(\"升序排序\")\n    data.sort()  # 升序排序\n    get_all_data(data)\n\n    print(\"降序排序\")\n    data.sort(reverse=True)  # 降序排序\n    get_all_data(data)\n\n    print(\"逆置，反转\")\n    data.reverse()\n    get_all_data(data)\n\n```\n\n# 拆包\n\n- 拆包就是把列表或者元组或者集合以及字典中的每个元素拆分出来\n- 变量1, 变量2, 变量n = 列表名\n  - 等号左边变量的数量要和等号右边列表中元素的数量一致\n\n# 列表推导式\n\n- 可以快速的生成一个比较大的列表\n- [x for x in range(10)]\n  - 从1到9,9个数字\n- [x for x in range(3, 100)]\n  - 从3到99\n- 带条件的推导式\n- [x for x in range(1, 100) if x % 3 == 0]\n  - 从1到99所有能被3整除的数字\n\n### 代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\nif __name__ == '__main__':\n    # 列表推导式 定义一个长列表\n    # 从1到99步长为2的所以数字\n    data = [x for x in range(1, 100, 2)]\n    # 从1到99所以能被3整除的数字\n    data1 = [x for x in range(1, 100, 2) if x % 3 == 0]\n    # 解包list\n    print(*data)\n    print(*data1)\n```\n\n# 公共方法\n\n- dir查看对象所有的方法\n\t- dir(变量名)\n- len返回非数字类型的元素数量\n  - 包括列表,字符串,元组等\n- len(变量名)\n- max(列表)\n  - 返回列表中最大的元素\n- min(列表)\n  - 返回列表中最小的元素\n- 值 in 列表\n  - 判断指定的值是否在列表里面,如果在返回True,否则返回False\n  - 可以是列表,也可以是字符串和其他非数字类型\n- 值 not in 列表\n  - 判断指定的值是否不在列表里面,如果不在,返回True,在返回False\n\n\n# 元组\n\n- 元组和列表类似,区别是元组的元素不能修改\n- 通过()定义元组\n- a = ()\n  - 定义一个空元组\n- a = (1, )\n  - 定义一个只有一个元素的元组\n- a = (1, 2, 3)\n  - 定义有三个元素的元组\n- 定义元组的时候可以省略()\n- a = 1, 2, 3\n\n### 代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\nif __name__ == '__main__':\n    # 元祖和列表区别式，元祖定义后不可修改\n    # 定义一个空元祖\n    tuple01 = ()\n\n    # 定义1个值得元祖，需要在值后面加，\n    str = (\"Test\")\n    tuple02 = (\"Test\",)\n    print(\"str的类型为：\", type(str))\n    print(\"tuple02的类型为：\", type(tuple02))\n\n    # 定义元祖可省略括号\n    tuple03 = \"Test\", \"我是元祖\", \"Test\"\n\n    print(\"tuple03的类型为：\", type(tuple03))\n    print(*tuple03)\n\n    for n in tuple03:\n        print(tuple03.index(n))\n        print(tuple03.count(n))\n\n```\n\n## 元组和列表的区别\n\n- 元组可以理解为一个只读的列表,除了修改元素方法不同,其他方法和列表相同\n\n## 元组和列表的转换\n\n- 列表变量 = list(元组变量)\n  - 把元组转换为列表\n- 元组变量 = tuple(列表变量)\n  - 把列表转换为元组\n- 在python中转化数据类型就是用, 数据类型的关键字(要转化的内容)\n  - 要转化内容一定是可转化的\n\n### 代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\nif __name__ == '__main__':\n    # 元祖和列表区别式，元祖定义后不可修改\n    # 定义一个空元祖\n    tuple01 = (\"Test\", \"我是元祖\", \"Test\")\n\n    print(type(tuple01))\n    list01 = list(tuple01)\n    print(type(list01))\n    list01.append(\"转list后可修改数据\")\n    # 在转回tuple\n    tuple02 = tuple(list01)\n    print(type(tuple02))\n    print(*tuple02)\n\n```\n\n\n\n\n\n\n\n","source":"_posts/Python自动化/Python基础篇02-list和tuple常用操作.md","raw":"---\ntitle: Python基础篇02-list和tuple常用操作\ndate: 2022-01-16 15:48:20\nabbrlink: d2331223\ntags:\n - Python自动化\ncategories:\n  - Python自动化\n---\n\nlist和tuple常用操作<!-- more -->\n\n\n# 列表\n\n- 列表用[]定义\n- 如果列表有多个元素,元素和元素用逗号隔开\n- 用[下标]方式访问列表中具体的元素\n- 下标从0开始\n  - 列表中第一个元素下标为0\n- 如果下标超过列表中元素的范围,程序出错\n\n## list常用方法\n\n- insert(索引, 值)\n  - 往列表指定的索引位置插入指定的值\n\n- append(值)\n  - 在列表的最后追加指定的值\n- extend(列表)\n  - 把指定列表追加到后面,相当于两个列表合并\n- 列表名[索引] = 值\n  - 修改列表元素的值\n\n### 代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\ndef list_add_method():\n    list_date = []\n    return list_date\n\n\n# 遍历输出列表所以内容\ndef get_all_data(data):\n    for n in data:\n        print(\"list_data第\", data.index(n), end=\"\")\n        print(\"个数据为：\", n)\n    print(\"_\" * 100)\n    print()\n\n\nif __name__ == '__main__':\n    data = list_add_method()\n    data.append(\"append在末尾添加数据\")\n    get_all_data(data)\n\n    data.insert(0, \"insert在指定索引位置增加数据\")\n    get_all_data(data)\n\n    list_extend_date = [\"飞花\", \"血月\"]\n    # extend方法 追加另一个列表的值到这个列表\n    data.extend(list_extend_date)\n    get_all_data(data)\n    \n    data[1] = \"修改index为1的数据为NONE\"\n    get_all_data(data)\n\n```\n\n\n\n## 删除列表元素\n\n- del(列表名[索引])\n  - 删除列表指定索引位置的元素\n- 列表名.remove(值)\n  - 删除列表中指定值\n- 列表名.pop()\n  - 删除最后一个元素\n- 列表名.pop(索引)\n  - 删除指定索引位置元素\n  - 类似于del\n- 列表名.clear()\n  - 删除列表所有元素\n\n### 代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\ndef list_del_method():\n    list_date = [\"采薇采薇，薇亦作止\", \"曰归曰归，岁亦莫止\", \"靡室靡家，猃狁之故\", \"不遑启居，猃狁之故\"]\n    return list_date\n\n\n# 遍历输出列表所以内容\ndef get_all_data(data):\n    for n in data:\n        print(\"list_data第\", data.index(n), end=\"\")\n        print(\"个数据为：\", n)\n    print(\"_\" * 100)\n    print()\n\n\nif __name__ == '__main__':\n    data = list_del_method()\n    get_all_data(data)\n\n    del (data[0])  # 删除指定索引的数据\n    get_all_data(data)\n\n    data.pop(1)  # 删除指定索引数据\n    get_all_data(data)\n\n    data.pop()  # 删除末尾数据\n    get_all_data(data)\n\n    data.clear()  # 清空列表\n    get_all_data(data)\n\n```\n\n\n\n## 统计列表元素\n\n- 列表名.count(值)\n  \n  - 统计指定值在列表中出现的次数\n  \n- 列表名.index(值)\n  - 计算指定值的下标\n  - 如果有多个相同的值,返回第一个值的下标\n  - 如果值不存在,程序出错\n\n###  代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\ndef list_del_method():\n    list_date = [5, 5, 4, 1, 7, 4, 5, 1, 6, 8, 8, 6, 6]\n    return list_date\n\n\n# 遍历输出列表所以内容\ndef get_all_data(data):\n    for n in data:\n        # 列表index函数，获取当前下标的值\n        print(\"list_data第\", data.index(n), end=\"\")\n        print(\"个数据为：\", n)\n    print(\"_\" * 100)\n    print()\n\n\nif __name__ == '__main__':\n    data = list_del_method()\n    print(\"_\" * 100)\n\n    # 打印6在列表中出现了几次\n    print(\"6在列表中出现了\", data.count(6), \"次\")\n    print(\"_\" * 100)\n\n```\n\n\n## 列表排序\n\n- 列表名.sort()\n  - 升序排序\n- 列表名.sort(reverse=True)\n  - 降序排序\n- 列表名.reverse()\n  - 逆置,把列表中所有的元素颠倒过来\n\n###  代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\ndef list_del_method():\n    list_date = [5, 5, 4, 1, 7, 4, 5, 1, 6, 8, 8, 6, 6]\n    return list_date\n\n\n# 遍历输出列表所以内容\ndef get_all_data(data):\n    for n in data:\n        # 列表index函数，获取当前下标的值\n        print(\"list_data第\", data.index(n), end=\"\")\n        print(\"个数据为：\", n)\n    print(\"_\" * 100)\n    print()\n\n\nif __name__ == '__main__':\n    data = list_del_method()\n    print(\"_\" * 100)\n\n    print(\"升序排序\")\n    data.sort()  # 升序排序\n    get_all_data(data)\n\n    print(\"降序排序\")\n    data.sort(reverse=True)  # 降序排序\n    get_all_data(data)\n\n    print(\"逆置，反转\")\n    data.reverse()\n    get_all_data(data)\n\n```\n\n# 拆包\n\n- 拆包就是把列表或者元组或者集合以及字典中的每个元素拆分出来\n- 变量1, 变量2, 变量n = 列表名\n  - 等号左边变量的数量要和等号右边列表中元素的数量一致\n\n# 列表推导式\n\n- 可以快速的生成一个比较大的列表\n- [x for x in range(10)]\n  - 从1到9,9个数字\n- [x for x in range(3, 100)]\n  - 从3到99\n- 带条件的推导式\n- [x for x in range(1, 100) if x % 3 == 0]\n  - 从1到99所有能被3整除的数字\n\n### 代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\nif __name__ == '__main__':\n    # 列表推导式 定义一个长列表\n    # 从1到99步长为2的所以数字\n    data = [x for x in range(1, 100, 2)]\n    # 从1到99所以能被3整除的数字\n    data1 = [x for x in range(1, 100, 2) if x % 3 == 0]\n    # 解包list\n    print(*data)\n    print(*data1)\n```\n\n# 公共方法\n\n- dir查看对象所有的方法\n\t- dir(变量名)\n- len返回非数字类型的元素数量\n  - 包括列表,字符串,元组等\n- len(变量名)\n- max(列表)\n  - 返回列表中最大的元素\n- min(列表)\n  - 返回列表中最小的元素\n- 值 in 列表\n  - 判断指定的值是否在列表里面,如果在返回True,否则返回False\n  - 可以是列表,也可以是字符串和其他非数字类型\n- 值 not in 列表\n  - 判断指定的值是否不在列表里面,如果不在,返回True,在返回False\n\n\n# 元组\n\n- 元组和列表类似,区别是元组的元素不能修改\n- 通过()定义元组\n- a = ()\n  - 定义一个空元组\n- a = (1, )\n  - 定义一个只有一个元素的元组\n- a = (1, 2, 3)\n  - 定义有三个元素的元组\n- 定义元组的时候可以省略()\n- a = 1, 2, 3\n\n### 代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\nif __name__ == '__main__':\n    # 元祖和列表区别式，元祖定义后不可修改\n    # 定义一个空元祖\n    tuple01 = ()\n\n    # 定义1个值得元祖，需要在值后面加，\n    str = (\"Test\")\n    tuple02 = (\"Test\",)\n    print(\"str的类型为：\", type(str))\n    print(\"tuple02的类型为：\", type(tuple02))\n\n    # 定义元祖可省略括号\n    tuple03 = \"Test\", \"我是元祖\", \"Test\"\n\n    print(\"tuple03的类型为：\", type(tuple03))\n    print(*tuple03)\n\n    for n in tuple03:\n        print(tuple03.index(n))\n        print(tuple03.count(n))\n\n```\n\n## 元组和列表的区别\n\n- 元组可以理解为一个只读的列表,除了修改元素方法不同,其他方法和列表相同\n\n## 元组和列表的转换\n\n- 列表变量 = list(元组变量)\n  - 把元组转换为列表\n- 元组变量 = tuple(列表变量)\n  - 把列表转换为元组\n- 在python中转化数据类型就是用, 数据类型的关键字(要转化的内容)\n  - 要转化内容一定是可转化的\n\n### 代码举例：\n\n```python\n#!/usr/bin/env python\n# -*- coding:utf-8 -*-\n\n\nif __name__ == '__main__':\n    # 元祖和列表区别式，元祖定义后不可修改\n    # 定义一个空元祖\n    tuple01 = (\"Test\", \"我是元祖\", \"Test\")\n\n    print(type(tuple01))\n    list01 = list(tuple01)\n    print(type(list01))\n    list01.append(\"转list后可修改数据\")\n    # 在转回tuple\n    tuple02 = tuple(list01)\n    print(type(tuple02))\n    print(*tuple02)\n\n```\n\n\n\n\n\n\n\n","slug":"Python自动化/Python基础篇02-list和tuple常用操作","published":1,"updated":"2022-01-16T07:48:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xr003pn4ep1wm7944d","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>list和tuple常用操作<a id=\"more\"></a></p>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><ul>\n<li>列表用[]定义</li>\n<li>如果列表有多个元素,元素和元素用逗号隔开</li>\n<li>用[下标]方式访问列表中具体的元素</li>\n<li>下标从0开始<ul>\n<li>列表中第一个元素下标为0</li>\n</ul>\n</li>\n<li>如果下标超过列表中元素的范围,程序出错</li>\n</ul>\n<h2 id=\"list常用方法\"><a href=\"#list常用方法\" class=\"headerlink\" title=\"list常用方法\"></a>list常用方法</h2><ul>\n<li><p>insert(索引, 值)</p>\n<ul>\n<li>往列表指定的索引位置插入指定的值</li>\n</ul>\n</li>\n<li><p>append(值)</p>\n<ul>\n<li>在列表的最后追加指定的值</li>\n</ul>\n</li>\n<li><p>extend(列表)</p>\n<ul>\n<li>把指定列表追加到后面,相当于两个列表合并</li>\n</ul>\n</li>\n<li><p>列表名[索引] = 值</p>\n<ul>\n<li>修改列表元素的值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：\"><a href=\"#代码举例：\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_add_method</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    list_date = []</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list_date</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历输出列表所以内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_all_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        print(<span class=\"string\">\"list_data第\"</span>, data.index(n), end=<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"个数据为：\"</span>, n)</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    data = list_add_method()</span><br><span class=\"line\">    data.append(<span class=\"string\">\"append在末尾添加数据\"</span>)</span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    data.insert(<span class=\"number\">0</span>, <span class=\"string\">\"insert在指定索引位置增加数据\"</span>)</span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    list_extend_date = [<span class=\"string\">\"飞花\"</span>, <span class=\"string\">\"血月\"</span>]</span><br><span class=\"line\">    <span class=\"comment\"># extend方法 追加另一个列表的值到这个列表</span></span><br><span class=\"line\">    data.extend(list_extend_date)</span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\">    </span><br><span class=\"line\">    data[<span class=\"number\">1</span>] = <span class=\"string\">\"修改index为1的数据为NONE\"</span></span><br><span class=\"line\">    get_all_data(data)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除列表元素\"><a href=\"#删除列表元素\" class=\"headerlink\" title=\"删除列表元素\"></a>删除列表元素</h2><ul>\n<li>del(列表名[索引])<ul>\n<li>删除列表指定索引位置的元素</li>\n</ul>\n</li>\n<li>列表名.remove(值)<ul>\n<li>删除列表中指定值</li>\n</ul>\n</li>\n<li>列表名.pop()<ul>\n<li>删除最后一个元素</li>\n</ul>\n</li>\n<li>列表名.pop(索引)<ul>\n<li>删除指定索引位置元素</li>\n<li>类似于del</li>\n</ul>\n</li>\n<li>列表名.clear()<ul>\n<li>删除列表所有元素</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：-1\"><a href=\"#代码举例：-1\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_del_method</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    list_date = [<span class=\"string\">\"采薇采薇，薇亦作止\"</span>, <span class=\"string\">\"曰归曰归，岁亦莫止\"</span>, <span class=\"string\">\"靡室靡家，猃狁之故\"</span>, <span class=\"string\">\"不遑启居，猃狁之故\"</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list_date</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历输出列表所以内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_all_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        print(<span class=\"string\">\"list_data第\"</span>, data.index(n), end=<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"个数据为：\"</span>, n)</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    data = list_del_method()</span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">del</span> (data[<span class=\"number\">0</span>])  <span class=\"comment\"># 删除指定索引的数据</span></span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    data.pop(<span class=\"number\">1</span>)  <span class=\"comment\"># 删除指定索引数据</span></span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    data.pop()  <span class=\"comment\"># 删除末尾数据</span></span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    data.clear()  <span class=\"comment\"># 清空列表</span></span><br><span class=\"line\">    get_all_data(data)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"统计列表元素\"><a href=\"#统计列表元素\" class=\"headerlink\" title=\"统计列表元素\"></a>统计列表元素</h2><ul>\n<li><p>列表名.count(值)</p>\n<ul>\n<li>统计指定值在列表中出现的次数</li>\n</ul>\n</li>\n<li><p>列表名.index(值)</p>\n<ul>\n<li>计算指定值的下标</li>\n<li>如果有多个相同的值,返回第一个值的下标</li>\n<li>如果值不存在,程序出错</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：-2\"><a href=\"#代码举例：-2\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_del_method</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    list_date = [<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list_date</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历输出列表所以内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_all_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        <span class=\"comment\"># 列表index函数，获取当前下标的值</span></span><br><span class=\"line\">        print(<span class=\"string\">\"list_data第\"</span>, data.index(n), end=<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"个数据为：\"</span>, n)</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    data = list_del_method()</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 打印6在列表中出现了几次</span></span><br><span class=\"line\">    print(<span class=\"string\">\"6在列表中出现了\"</span>, data.count(<span class=\"number\">6</span>), <span class=\"string\">\"次\"</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"列表排序\"><a href=\"#列表排序\" class=\"headerlink\" title=\"列表排序\"></a>列表排序</h2><ul>\n<li>列表名.sort()<ul>\n<li>升序排序</li>\n</ul>\n</li>\n<li>列表名.sort(reverse=True)<ul>\n<li>降序排序</li>\n</ul>\n</li>\n<li>列表名.reverse()<ul>\n<li>逆置,把列表中所有的元素颠倒过来</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：-3\"><a href=\"#代码举例：-3\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_del_method</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    list_date = [<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list_date</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历输出列表所以内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_all_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        <span class=\"comment\"># 列表index函数，获取当前下标的值</span></span><br><span class=\"line\">        print(<span class=\"string\">\"list_data第\"</span>, data.index(n), end=<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"个数据为：\"</span>, n)</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    data = list_del_method()</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"升序排序\"</span>)</span><br><span class=\"line\">    data.sort()  <span class=\"comment\"># 升序排序</span></span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"降序排序\"</span>)</span><br><span class=\"line\">    data.sort(reverse=<span class=\"literal\">True</span>)  <span class=\"comment\"># 降序排序</span></span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"逆置，反转\"</span>)</span><br><span class=\"line\">    data.reverse()</span><br><span class=\"line\">    get_all_data(data)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"拆包\"><a href=\"#拆包\" class=\"headerlink\" title=\"拆包\"></a>拆包</h1><ul>\n<li>拆包就是把列表或者元组或者集合以及字典中的每个元素拆分出来</li>\n<li>变量1, 变量2, 变量n = 列表名<ul>\n<li>等号左边变量的数量要和等号右边列表中元素的数量一致</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"列表推导式\"><a href=\"#列表推导式\" class=\"headerlink\" title=\"列表推导式\"></a>列表推导式</h1><ul>\n<li>可以快速的生成一个比较大的列表</li>\n<li>[x for x in range(10)]<ul>\n<li>从1到9,9个数字</li>\n</ul>\n</li>\n<li>[x for x in range(3, 100)]<ul>\n<li>从3到99</li>\n</ul>\n</li>\n<li>带条件的推导式</li>\n<li>[x for x in range(1, 100) if x % 3 == 0]<ul>\n<li>从1到99所有能被3整除的数字</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：-4\"><a href=\"#代码举例：-4\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 列表推导式 定义一个长列表</span></span><br><span class=\"line\">    <span class=\"comment\"># 从1到99步长为2的所以数字</span></span><br><span class=\"line\">    data = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">100</span>, <span class=\"number\">2</span>)]</span><br><span class=\"line\">    <span class=\"comment\"># 从1到99所以能被3整除的数字</span></span><br><span class=\"line\">    data1 = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">100</span>, <span class=\"number\">2</span>) <span class=\"keyword\">if</span> x % <span class=\"number\">3</span> == <span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"comment\"># 解包list</span></span><br><span class=\"line\">    print(*data)</span><br><span class=\"line\">    print(*data1)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"公共方法\"><a href=\"#公共方法\" class=\"headerlink\" title=\"公共方法\"></a>公共方法</h1><ul>\n<li>dir查看对象所有的方法<ul>\n<li>dir(变量名)</li>\n</ul>\n</li>\n<li>len返回非数字类型的元素数量<ul>\n<li>包括列表,字符串,元组等</li>\n</ul>\n</li>\n<li>len(变量名)</li>\n<li>max(列表)<ul>\n<li>返回列表中最大的元素</li>\n</ul>\n</li>\n<li>min(列表)<ul>\n<li>返回列表中最小的元素</li>\n</ul>\n</li>\n<li>值 in 列表<ul>\n<li>判断指定的值是否在列表里面,如果在返回True,否则返回False</li>\n<li>可以是列表,也可以是字符串和其他非数字类型</li>\n</ul>\n</li>\n<li>值 not in 列表<ul>\n<li>判断指定的值是否不在列表里面,如果不在,返回True,在返回False</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h1><ul>\n<li>元组和列表类似,区别是元组的元素不能修改</li>\n<li>通过()定义元组</li>\n<li>a = ()<ul>\n<li>定义一个空元组</li>\n</ul>\n</li>\n<li>a = (1, )<ul>\n<li>定义一个只有一个元素的元组</li>\n</ul>\n</li>\n<li>a = (1, 2, 3)<ul>\n<li>定义有三个元素的元组</li>\n</ul>\n</li>\n<li>定义元组的时候可以省略()</li>\n<li>a = 1, 2, 3</li>\n</ul>\n<h3 id=\"代码举例：-5\"><a href=\"#代码举例：-5\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 元祖和列表区别式，元祖定义后不可修改</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义一个空元祖</span></span><br><span class=\"line\">    tuple01 = ()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 定义1个值得元祖，需要在值后面加，</span></span><br><span class=\"line\">    str = (<span class=\"string\">\"Test\"</span>)</span><br><span class=\"line\">    tuple02 = (<span class=\"string\">\"Test\"</span>,)</span><br><span class=\"line\">    print(<span class=\"string\">\"str的类型为：\"</span>, type(str))</span><br><span class=\"line\">    print(<span class=\"string\">\"tuple02的类型为：\"</span>, type(tuple02))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 定义元祖可省略括号</span></span><br><span class=\"line\">    tuple03 = <span class=\"string\">\"Test\"</span>, <span class=\"string\">\"我是元祖\"</span>, <span class=\"string\">\"Test\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"tuple03的类型为：\"</span>, type(tuple03))</span><br><span class=\"line\">    print(*tuple03)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> tuple03:</span><br><span class=\"line\">        print(tuple03.index(n))</span><br><span class=\"line\">        print(tuple03.count(n))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元组和列表的区别\"><a href=\"#元组和列表的区别\" class=\"headerlink\" title=\"元组和列表的区别\"></a>元组和列表的区别</h2><ul>\n<li>元组可以理解为一个只读的列表,除了修改元素方法不同,其他方法和列表相同</li>\n</ul>\n<h2 id=\"元组和列表的转换\"><a href=\"#元组和列表的转换\" class=\"headerlink\" title=\"元组和列表的转换\"></a>元组和列表的转换</h2><ul>\n<li>列表变量 = list(元组变量)<ul>\n<li>把元组转换为列表</li>\n</ul>\n</li>\n<li>元组变量 = tuple(列表变量)<ul>\n<li>把列表转换为元组</li>\n</ul>\n</li>\n<li>在python中转化数据类型就是用, 数据类型的关键字(要转化的内容)<ul>\n<li>要转化内容一定是可转化的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：-6\"><a href=\"#代码举例：-6\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 元祖和列表区别式，元祖定义后不可修改</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义一个空元祖</span></span><br><span class=\"line\">    tuple01 = (<span class=\"string\">\"Test\"</span>, <span class=\"string\">\"我是元祖\"</span>, <span class=\"string\">\"Test\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(type(tuple01))</span><br><span class=\"line\">    list01 = list(tuple01)</span><br><span class=\"line\">    print(type(list01))</span><br><span class=\"line\">    list01.append(<span class=\"string\">\"转list后可修改数据\"</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 在转回tuple</span></span><br><span class=\"line\">    tuple02 = tuple(list01)</span><br><span class=\"line\">    print(type(tuple02))</span><br><span class=\"line\">    print(*tuple02)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>list和tuple常用操作","more":"</p>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h1><ul>\n<li>列表用[]定义</li>\n<li>如果列表有多个元素,元素和元素用逗号隔开</li>\n<li>用[下标]方式访问列表中具体的元素</li>\n<li>下标从0开始<ul>\n<li>列表中第一个元素下标为0</li>\n</ul>\n</li>\n<li>如果下标超过列表中元素的范围,程序出错</li>\n</ul>\n<h2 id=\"list常用方法\"><a href=\"#list常用方法\" class=\"headerlink\" title=\"list常用方法\"></a>list常用方法</h2><ul>\n<li><p>insert(索引, 值)</p>\n<ul>\n<li>往列表指定的索引位置插入指定的值</li>\n</ul>\n</li>\n<li><p>append(值)</p>\n<ul>\n<li>在列表的最后追加指定的值</li>\n</ul>\n</li>\n<li><p>extend(列表)</p>\n<ul>\n<li>把指定列表追加到后面,相当于两个列表合并</li>\n</ul>\n</li>\n<li><p>列表名[索引] = 值</p>\n<ul>\n<li>修改列表元素的值</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：\"><a href=\"#代码举例：\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_add_method</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    list_date = []</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list_date</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历输出列表所以内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_all_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        print(<span class=\"string\">\"list_data第\"</span>, data.index(n), end=<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"个数据为：\"</span>, n)</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    data = list_add_method()</span><br><span class=\"line\">    data.append(<span class=\"string\">\"append在末尾添加数据\"</span>)</span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    data.insert(<span class=\"number\">0</span>, <span class=\"string\">\"insert在指定索引位置增加数据\"</span>)</span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    list_extend_date = [<span class=\"string\">\"飞花\"</span>, <span class=\"string\">\"血月\"</span>]</span><br><span class=\"line\">    <span class=\"comment\"># extend方法 追加另一个列表的值到这个列表</span></span><br><span class=\"line\">    data.extend(list_extend_date)</span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\">    </span><br><span class=\"line\">    data[<span class=\"number\">1</span>] = <span class=\"string\">\"修改index为1的数据为NONE\"</span></span><br><span class=\"line\">    get_all_data(data)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"删除列表元素\"><a href=\"#删除列表元素\" class=\"headerlink\" title=\"删除列表元素\"></a>删除列表元素</h2><ul>\n<li>del(列表名[索引])<ul>\n<li>删除列表指定索引位置的元素</li>\n</ul>\n</li>\n<li>列表名.remove(值)<ul>\n<li>删除列表中指定值</li>\n</ul>\n</li>\n<li>列表名.pop()<ul>\n<li>删除最后一个元素</li>\n</ul>\n</li>\n<li>列表名.pop(索引)<ul>\n<li>删除指定索引位置元素</li>\n<li>类似于del</li>\n</ul>\n</li>\n<li>列表名.clear()<ul>\n<li>删除列表所有元素</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：-1\"><a href=\"#代码举例：-1\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_del_method</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    list_date = [<span class=\"string\">\"采薇采薇，薇亦作止\"</span>, <span class=\"string\">\"曰归曰归，岁亦莫止\"</span>, <span class=\"string\">\"靡室靡家，猃狁之故\"</span>, <span class=\"string\">\"不遑启居，猃狁之故\"</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list_date</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历输出列表所以内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_all_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        print(<span class=\"string\">\"list_data第\"</span>, data.index(n), end=<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"个数据为：\"</span>, n)</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    data = list_del_method()</span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">del</span> (data[<span class=\"number\">0</span>])  <span class=\"comment\"># 删除指定索引的数据</span></span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    data.pop(<span class=\"number\">1</span>)  <span class=\"comment\"># 删除指定索引数据</span></span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    data.pop()  <span class=\"comment\"># 删除末尾数据</span></span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    data.clear()  <span class=\"comment\"># 清空列表</span></span><br><span class=\"line\">    get_all_data(data)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"统计列表元素\"><a href=\"#统计列表元素\" class=\"headerlink\" title=\"统计列表元素\"></a>统计列表元素</h2><ul>\n<li><p>列表名.count(值)</p>\n<ul>\n<li>统计指定值在列表中出现的次数</li>\n</ul>\n</li>\n<li><p>列表名.index(值)</p>\n<ul>\n<li>计算指定值的下标</li>\n<li>如果有多个相同的值,返回第一个值的下标</li>\n<li>如果值不存在,程序出错</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：-2\"><a href=\"#代码举例：-2\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_del_method</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    list_date = [<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list_date</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历输出列表所以内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_all_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        <span class=\"comment\"># 列表index函数，获取当前下标的值</span></span><br><span class=\"line\">        print(<span class=\"string\">\"list_data第\"</span>, data.index(n), end=<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"个数据为：\"</span>, n)</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    data = list_del_method()</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 打印6在列表中出现了几次</span></span><br><span class=\"line\">    print(<span class=\"string\">\"6在列表中出现了\"</span>, data.count(<span class=\"number\">6</span>), <span class=\"string\">\"次\"</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"列表排序\"><a href=\"#列表排序\" class=\"headerlink\" title=\"列表排序\"></a>列表排序</h2><ul>\n<li>列表名.sort()<ul>\n<li>升序排序</li>\n</ul>\n</li>\n<li>列表名.sort(reverse=True)<ul>\n<li>降序排序</li>\n</ul>\n</li>\n<li>列表名.reverse()<ul>\n<li>逆置,把列表中所有的元素颠倒过来</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：-3\"><a href=\"#代码举例：-3\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_del_method</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    list_date = [<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list_date</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历输出列表所以内容</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_all_data</span><span class=\"params\">(data)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        <span class=\"comment\"># 列表index函数，获取当前下标的值</span></span><br><span class=\"line\">        print(<span class=\"string\">\"list_data第\"</span>, data.index(n), end=<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        print(<span class=\"string\">\"个数据为：\"</span>, n)</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    data = list_del_method()</span><br><span class=\"line\">    print(<span class=\"string\">\"_\"</span> * <span class=\"number\">100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"升序排序\"</span>)</span><br><span class=\"line\">    data.sort()  <span class=\"comment\"># 升序排序</span></span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"降序排序\"</span>)</span><br><span class=\"line\">    data.sort(reverse=<span class=\"literal\">True</span>)  <span class=\"comment\"># 降序排序</span></span><br><span class=\"line\">    get_all_data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"逆置，反转\"</span>)</span><br><span class=\"line\">    data.reverse()</span><br><span class=\"line\">    get_all_data(data)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"拆包\"><a href=\"#拆包\" class=\"headerlink\" title=\"拆包\"></a>拆包</h1><ul>\n<li>拆包就是把列表或者元组或者集合以及字典中的每个元素拆分出来</li>\n<li>变量1, 变量2, 变量n = 列表名<ul>\n<li>等号左边变量的数量要和等号右边列表中元素的数量一致</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"列表推导式\"><a href=\"#列表推导式\" class=\"headerlink\" title=\"列表推导式\"></a>列表推导式</h1><ul>\n<li>可以快速的生成一个比较大的列表</li>\n<li>[x for x in range(10)]<ul>\n<li>从1到9,9个数字</li>\n</ul>\n</li>\n<li>[x for x in range(3, 100)]<ul>\n<li>从3到99</li>\n</ul>\n</li>\n<li>带条件的推导式</li>\n<li>[x for x in range(1, 100) if x % 3 == 0]<ul>\n<li>从1到99所有能被3整除的数字</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：-4\"><a href=\"#代码举例：-4\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 列表推导式 定义一个长列表</span></span><br><span class=\"line\">    <span class=\"comment\"># 从1到99步长为2的所以数字</span></span><br><span class=\"line\">    data = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">100</span>, <span class=\"number\">2</span>)]</span><br><span class=\"line\">    <span class=\"comment\"># 从1到99所以能被3整除的数字</span></span><br><span class=\"line\">    data1 = [x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">100</span>, <span class=\"number\">2</span>) <span class=\"keyword\">if</span> x % <span class=\"number\">3</span> == <span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"comment\"># 解包list</span></span><br><span class=\"line\">    print(*data)</span><br><span class=\"line\">    print(*data1)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"公共方法\"><a href=\"#公共方法\" class=\"headerlink\" title=\"公共方法\"></a>公共方法</h1><ul>\n<li>dir查看对象所有的方法<ul>\n<li>dir(变量名)</li>\n</ul>\n</li>\n<li>len返回非数字类型的元素数量<ul>\n<li>包括列表,字符串,元组等</li>\n</ul>\n</li>\n<li>len(变量名)</li>\n<li>max(列表)<ul>\n<li>返回列表中最大的元素</li>\n</ul>\n</li>\n<li>min(列表)<ul>\n<li>返回列表中最小的元素</li>\n</ul>\n</li>\n<li>值 in 列表<ul>\n<li>判断指定的值是否在列表里面,如果在返回True,否则返回False</li>\n<li>可以是列表,也可以是字符串和其他非数字类型</li>\n</ul>\n</li>\n<li>值 not in 列表<ul>\n<li>判断指定的值是否不在列表里面,如果不在,返回True,在返回False</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h1><ul>\n<li>元组和列表类似,区别是元组的元素不能修改</li>\n<li>通过()定义元组</li>\n<li>a = ()<ul>\n<li>定义一个空元组</li>\n</ul>\n</li>\n<li>a = (1, )<ul>\n<li>定义一个只有一个元素的元组</li>\n</ul>\n</li>\n<li>a = (1, 2, 3)<ul>\n<li>定义有三个元素的元组</li>\n</ul>\n</li>\n<li>定义元组的时候可以省略()</li>\n<li>a = 1, 2, 3</li>\n</ul>\n<h3 id=\"代码举例：-5\"><a href=\"#代码举例：-5\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 元祖和列表区别式，元祖定义后不可修改</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义一个空元祖</span></span><br><span class=\"line\">    tuple01 = ()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 定义1个值得元祖，需要在值后面加，</span></span><br><span class=\"line\">    str = (<span class=\"string\">\"Test\"</span>)</span><br><span class=\"line\">    tuple02 = (<span class=\"string\">\"Test\"</span>,)</span><br><span class=\"line\">    print(<span class=\"string\">\"str的类型为：\"</span>, type(str))</span><br><span class=\"line\">    print(<span class=\"string\">\"tuple02的类型为：\"</span>, type(tuple02))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 定义元祖可省略括号</span></span><br><span class=\"line\">    tuple03 = <span class=\"string\">\"Test\"</span>, <span class=\"string\">\"我是元祖\"</span>, <span class=\"string\">\"Test\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"tuple03的类型为：\"</span>, type(tuple03))</span><br><span class=\"line\">    print(*tuple03)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> tuple03:</span><br><span class=\"line\">        print(tuple03.index(n))</span><br><span class=\"line\">        print(tuple03.count(n))</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"元组和列表的区别\"><a href=\"#元组和列表的区别\" class=\"headerlink\" title=\"元组和列表的区别\"></a>元组和列表的区别</h2><ul>\n<li>元组可以理解为一个只读的列表,除了修改元素方法不同,其他方法和列表相同</li>\n</ul>\n<h2 id=\"元组和列表的转换\"><a href=\"#元组和列表的转换\" class=\"headerlink\" title=\"元组和列表的转换\"></a>元组和列表的转换</h2><ul>\n<li>列表变量 = list(元组变量)<ul>\n<li>把元组转换为列表</li>\n</ul>\n</li>\n<li>元组变量 = tuple(列表变量)<ul>\n<li>把列表转换为元组</li>\n</ul>\n</li>\n<li>在python中转化数据类型就是用, 数据类型的关键字(要转化的内容)<ul>\n<li>要转化内容一定是可转化的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"代码举例：-6\"><a href=\"#代码举例：-6\" class=\"headerlink\" title=\"代码举例：\"></a>代码举例：</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding:utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 元祖和列表区别式，元祖定义后不可修改</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义一个空元祖</span></span><br><span class=\"line\">    tuple01 = (<span class=\"string\">\"Test\"</span>, <span class=\"string\">\"我是元祖\"</span>, <span class=\"string\">\"Test\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(type(tuple01))</span><br><span class=\"line\">    list01 = list(tuple01)</span><br><span class=\"line\">    print(type(list01))</span><br><span class=\"line\">    list01.append(<span class=\"string\">\"转list后可修改数据\"</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 在转回tuple</span></span><br><span class=\"line\">    tuple02 = tuple(list01)</span><br><span class=\"line\">    print(type(tuple02))</span><br><span class=\"line\">    print(*tuple02)</span><br></pre></td></tr></table></figure>"},{"title":"学习笔记-Python之生成器和列表推导式的区别","abbrlink":"30fa304c","date":"2022-01-17T15:32:48.000Z","_content":"\n生成器表达式和列表推导式的区别记录<!-- more -->\n\n##   生成器表达式和列表推导式的区别:\n\n- 列表推导式比较耗内存. 一次性加载. 生成器表达式几乎不占用内存. 使用的时候才分\n配和使用内存\n- 得到的值不一样. 列表推导式得到的是一个列表. 生成器表达式获取的是一个生成器.\n## 示例\n- 同样一篮子鸡蛋. 列表推导式: 直接拿到一篮子鸡蛋. 生成器表达式: 拿到⼀个老母鸡. 需要\n  鸡蛋就给你下鸡蛋.\n- 生成器的惰性机制: 生成器只有在访问的时候才取值. 说白了了. 你找他要他才给你值. 不找他\n  要. 他是不会执行的.\n\n","source":"_posts/Python自动化/学习笔记-Python之生成器和列表推导式的区别.md","raw":"---\ntitle: 学习笔记-Python之生成器和列表推导式的区别\nabbrlink: 30fa304c\ndate: 2022-01-17 23:32:48\ntags:\n---\n\n生成器表达式和列表推导式的区别记录<!-- more -->\n\n##   生成器表达式和列表推导式的区别:\n\n- 列表推导式比较耗内存. 一次性加载. 生成器表达式几乎不占用内存. 使用的时候才分\n配和使用内存\n- 得到的值不一样. 列表推导式得到的是一个列表. 生成器表达式获取的是一个生成器.\n## 示例\n- 同样一篮子鸡蛋. 列表推导式: 直接拿到一篮子鸡蛋. 生成器表达式: 拿到⼀个老母鸡. 需要\n  鸡蛋就给你下鸡蛋.\n- 生成器的惰性机制: 生成器只有在访问的时候才取值. 说白了了. 你找他要他才给你值. 不找他\n  要. 他是不会执行的.\n\n","slug":"Python自动化/学习笔记-Python之生成器和列表推导式的区别","published":1,"updated":"2022-01-17T15:32:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xt003un4ep5to64eje","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>生成器表达式和列表推导式的区别记录<a id=\"more\"></a></p>\n<h2 id=\"生成器表达式和列表推导式的区别\"><a href=\"#生成器表达式和列表推导式的区别\" class=\"headerlink\" title=\"生成器表达式和列表推导式的区别:\"></a>生成器表达式和列表推导式的区别:</h2><ul>\n<li>列表推导式比较耗内存. 一次性加载. 生成器表达式几乎不占用内存. 使用的时候才分<br>配和使用内存</li>\n<li>得到的值不一样. 列表推导式得到的是一个列表. 生成器表达式获取的是一个生成器.<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2></li>\n<li>同样一篮子鸡蛋. 列表推导式: 直接拿到一篮子鸡蛋. 生成器表达式: 拿到⼀个老母鸡. 需要<br>鸡蛋就给你下鸡蛋.</li>\n<li>生成器的惰性机制: 生成器只有在访问的时候才取值. 说白了了. 你找他要他才给你值. 不找他<br>要. 他是不会执行的.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>生成器表达式和列表推导式的区别记录","more":"</p>\n<h2 id=\"生成器表达式和列表推导式的区别\"><a href=\"#生成器表达式和列表推导式的区别\" class=\"headerlink\" title=\"生成器表达式和列表推导式的区别:\"></a>生成器表达式和列表推导式的区别:</h2><ul>\n<li>列表推导式比较耗内存. 一次性加载. 生成器表达式几乎不占用内存. 使用的时候才分<br>配和使用内存</li>\n<li>得到的值不一样. 列表推导式得到的是一个列表. 生成器表达式获取的是一个生成器.<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2></li>\n<li>同样一篮子鸡蛋. 列表推导式: 直接拿到一篮子鸡蛋. 生成器表达式: 拿到⼀个老母鸡. 需要<br>鸡蛋就给你下鸡蛋.</li>\n<li>生成器的惰性机制: 生成器只有在访问的时候才取值. 说白了了. 你找他要他才给你值. 不找他<br>要. 他是不会执行的.</li>\n</ul>"},{"title":"【01】Shell特殊位置变量","abbrlink":"3bd3916a","date":"2022-01-09T07:32:32.000Z","_content":"\n> Linux命令Demo  <!-- more --> \n\n## 1). $0 获取脚本名称\n\n```shell\n[root@aliyun shell]# cat test.sh\necho $0\n\n[root@aliyun shell]# sh test.sh\ntest.sh\n[root@aliyun shell]#\n[root@aliyun shell]# sh /root/shell/test.sh\n/root/shell/test.sh\n\n# 如果只想获取脚本名称 basename\n[root@aliyun shell]# basename test.sh\ntest.sh\n[root@aliyun shell]# basename /root/shell/test.sh\ntest.sh\n[root@aliyun shell]#\n\n```\n\n\n\n## 2). $n表示脚本的第n个参数\n\n```shell\n# 实例1\n[root@aliyun shell]# cat test.sh\necho \"超过9个变量不加引号\"\necho $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11\n\necho \"超过9个变量需要加花括号\"\necho $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11}\n\n[root@aliyun shell]#\n[root@aliyun shell]# sh test.sh {a..z}\n超过9个变量不加引号\na b c d e f g h i a0 a1\n超过9个变量需要加花括号\na b c d e f g h i j k\n[root@aliyun shell]#\n[root@aliyun shell]# sh test.sh {1..20}\n超过9个变量不加引号\n1 2 3 4 5 6 7 8 9 10 11\n超过9个变量需要加花括号\n1 2 3 4 5 6 7 8 9 10 11\n\n# 实例2\n[root@aliyun shell]# cat test.sh\n[ $# -ne 2 ] && echo \"请输入两个参数\" && exit 1002\nname=$1\nage=$2\necho $name $age\n\n[root@aliyun shell]# sh test.sh xiajian 22 dd\n请输入两个参数\n[root@aliyun shell]# sh test.sh xiajian\n请输入两个参数\n[root@aliyun shell]# sh test.sh xiajian 22\nxiajian 22\n[root@aliyun shell]#\n\n```\n\n## 3). $# 获取脚本传参的个数\n\n```shell\n[root@aliyun shell]# cat test.sh\necho $#\n[root@aliyun shell]# sh test.sh n1 n2 n3 n4\n4\n[root@aliyun shell]#\n\n```\n\n## 4). $? 获取上一条命令返回结果 0 为成功 非0失败\n\n```shell\n[root@aliyun shell]# ll\ntotal 8\n-rw-r--r-- 1 root root 54 Jan  9 16:09 killshell.sh\n-rw-r--r-- 1 root root  8 Jan  9 16:46 test.sh\n[root@aliyun shell]# echo $?\n0\n[root@aliyun shell]# lsl\nbash: lsl: command not found...\n[root@aliyun shell]# echo $?\n127\n[root@aliyun shell]#\n```\n\n## 5). $! 获取上一个在后台运行脚本的PID\n\n```shell\n[root@aliyun shell]# tail -f killshell.sh &\n[1] 5268\n[root@aliyun shell]# sh test.sh &\npid=$!\necho $pid\nsleep 5\nkill -9 $pid\n\n[root@aliyun shell]# echo $!\n5268\n[root@aliyun shell]#\n```\n\n\n\n## 6). $$ shell本身的pid\n\n```shell\n[root@aliyun shell]# echo $$\n14975\n[root@aliyun shell]#\n```\n\n## 7). $@ 获取所有参数列表\n\n```shell\n[root@aliyun shell]# cat test.sh\necho $@\n[root@aliyun shell]# sh test.sh {a..z}\na b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n## 8)$* 获取所有参数列表\n\n```shell\n[root@aliyun shell]# cat test.sh\necho $*\n[root@aliyun shell]# sh test.sh {a..z}\na b c d e f g h i j k l m n o p q r s t u v w x y z\n\n# $*不加引号和$@一样,在循环里加引号时，“$@”会把引起来的内容作为一个变量\n[root@aliyun shell]# set -- \"I am\" xiajian student\n[root@aliyun shell]# echo $*\nI am xiajian student\n[root@aliyun shell]# echo $@\nI am xiajian student\n[root@aliyun shell]# for i in $*;do echo $i;done\nI\nam\nxiajian\nstudent\n[root@aliyun shell]# for i in $@;do echo $i;done\nI\nam\nxiajian\nstudent\n[root@aliyun shell]# for i in \"$@\";do echo $i;done\nI am\nxiajian\nstudent\n[root@aliyun shell]# for i in \"$*\";do echo $i;done\nI am xiajian student\n```\n\n","source":"_posts/Shell/【01】Shell特殊位置变量.md","raw":"---\ntitle: 【01】Shell特殊位置变量\nabbrlink: 3bd3916a\ndate: 2022-01-09 15:32:32\ntags:\n  - Shell脚本\ncategories:\n  - Shell脚本\n---\n\n> Linux命令Demo  <!-- more --> \n\n## 1). $0 获取脚本名称\n\n```shell\n[root@aliyun shell]# cat test.sh\necho $0\n\n[root@aliyun shell]# sh test.sh\ntest.sh\n[root@aliyun shell]#\n[root@aliyun shell]# sh /root/shell/test.sh\n/root/shell/test.sh\n\n# 如果只想获取脚本名称 basename\n[root@aliyun shell]# basename test.sh\ntest.sh\n[root@aliyun shell]# basename /root/shell/test.sh\ntest.sh\n[root@aliyun shell]#\n\n```\n\n\n\n## 2). $n表示脚本的第n个参数\n\n```shell\n# 实例1\n[root@aliyun shell]# cat test.sh\necho \"超过9个变量不加引号\"\necho $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11\n\necho \"超过9个变量需要加花括号\"\necho $1 $2 $3 $4 $5 $6 $7 $8 $9 ${10} ${11}\n\n[root@aliyun shell]#\n[root@aliyun shell]# sh test.sh {a..z}\n超过9个变量不加引号\na b c d e f g h i a0 a1\n超过9个变量需要加花括号\na b c d e f g h i j k\n[root@aliyun shell]#\n[root@aliyun shell]# sh test.sh {1..20}\n超过9个变量不加引号\n1 2 3 4 5 6 7 8 9 10 11\n超过9个变量需要加花括号\n1 2 3 4 5 6 7 8 9 10 11\n\n# 实例2\n[root@aliyun shell]# cat test.sh\n[ $# -ne 2 ] && echo \"请输入两个参数\" && exit 1002\nname=$1\nage=$2\necho $name $age\n\n[root@aliyun shell]# sh test.sh xiajian 22 dd\n请输入两个参数\n[root@aliyun shell]# sh test.sh xiajian\n请输入两个参数\n[root@aliyun shell]# sh test.sh xiajian 22\nxiajian 22\n[root@aliyun shell]#\n\n```\n\n## 3). $# 获取脚本传参的个数\n\n```shell\n[root@aliyun shell]# cat test.sh\necho $#\n[root@aliyun shell]# sh test.sh n1 n2 n3 n4\n4\n[root@aliyun shell]#\n\n```\n\n## 4). $? 获取上一条命令返回结果 0 为成功 非0失败\n\n```shell\n[root@aliyun shell]# ll\ntotal 8\n-rw-r--r-- 1 root root 54 Jan  9 16:09 killshell.sh\n-rw-r--r-- 1 root root  8 Jan  9 16:46 test.sh\n[root@aliyun shell]# echo $?\n0\n[root@aliyun shell]# lsl\nbash: lsl: command not found...\n[root@aliyun shell]# echo $?\n127\n[root@aliyun shell]#\n```\n\n## 5). $! 获取上一个在后台运行脚本的PID\n\n```shell\n[root@aliyun shell]# tail -f killshell.sh &\n[1] 5268\n[root@aliyun shell]# sh test.sh &\npid=$!\necho $pid\nsleep 5\nkill -9 $pid\n\n[root@aliyun shell]# echo $!\n5268\n[root@aliyun shell]#\n```\n\n\n\n## 6). $$ shell本身的pid\n\n```shell\n[root@aliyun shell]# echo $$\n14975\n[root@aliyun shell]#\n```\n\n## 7). $@ 获取所有参数列表\n\n```shell\n[root@aliyun shell]# cat test.sh\necho $@\n[root@aliyun shell]# sh test.sh {a..z}\na b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n## 8)$* 获取所有参数列表\n\n```shell\n[root@aliyun shell]# cat test.sh\necho $*\n[root@aliyun shell]# sh test.sh {a..z}\na b c d e f g h i j k l m n o p q r s t u v w x y z\n\n# $*不加引号和$@一样,在循环里加引号时，“$@”会把引起来的内容作为一个变量\n[root@aliyun shell]# set -- \"I am\" xiajian student\n[root@aliyun shell]# echo $*\nI am xiajian student\n[root@aliyun shell]# echo $@\nI am xiajian student\n[root@aliyun shell]# for i in $*;do echo $i;done\nI\nam\nxiajian\nstudent\n[root@aliyun shell]# for i in $@;do echo $i;done\nI\nam\nxiajian\nstudent\n[root@aliyun shell]# for i in \"$@\";do echo $i;done\nI am\nxiajian\nstudent\n[root@aliyun shell]# for i in \"$*\";do echo $i;done\nI am xiajian student\n```\n\n","slug":"Shell/【01】Shell特殊位置变量","published":1,"updated":"2022-01-09T07:32:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl2y4l3xu003xn4epg19cdvtj","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><blockquote>\n<p>Linux命令Demo  <a id=\"more\"></a> </p>\n</blockquote>\n<h2 id=\"1-0-获取脚本名称\"><a href=\"#1-0-获取脚本名称\" class=\"headerlink\" title=\"1). $0 获取脚本名称\"></a>1). $0 获取脚本名称</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">echo $0</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun shell]# sh test.sh</span><br><span class=\"line\">test.sh</span><br><span class=\"line\">[root@aliyun shell]#</span><br><span class=\"line\">[root@aliyun shell]# sh /root/shell/test.sh</span><br><span class=\"line\">/root/shell/test.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果只想获取脚本名称 basename</span></span><br><span class=\"line\">[root@aliyun shell]# basename test.sh</span><br><span class=\"line\">test.sh</span><br><span class=\"line\">[root@aliyun shell]# basename /root/shell/test.sh</span><br><span class=\"line\">test.sh</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-n表示脚本的第n个参数\"><a href=\"#2-n表示脚本的第n个参数\" class=\"headerlink\" title=\"2). $n表示脚本的第n个参数\"></a>2). $n表示脚本的第n个参数</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 实例1</span></span><br><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">echo \"超过9个变量不加引号\"</span><br><span class=\"line\">echo $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"超过9个变量需要加花括号\"</span><br><span class=\"line\">echo $1 $2 $3 $4 $5 $6 $7 $8 $9 $&#123;10&#125; $&#123;11&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun shell]#</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh &#123;a..z&#125;</span><br><span class=\"line\">超过9个变量不加引号</span><br><span class=\"line\">a b c d e f g h i a0 a1</span><br><span class=\"line\">超过9个变量需要加花括号</span><br><span class=\"line\">a b c d e f g h i j k</span><br><span class=\"line\">[root@aliyun shell]#</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh &#123;1..20&#125;</span><br><span class=\"line\">超过9个变量不加引号</span><br><span class=\"line\">1 2 3 4 5 6 7 8 9 10 11</span><br><span class=\"line\">超过9个变量需要加花括号</span><br><span class=\"line\">1 2 3 4 5 6 7 8 9 10 11</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 实例2</span></span><br><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">[ $# -ne 2 ] &amp;&amp; echo \"请输入两个参数\" &amp;&amp; exit 1002</span><br><span class=\"line\">name=$1</span><br><span class=\"line\">age=$2</span><br><span class=\"line\">echo $name $age</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun shell]# sh test.sh xiajian 22 dd</span><br><span class=\"line\">请输入两个参数</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh xiajian</span><br><span class=\"line\">请输入两个参数</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh xiajian 22</span><br><span class=\"line\">xiajian 22</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-获取脚本传参的个数\"><a href=\"#3-获取脚本传参的个数\" class=\"headerlink\" title=\"3). $# 获取脚本传参的个数\"></a>3). $# 获取脚本传参的个数</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">echo $#</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh n1 n2 n3 n4</span><br><span class=\"line\">4</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-获取上一条命令返回结果-0-为成功-非0失败\"><a href=\"#4-获取上一条命令返回结果-0-为成功-非0失败\" class=\"headerlink\" title=\"4). $? 获取上一条命令返回结果 0 为成功 非0失败\"></a>4). $? 获取上一条命令返回结果 0 为成功 非0失败</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# ll</span><br><span class=\"line\">total 8</span><br><span class=\"line\">-rw-r--r-- 1 root root 54 Jan  9 16:09 killshell.sh</span><br><span class=\"line\">-rw-r--r-- 1 root root  8 Jan  9 16:46 test.sh</span><br><span class=\"line\">[root@aliyun shell]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\">[root@aliyun shell]# lsl</span><br><span class=\"line\">bash: lsl: command not found...</span><br><span class=\"line\">[root@aliyun shell]# echo $?</span><br><span class=\"line\">127</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-获取上一个在后台运行脚本的PID\"><a href=\"#5-获取上一个在后台运行脚本的PID\" class=\"headerlink\" title=\"5). $! 获取上一个在后台运行脚本的PID\"></a>5). $! 获取上一个在后台运行脚本的PID</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# tail -f killshell.sh &amp;</span><br><span class=\"line\">[1] 5268</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh &amp;</span><br><span class=\"line\">pid=$!</span><br><span class=\"line\">echo $pid</span><br><span class=\"line\">sleep 5</span><br><span class=\"line\">kill -9 $pid</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun shell]# echo $!</span><br><span class=\"line\">5268</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-shell本身的pid\"><a href=\"#6-shell本身的pid\" class=\"headerlink\" title=\"6). $$ shell本身的pid\"></a>6). $$ shell本身的pid</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# echo $$</span><br><span class=\"line\">14975</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-获取所有参数列表\"><a href=\"#7-获取所有参数列表\" class=\"headerlink\" title=\"7). $@ 获取所有参数列表\"></a>7). $@ 获取所有参数列表</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">echo $@</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh &#123;a..z&#125;</span><br><span class=\"line\">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-获取所有参数列表\"><a href=\"#8-获取所有参数列表\" class=\"headerlink\" title=\"8)$* 获取所有参数列表\"></a>8)$* 获取所有参数列表</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">echo $*</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh &#123;a..z&#125;</span><br><span class=\"line\">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> $*不加引号和<span class=\"variable\">$@</span>一样,在循环里加引号时，“<span class=\"variable\">$@</span>”会把引起来的内容作为一个变量</span></span><br><span class=\"line\">[root@aliyun shell]# set -- \"I am\" xiajian student</span><br><span class=\"line\">[root@aliyun shell]# echo $*</span><br><span class=\"line\">I am xiajian student</span><br><span class=\"line\">[root@aliyun shell]# echo $@</span><br><span class=\"line\">I am xiajian student</span><br><span class=\"line\">[root@aliyun shell]# for i in $*;do echo $i;done</span><br><span class=\"line\">I</span><br><span class=\"line\">am</span><br><span class=\"line\">xiajian</span><br><span class=\"line\">student</span><br><span class=\"line\">[root@aliyun shell]# for i in $@;do echo $i;done</span><br><span class=\"line\">I</span><br><span class=\"line\">am</span><br><span class=\"line\">xiajian</span><br><span class=\"line\">student</span><br><span class=\"line\">[root@aliyun shell]# for i in \"$@\";do echo $i;done</span><br><span class=\"line\">I am</span><br><span class=\"line\">xiajian</span><br><span class=\"line\">student</span><br><span class=\"line\">[root@aliyun shell]# for i in \"$*\";do echo $i;done</span><br><span class=\"line\">I am xiajian student</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Linux命令Demo","more":"</p>\n</blockquote>\n<h2 id=\"1-0-获取脚本名称\"><a href=\"#1-0-获取脚本名称\" class=\"headerlink\" title=\"1). $0 获取脚本名称\"></a>1). $0 获取脚本名称</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">echo $0</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun shell]# sh test.sh</span><br><span class=\"line\">test.sh</span><br><span class=\"line\">[root@aliyun shell]#</span><br><span class=\"line\">[root@aliyun shell]# sh /root/shell/test.sh</span><br><span class=\"line\">/root/shell/test.sh</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 如果只想获取脚本名称 basename</span></span><br><span class=\"line\">[root@aliyun shell]# basename test.sh</span><br><span class=\"line\">test.sh</span><br><span class=\"line\">[root@aliyun shell]# basename /root/shell/test.sh</span><br><span class=\"line\">test.sh</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"2-n表示脚本的第n个参数\"><a href=\"#2-n表示脚本的第n个参数\" class=\"headerlink\" title=\"2). $n表示脚本的第n个参数\"></a>2). $n表示脚本的第n个参数</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 实例1</span></span><br><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">echo \"超过9个变量不加引号\"</span><br><span class=\"line\">echo $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11</span><br><span class=\"line\"></span><br><span class=\"line\">echo \"超过9个变量需要加花括号\"</span><br><span class=\"line\">echo $1 $2 $3 $4 $5 $6 $7 $8 $9 $&#123;10&#125; $&#123;11&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun shell]#</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh &#123;a..z&#125;</span><br><span class=\"line\">超过9个变量不加引号</span><br><span class=\"line\">a b c d e f g h i a0 a1</span><br><span class=\"line\">超过9个变量需要加花括号</span><br><span class=\"line\">a b c d e f g h i j k</span><br><span class=\"line\">[root@aliyun shell]#</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh &#123;1..20&#125;</span><br><span class=\"line\">超过9个变量不加引号</span><br><span class=\"line\">1 2 3 4 5 6 7 8 9 10 11</span><br><span class=\"line\">超过9个变量需要加花括号</span><br><span class=\"line\">1 2 3 4 5 6 7 8 9 10 11</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 实例2</span></span><br><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">[ $# -ne 2 ] &amp;&amp; echo \"请输入两个参数\" &amp;&amp; exit 1002</span><br><span class=\"line\">name=$1</span><br><span class=\"line\">age=$2</span><br><span class=\"line\">echo $name $age</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun shell]# sh test.sh xiajian 22 dd</span><br><span class=\"line\">请输入两个参数</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh xiajian</span><br><span class=\"line\">请输入两个参数</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh xiajian 22</span><br><span class=\"line\">xiajian 22</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-获取脚本传参的个数\"><a href=\"#3-获取脚本传参的个数\" class=\"headerlink\" title=\"3). $# 获取脚本传参的个数\"></a>3). $# 获取脚本传参的个数</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">echo $#</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh n1 n2 n3 n4</span><br><span class=\"line\">4</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-获取上一条命令返回结果-0-为成功-非0失败\"><a href=\"#4-获取上一条命令返回结果-0-为成功-非0失败\" class=\"headerlink\" title=\"4). $? 获取上一条命令返回结果 0 为成功 非0失败\"></a>4). $? 获取上一条命令返回结果 0 为成功 非0失败</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# ll</span><br><span class=\"line\">total 8</span><br><span class=\"line\">-rw-r--r-- 1 root root 54 Jan  9 16:09 killshell.sh</span><br><span class=\"line\">-rw-r--r-- 1 root root  8 Jan  9 16:46 test.sh</span><br><span class=\"line\">[root@aliyun shell]# echo $?</span><br><span class=\"line\">0</span><br><span class=\"line\">[root@aliyun shell]# lsl</span><br><span class=\"line\">bash: lsl: command not found...</span><br><span class=\"line\">[root@aliyun shell]# echo $?</span><br><span class=\"line\">127</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-获取上一个在后台运行脚本的PID\"><a href=\"#5-获取上一个在后台运行脚本的PID\" class=\"headerlink\" title=\"5). $! 获取上一个在后台运行脚本的PID\"></a>5). $! 获取上一个在后台运行脚本的PID</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# tail -f killshell.sh &amp;</span><br><span class=\"line\">[1] 5268</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh &amp;</span><br><span class=\"line\">pid=$!</span><br><span class=\"line\">echo $pid</span><br><span class=\"line\">sleep 5</span><br><span class=\"line\">kill -9 $pid</span><br><span class=\"line\"></span><br><span class=\"line\">[root@aliyun shell]# echo $!</span><br><span class=\"line\">5268</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-shell本身的pid\"><a href=\"#6-shell本身的pid\" class=\"headerlink\" title=\"6). $$ shell本身的pid\"></a>6). $$ shell本身的pid</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# echo $$</span><br><span class=\"line\">14975</span><br><span class=\"line\">[root@aliyun shell]#</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-获取所有参数列表\"><a href=\"#7-获取所有参数列表\" class=\"headerlink\" title=\"7). $@ 获取所有参数列表\"></a>7). $@ 获取所有参数列表</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">echo $@</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh &#123;a..z&#125;</span><br><span class=\"line\">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-获取所有参数列表\"><a href=\"#8-获取所有参数列表\" class=\"headerlink\" title=\"8)$* 获取所有参数列表\"></a>8)$* 获取所有参数列表</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@aliyun shell]# cat test.sh</span><br><span class=\"line\">echo $*</span><br><span class=\"line\">[root@aliyun shell]# sh test.sh &#123;a..z&#125;</span><br><span class=\"line\">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> $*不加引号和<span class=\"variable\">$@</span>一样,在循环里加引号时，“<span class=\"variable\">$@</span>”会把引起来的内容作为一个变量</span></span><br><span class=\"line\">[root@aliyun shell]# set -- \"I am\" xiajian student</span><br><span class=\"line\">[root@aliyun shell]# echo $*</span><br><span class=\"line\">I am xiajian student</span><br><span class=\"line\">[root@aliyun shell]# echo $@</span><br><span class=\"line\">I am xiajian student</span><br><span class=\"line\">[root@aliyun shell]# for i in $*;do echo $i;done</span><br><span class=\"line\">I</span><br><span class=\"line\">am</span><br><span class=\"line\">xiajian</span><br><span class=\"line\">student</span><br><span class=\"line\">[root@aliyun shell]# for i in $@;do echo $i;done</span><br><span class=\"line\">I</span><br><span class=\"line\">am</span><br><span class=\"line\">xiajian</span><br><span class=\"line\">student</span><br><span class=\"line\">[root@aliyun shell]# for i in \"$@\";do echo $i;done</span><br><span class=\"line\">I am</span><br><span class=\"line\">xiajian</span><br><span class=\"line\">student</span><br><span class=\"line\">[root@aliyun shell]# for i in \"$*\";do echo $i;done</span><br><span class=\"line\">I am xiajian student</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl2y4l3ux0001n4epc75u32wa","category_id":"cl2y4l3v10004n4ep182sgcnb","_id":"cl2y4l3v40007n4ep81qw58sg"},{"post_id":"cl2y4l3wu0015n4ep95o6e5c6","category_id":"cl2y4l3wv0018n4ep8yq8674x","_id":"cl2y4l3x2001in4ep4smm43na"},{"post_id":"cl2y4l3wv0016n4epb83i8x4k","category_id":"cl2y4l3x0001dn4ep2wgv8njp","_id":"cl2y4l3x5001on4epgiso0v19"},{"post_id":"cl2y4l3ww001an4ep0mxz4xdw","category_id":"cl2y4l3x2001jn4ep083zh10n","_id":"cl2y4l3x8001vn4ep3remg3nu"},{"post_id":"cl2y4l3wx001bn4epel0odarj","category_id":"cl2y4l3x2001jn4ep083zh10n","_id":"cl2y4l3x90020n4ep2fex6n3g"},{"post_id":"cl2y4l3wy001cn4epgaibeshz","category_id":"cl2y4l3x7001un4ep8cypdwjr","_id":"cl2y4l3xc0026n4ep1u062moj"},{"post_id":"cl2y4l3xb0025n4ep5pksh3ig","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xe002en4ep5gtx8pbo"},{"post_id":"cl2y4l3x2001hn4epgqteczxf","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xf002jn4ep3ou7cam4"},{"post_id":"cl2y4l3xc0027n4ep7737e8p9","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xg002mn4ep30qk898t"},{"post_id":"cl2y4l3xd002bn4epg0hw1kpv","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xi002rn4epabhp3nja"},{"post_id":"cl2y4l3x3001ln4ep1y7ldn4i","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xj002un4ep4hqjad9v"},{"post_id":"cl2y4l3xe002dn4epbzk8aqdv","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xk002zn4ep2v0kbnk0"},{"post_id":"cl2y4l3xf002in4ep25c65i4y","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xl0032n4ep6sa98f7f"},{"post_id":"cl2y4l3x4001nn4ep6anja4bh","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xn0037n4ep9miic91b"},{"post_id":"cl2y4l3xg002ln4ep34v06v04","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xn003an4epcz72df9m"},{"post_id":"cl2y4l3xh002qn4epez0o2kdn","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xp003fn4epcso19ku0"},{"post_id":"cl2y4l3x6001rn4epdd7r5q6k","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xq003in4epgqcr157k"},{"post_id":"cl2y4l3xi002tn4ep3mutave4","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xr003nn4ep4h3c4lft"},{"post_id":"cl2y4l3xk002yn4ep1mzgedch","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xs003qn4ep1c9l4ump"},{"post_id":"cl2y4l3x7001tn4ep2g2l6cym","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xt003vn4eph2zu9b30"},{"post_id":"cl2y4l3xl0031n4ep89oo5bkc","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xu003yn4ep3d087z9v"},{"post_id":"cl2y4l3xm0036n4epcgqpf40h","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xv0042n4epb65i6ewg"},{"post_id":"cl2y4l3x8001xn4epfcbh65zo","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xv0044n4ep256f2nzt"},{"post_id":"cl2y4l3xn0039n4epa5jig2od","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xw0048n4ep9u0v6kb5"},{"post_id":"cl2y4l3xp003en4epds537rqg","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xw004an4ep3ofj3716"},{"post_id":"cl2y4l3x9001zn4epg0ex94sc","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xx004en4ep998t9h9a"},{"post_id":"cl2y4l3xa0023n4ep2he3auta","category_id":"cl2y4l3xa0021n4ep4joz2ips","_id":"cl2y4l3xx004gn4epgo4fbi9n"},{"post_id":"cl2y4l3xp003hn4ep5qqrgxnx","category_id":"cl2y4l3xs003rn4ephck22ud5","_id":"cl2y4l3xx004in4epeb8cev1v"},{"post_id":"cl2y4l3xr003mn4ep8g8n6dzl","category_id":"cl2y4l3xs003rn4ephck22ud5","_id":"cl2y4l3xx004kn4epddxz6zxi"},{"post_id":"cl2y4l3xr003pn4ep1wm7944d","category_id":"cl2y4l3xv0045n4epcw9oft97","_id":"cl2y4l3xx004mn4epd0w8a7hm"},{"post_id":"cl2y4l3xu003xn4epg19cdvtj","category_id":"cl2y4l3xw004bn4ep4xk7f9ff","_id":"cl2y4l3xx004nn4epg8ed2ahg"}],"PostTag":[{"post_id":"cl2y4l3ux0001n4epc75u32wa","tag_id":"cl2y4l3v30005n4epaslpap4h","_id":"cl2y4l3v40006n4eph17o5deo"},{"post_id":"cl2y4l3we000cn4epgilz0rg2","tag_id":"cl2y4l3wd000an4epdjycc2iz","_id":"cl2y4l3wh000fn4epdajpanft"},{"post_id":"cl2y4l3wb0008n4ep29m97tsw","tag_id":"cl2y4l3wd000an4epdjycc2iz","_id":"cl2y4l3wi000hn4ep9tmweanp"},{"post_id":"cl2y4l3wf000dn4ep9xyu46jg","tag_id":"cl2y4l3wd000an4epdjycc2iz","_id":"cl2y4l3wj000kn4epg5bc8eox"},{"post_id":"cl2y4l3wh000gn4epgrhugx23","tag_id":"cl2y4l3wd000an4epdjycc2iz","_id":"cl2y4l3wk000mn4ephfvo35k8"},{"post_id":"cl2y4l3wc0009n4epca48g78a","tag_id":"cl2y4l3wd000an4epdjycc2iz","_id":"cl2y4l3wl000on4ep4ory6z3h"},{"post_id":"cl2y4l3wi000in4ep38vpeuw1","tag_id":"cl2y4l3wd000an4epdjycc2iz","_id":"cl2y4l3wm000qn4ep5xv65b7v"},{"post_id":"cl2y4l3wd000bn4ephlmifu4s","tag_id":"cl2y4l3wd000an4epdjycc2iz","_id":"cl2y4l3wn000sn4epgiao3uot"},{"post_id":"cl2y4l3wk000nn4ep1c7u2vbo","tag_id":"cl2y4l3wd000an4epdjycc2iz","_id":"cl2y4l3wo000un4ep41khfvlf"},{"post_id":"cl2y4l3wr000zn4epa8i9dgms","tag_id":"cl2y4l3wd000an4epdjycc2iz","_id":"cl2y4l3wt0012n4epgqv21zpx"},{"post_id":"cl2y4l3wo000vn4epa5d33ejx","tag_id":"cl2y4l3wq000xn4ep5cdq5g9s","_id":"cl2y4l3wu0014n4ephktp37hm"},{"post_id":"cl2y4l3wp000wn4ep4p30grm9","tag_id":"cl2y4l3ws0011n4ep88gzgi8c","_id":"cl2y4l3wv0017n4ep0nrubo10"},{"post_id":"cl2y4l3wu0015n4ep95o6e5c6","tag_id":"cl2y4l3ww0019n4ep99cjdxau","_id":"cl2y4l3x1001fn4epgqr302rr"},{"post_id":"cl2y4l3wv0016n4epb83i8x4k","tag_id":"cl2y4l3x0001en4epdduictfo","_id":"cl2y4l3x4001mn4epgron8mdu"},{"post_id":"cl2y4l3ww001an4ep0mxz4xdw","tag_id":"cl2y4l3x3001kn4ep3rp50vq3","_id":"cl2y4l3x6001sn4ep6gnuaypb"},{"post_id":"cl2y4l3wx001bn4epel0odarj","tag_id":"cl2y4l3x3001kn4ep3rp50vq3","_id":"cl2y4l3x9001yn4ep14z86ng6"},{"post_id":"cl2y4l3wy001cn4epgaibeshz","tag_id":"cl2y4l3x8001wn4epeababbix","_id":"cl2y4l3xb0024n4epa8c811wr"},{"post_id":"cl2y4l3xb0025n4ep5pksh3ig","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xd002an4ep518179ct"},{"post_id":"cl2y4l3x2001hn4epgqteczxf","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xe002cn4epamzt7i11"},{"post_id":"cl2y4l3xc0027n4ep7737e8p9","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xf002hn4ep5cmq531v"},{"post_id":"cl2y4l3xd002bn4epg0hw1kpv","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xg002kn4ep2na75mjh"},{"post_id":"cl2y4l3x3001ln4ep1y7ldn4i","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xh002pn4epeo9k16jr"},{"post_id":"cl2y4l3xe002dn4epbzk8aqdv","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xi002sn4ep2y52e1hj"},{"post_id":"cl2y4l3xf002in4ep25c65i4y","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xk002xn4epeh199a2y"},{"post_id":"cl2y4l3x4001nn4ep6anja4bh","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xl0030n4ep2j94gz5k"},{"post_id":"cl2y4l3xg002ln4ep34v06v04","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xm0035n4epb585h3dw"},{"post_id":"cl2y4l3xh002qn4epez0o2kdn","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xn0038n4ep0hv0emhi"},{"post_id":"cl2y4l3x6001rn4epdd7r5q6k","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xo003dn4ep77oe3au1"},{"post_id":"cl2y4l3xi002tn4ep3mutave4","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xp003gn4ephww2bmqh"},{"post_id":"cl2y4l3xk002yn4ep1mzgedch","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xr003ln4epg32adxez"},{"post_id":"cl2y4l3x7001tn4ep2g2l6cym","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xr003on4ep1gicd8pb"},{"post_id":"cl2y4l3xl0031n4ep89oo5bkc","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xs003tn4epdtisgb3u"},{"post_id":"cl2y4l3xm0036n4epcgqpf40h","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xu003wn4ep352vdv7f"},{"post_id":"cl2y4l3x8001xn4epfcbh65zo","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xv0041n4ep433ibdd7"},{"post_id":"cl2y4l3xn0039n4epa5jig2od","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xv0043n4ep6m6mgtuz"},{"post_id":"cl2y4l3xp003en4epds537rqg","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xw0047n4ep5f29esbl"},{"post_id":"cl2y4l3x9001zn4epg0ex94sc","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xw0049n4ep26qo7q2n"},{"post_id":"cl2y4l3xa0023n4ep2he3auta","tag_id":"cl2y4l3xa0022n4epb8vnddf5","_id":"cl2y4l3xx004dn4epgsho84my"},{"post_id":"cl2y4l3xp003hn4ep5qqrgxnx","tag_id":"cl2y4l3xs003sn4ep75o1f51y","_id":"cl2y4l3xx004fn4ep883u6k5f"},{"post_id":"cl2y4l3xr003mn4ep8g8n6dzl","tag_id":"cl2y4l3xs003sn4ep75o1f51y","_id":"cl2y4l3xx004hn4epfake7e16"},{"post_id":"cl2y4l3xr003pn4ep1wm7944d","tag_id":"cl2y4l3xw0046n4ephr52bm38","_id":"cl2y4l3xx004jn4epfqds235m"},{"post_id":"cl2y4l3xu003xn4epg19cdvtj","tag_id":"cl2y4l3xw004cn4ep8ar3c642","_id":"cl2y4l3xx004ln4epbo65de6b"}],"Tag":[{"name":"API","_id":"cl2y4l3v30005n4epaslpap4h"},{"name":"博客","_id":"cl2y4l3wd000an4epdjycc2iz"},{"name":"MQ","_id":"cl2y4l3wq000xn4ep5cdq5g9s"},{"name":"自动化测试","_id":"cl2y4l3ws0011n4ep88gzgi8c"},{"name":"Appium","_id":"cl2y4l3ww0019n4ep99cjdxau"},{"name":"Charles","_id":"cl2y4l3x0001en4epdduictfo"},{"name":"Hexo","_id":"cl2y4l3x3001kn4ep3rp50vq3"},{"name":"MySQL","_id":"cl2y4l3x8001wn4epeababbix"},{"name":"postman","_id":"cl2y4l3xa0022n4epb8vnddf5"},{"name":"Python接口自动化测试","_id":"cl2y4l3xs003sn4ep75o1f51y"},{"name":"Python自动化","_id":"cl2y4l3xw0046n4ephr52bm38"},{"name":"Shell脚本","_id":"cl2y4l3xw004cn4ep8ar3c642"}]}}