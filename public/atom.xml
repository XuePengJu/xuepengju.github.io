<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏见°の博客</title>
  
  <subtitle>欢迎加入</subtitle>
  <link href="http://mypeng.site/atom.xml" rel="self"/>
  
  <link href="http://mypeng.site/"/>
  <updated>2022-01-23T13:13:56.000Z</updated>
  <id>http://mypeng.site/</id>
  
  <author>
    <name>夏见°</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>〖接口测试〗postman做接口测试10-全局变量/集合变量/环境变量</title>
    <link href="http://mypeng.site/posts/c98d9940/"/>
    <id>http://mypeng.site/posts/c98d9940/</id>
    <published>2022-01-23T13:13:56.000Z</published>
    <updated>2022-01-23T13:13:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。</p></blockquote><p>对我们做接口测试来说，又是一个非常重要的功能 。</p><h2 id="在postman常用的三种变量分别是全局变量，环境变量，集合变量-。"><a href="#在postman常用的三种变量分别是全局变量，环境变量，集合变量-。" class="headerlink" title="在postman常用的三种变量分别是全局变量，环境变量，集合变量 。"></a>在postman常用的三种变量分别是全局变量，环境变量，集合变量 。</h2><blockquote><p>全局变量：一旦申明了全局变量，全局有效，也就是说postman中的任何集合，任何请求中都可以使用这个变量。它的作用域是最大的 。</p></blockquote><blockquote><p>环境变量：要申明环境变量，首先的创建环境，然后在环境中才能创建变量 。如果要想使用环境变量，必须先选择(导入)这个环境，这样就可以使用这个环境下的变量了 。需要说明的是环境也可以创建多个 。每个环境下又可以有多个变量 。</p></blockquote><blockquote><p>集合变量：集合变量是针对集合的，也就是说申明的变量必须基于某个集合，它的使用范围也只是针对这个集合有效 。</p></blockquote><p>其中，他们的作用域范围依次从大到小：全局变量&gt;集合变量&gt;环境变量 。 当在几个不同的范围内都申明了相同的变量时，则会优先使用范围最小的变量使。</p><h2 id="想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量-。"><a href="#想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量-。" class="headerlink" title="想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。"></a>想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。</h2><pre><code>1.定义变量（设置变量）2.获取变量（访问变量）</code></pre><h3 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="1. 定义变量"></a>1. 定义变量</h3><p>定义全局变量和环境变量，点击右上角的小齿轮，弹出如下界面，就可以根据需求定义全局变量或者环境变量了。</p><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/010-01.png" alt="img"> </p><p>已经定义的全局变量和环境变量，可以进行快速查看</p><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/010-02.png" alt="img"> </p><h3 id="2-定义集合变量"><a href="#2-定义集合变量" class="headerlink" title="2.定义集合变量"></a>2.定义集合变量</h3><h4 id="2-1-选择一个集合，打开查看更多动作-…-菜单，然后点击编辑-。选择“变量”选项卡以编辑或添加到集合变量。"><a href="#2-1-选择一个集合，打开查看更多动作-…-菜单，然后点击编辑-。选择“变量”选项卡以编辑或添加到集合变量。" class="headerlink" title="2.1 选择一个集合，打开查看更多动作(…)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。"></a>2.1 选择一个集合，打开查看更多动作(…)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。</h4><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/010-03.png" alt="img"> </p><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/010-04.png" alt="img"> </p><h4 id="2-2-定义变量除了以上方式，还有另外一种方式-。但是这种方式在不同的位置定义，编写不一样。"><a href="#2-2-定义变量除了以上方式，还有另外一种方式-。但是这种方式在不同的位置定义，编写不一样。" class="headerlink" title="2.2 定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。"></a>2.2 定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。</h4><p>在URL，Params , Authorization , Headers , Body中定义：</p><p>手工方式创建一个空的变量名</p><p>在以上的位置把想要的值选中右击，选中Set：环境|全局 ，选中一个变量名，点击后就会保存到这个变量中</p><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/010-05.png" alt="img"> </p><p>在Tests，Pre-requests Script：</p><p>定义全局变量：pm.collectionVariables.set(“变量名”,变量值)</p><p>定义环境变量：pm.environment.set(“变量名”，变量值)</p><p>定义集合变量：pm.variables.set(“变量名”,变量值)</p><h3 id="3-获取变量"><a href="#3-获取变量" class="headerlink" title="3.获取变量"></a>3.获取变量</h3><p>定义好变量，接下来就可以使用变量了 。需要注意的是，在不同的位置获取变量，编写的规则也是不一样的 。</p><p>如果在请求参数中获取变量，无论是获取全局变量，还是环境变量，还是集合变量，获取的方式都是一样的编写规则：{undefined{变量名}} 。</p><p>请求参数指的是：URL，Params , Authorization , Headers , Body</p><p>如果是在编写代码的位置(Tests,Pre-requests Script)获取变量，获取不同类型的变量，编写的代码都不相同，具体如下：</p><p>获取环境变量：pm.environment.get(‘变量名’)</p><p>获取全局变量：pm.globals.get(‘变量名’)</p><p>获取集合变量：pm.pm.collectionVariables.get.get(‘变量名’)</p><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/010-06.png" alt="img"> </p><p>变量的使用场景非常广泛，比如我们后面要提到的接口关联，请求前置脚本都会使用到变量 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="postman" scheme="http://mypeng.site/categories/postman/"/>
    
    
    <category term="postman" scheme="http://mypeng.site/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记-Python之生成器和列表推导式的区别</title>
    <link href="http://mypeng.site/posts/30fa304c/"/>
    <id>http://mypeng.site/posts/30fa304c/</id>
    <published>2022-01-17T15:32:48.000Z</published>
    <updated>2022-01-17T15:32:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="生成器表达式和列表推导式的区别"><a href="#生成器表达式和列表推导式的区别" class="headerlink" title="生成器表达式和列表推导式的区别:"></a>生成器表达式和列表推导式的区别:</h2><ul><li>列表推导式比较耗内存. 一次性加载. 生成器表达式几乎不占用内存. 使用的时候才分<br>配和使用内存</li><li>得到的值不一样. 列表推导式得到的是一个列表. 生成器表达式获取的是一个生成器.<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2></li><li>同样一篮子鸡蛋. 列表推导式: 直接拿到一篮子鸡蛋. 生成器表达式: 拿到⼀个老母鸡. 需要<br>鸡蛋就给你下鸡蛋.</li><li>生成器的惰性机制: 生成器只有在访问的时候才取值. 说白了了. 你找他要他才给你值. 不找他<br>要. 他是不会执行的.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python基础篇02-list和tuple常用操作</title>
    <link href="http://mypeng.site/posts/d2331223/"/>
    <id>http://mypeng.site/posts/d2331223/</id>
    <published>2022-01-16T07:48:20.000Z</published>
    <updated>2022-01-16T07:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul><li>列表用[]定义</li><li>如果列表有多个元素,元素和元素用逗号隔开</li><li>用[下标]方式访问列表中具体的元素</li><li>下标从0开始<ul><li>列表中第一个元素下标为0</li></ul></li><li>如果下标超过列表中元素的范围,程序出错</li></ul><h2 id="list常用方法"><a href="#list常用方法" class="headerlink" title="list常用方法"></a>list常用方法</h2><ul><li><p>insert(索引, 值)</p><ul><li>往列表指定的索引位置插入指定的值</li></ul></li><li><p>append(值)</p><ul><li>在列表的最后追加指定的值</li></ul></li><li><p>extend(列表)</p><ul><li>把指定列表追加到后面,相当于两个列表合并</li></ul></li><li><p>列表名[索引] = 值</p><ul><li>修改列表元素的值</li></ul></li></ul><h3 id="代码举例："><a href="#代码举例：" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_add_method</span><span class="params">()</span>:</span></span><br><span class="line">    list_date = []</span><br><span class="line">    <span class="keyword">return</span> list_date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历输出列表所以内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> data:</span><br><span class="line">        print(<span class="string">"list_data第"</span>, data.index(n), end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">"个数据为："</span>, n)</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = list_add_method()</span><br><span class="line">    data.append(<span class="string">"append在末尾添加数据"</span>)</span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    data.insert(<span class="number">0</span>, <span class="string">"insert在指定索引位置增加数据"</span>)</span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    list_extend_date = [<span class="string">"飞花"</span>, <span class="string">"血月"</span>]</span><br><span class="line">    <span class="comment"># extend方法 追加另一个列表的值到这个列表</span></span><br><span class="line">    data.extend(list_extend_date)</span><br><span class="line">    get_all_data(data)</span><br><span class="line">    </span><br><span class="line">    data[<span class="number">1</span>] = <span class="string">"修改index为1的数据为NONE"</span></span><br><span class="line">    get_all_data(data)</span><br></pre></td></tr></table></figure><h2 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h2><ul><li>del(列表名[索引])<ul><li>删除列表指定索引位置的元素</li></ul></li><li>列表名.remove(值)<ul><li>删除列表中指定值</li></ul></li><li>列表名.pop()<ul><li>删除最后一个元素</li></ul></li><li>列表名.pop(索引)<ul><li>删除指定索引位置元素</li><li>类似于del</li></ul></li><li>列表名.clear()<ul><li>删除列表所有元素</li></ul></li></ul><h3 id="代码举例：-1"><a href="#代码举例：-1" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_del_method</span><span class="params">()</span>:</span></span><br><span class="line">    list_date = [<span class="string">"采薇采薇，薇亦作止"</span>, <span class="string">"曰归曰归，岁亦莫止"</span>, <span class="string">"靡室靡家，猃狁之故"</span>, <span class="string">"不遑启居，猃狁之故"</span>]</span><br><span class="line">    <span class="keyword">return</span> list_date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历输出列表所以内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> data:</span><br><span class="line">        print(<span class="string">"list_data第"</span>, data.index(n), end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">"个数据为："</span>, n)</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = list_del_method()</span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> (data[<span class="number">0</span>])  <span class="comment"># 删除指定索引的数据</span></span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    data.pop(<span class="number">1</span>)  <span class="comment"># 删除指定索引数据</span></span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    data.pop()  <span class="comment"># 删除末尾数据</span></span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    data.clear()  <span class="comment"># 清空列表</span></span><br><span class="line">    get_all_data(data)</span><br></pre></td></tr></table></figure><h2 id="统计列表元素"><a href="#统计列表元素" class="headerlink" title="统计列表元素"></a>统计列表元素</h2><ul><li><p>列表名.count(值)</p><ul><li>统计指定值在列表中出现的次数</li></ul></li><li><p>列表名.index(值)</p><ul><li>计算指定值的下标</li><li>如果有多个相同的值,返回第一个值的下标</li><li>如果值不存在,程序出错</li></ul></li></ul><h3 id="代码举例：-2"><a href="#代码举例：-2" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_del_method</span><span class="params">()</span>:</span></span><br><span class="line">    list_date = [<span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="keyword">return</span> list_date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历输出列表所以内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># 列表index函数，获取当前下标的值</span></span><br><span class="line">        print(<span class="string">"list_data第"</span>, data.index(n), end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">"个数据为："</span>, n)</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = list_del_method()</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印6在列表中出现了几次</span></span><br><span class="line">    print(<span class="string">"6在列表中出现了"</span>, data.count(<span class="number">6</span>), <span class="string">"次"</span>)</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h2><ul><li>列表名.sort()<ul><li>升序排序</li></ul></li><li>列表名.sort(reverse=True)<ul><li>降序排序</li></ul></li><li>列表名.reverse()<ul><li>逆置,把列表中所有的元素颠倒过来</li></ul></li></ul><h3 id="代码举例：-3"><a href="#代码举例：-3" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_del_method</span><span class="params">()</span>:</span></span><br><span class="line">    list_date = [<span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="keyword">return</span> list_date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历输出列表所以内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># 列表index函数，获取当前下标的值</span></span><br><span class="line">        print(<span class="string">"list_data第"</span>, data.index(n), end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">"个数据为："</span>, n)</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = list_del_method()</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"升序排序"</span>)</span><br><span class="line">    data.sort()  <span class="comment"># 升序排序</span></span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"降序排序"</span>)</span><br><span class="line">    data.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 降序排序</span></span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"逆置，反转"</span>)</span><br><span class="line">    data.reverse()</span><br><span class="line">    get_all_data(data)</span><br></pre></td></tr></table></figure><h1 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h1><ul><li>拆包就是把列表或者元组或者集合以及字典中的每个元素拆分出来</li><li>变量1, 变量2, 变量n = 列表名<ul><li>等号左边变量的数量要和等号右边列表中元素的数量一致</li></ul></li></ul><h1 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h1><ul><li>可以快速的生成一个比较大的列表</li><li>[x for x in range(10)]<ul><li>从1到9,9个数字</li></ul></li><li>[x for x in range(3, 100)]<ul><li>从3到99</li></ul></li><li>带条件的推导式</li><li>[x for x in range(1, 100) if x % 3 == 0]<ul><li>从1到99所有能被3整除的数字</li></ul></li></ul><h3 id="代码举例：-4"><a href="#代码举例：-4" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 列表推导式 定义一个长列表</span></span><br><span class="line">    <span class="comment"># 从1到99步长为2的所以数字</span></span><br><span class="line">    data = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>)]</span><br><span class="line">    <span class="comment"># 从1到99所以能被3整除的数字</span></span><br><span class="line">    data1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 解包list</span></span><br><span class="line">    print(*data)</span><br><span class="line">    print(*data1)</span><br></pre></td></tr></table></figure><h1 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h1><ul><li>dir查看对象所有的方法<ul><li>dir(变量名)</li></ul></li><li>len返回非数字类型的元素数量<ul><li>包括列表,字符串,元组等</li></ul></li><li>len(变量名)</li><li>max(列表)<ul><li>返回列表中最大的元素</li></ul></li><li>min(列表)<ul><li>返回列表中最小的元素</li></ul></li><li>值 in 列表<ul><li>判断指定的值是否在列表里面,如果在返回True,否则返回False</li><li>可以是列表,也可以是字符串和其他非数字类型</li></ul></li><li>值 not in 列表<ul><li>判断指定的值是否不在列表里面,如果不在,返回True,在返回False</li></ul></li></ul><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><ul><li>元组和列表类似,区别是元组的元素不能修改</li><li>通过()定义元组</li><li>a = ()<ul><li>定义一个空元组</li></ul></li><li>a = (1, )<ul><li>定义一个只有一个元素的元组</li></ul></li><li>a = (1, 2, 3)<ul><li>定义有三个元素的元组</li></ul></li><li>定义元组的时候可以省略()</li><li>a = 1, 2, 3</li></ul><h3 id="代码举例：-5"><a href="#代码举例：-5" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 元祖和列表区别式，元祖定义后不可修改</span></span><br><span class="line">    <span class="comment"># 定义一个空元祖</span></span><br><span class="line">    tuple01 = ()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义1个值得元祖，需要在值后面加，</span></span><br><span class="line">    str = (<span class="string">"Test"</span>)</span><br><span class="line">    tuple02 = (<span class="string">"Test"</span>,)</span><br><span class="line">    print(<span class="string">"str的类型为："</span>, type(str))</span><br><span class="line">    print(<span class="string">"tuple02的类型为："</span>, type(tuple02))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义元祖可省略括号</span></span><br><span class="line">    tuple03 = <span class="string">"Test"</span>, <span class="string">"我是元祖"</span>, <span class="string">"Test"</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"tuple03的类型为："</span>, type(tuple03))</span><br><span class="line">    print(*tuple03)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> tuple03:</span><br><span class="line">        print(tuple03.index(n))</span><br><span class="line">        print(tuple03.count(n))</span><br></pre></td></tr></table></figure><h2 id="元组和列表的区别"><a href="#元组和列表的区别" class="headerlink" title="元组和列表的区别"></a>元组和列表的区别</h2><ul><li>元组可以理解为一个只读的列表,除了修改元素方法不同,其他方法和列表相同</li></ul><h2 id="元组和列表的转换"><a href="#元组和列表的转换" class="headerlink" title="元组和列表的转换"></a>元组和列表的转换</h2><ul><li>列表变量 = list(元组变量)<ul><li>把元组转换为列表</li></ul></li><li>元组变量 = tuple(列表变量)<ul><li>把列表转换为元组</li></ul></li><li>在python中转化数据类型就是用, 数据类型的关键字(要转化的内容)<ul><li>要转化内容一定是可转化的</li></ul></li></ul><h3 id="代码举例：-6"><a href="#代码举例：-6" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 元祖和列表区别式，元祖定义后不可修改</span></span><br><span class="line">    <span class="comment"># 定义一个空元祖</span></span><br><span class="line">    tuple01 = (<span class="string">"Test"</span>, <span class="string">"我是元祖"</span>, <span class="string">"Test"</span>)</span><br><span class="line"></span><br><span class="line">    print(type(tuple01))</span><br><span class="line">    list01 = list(tuple01)</span><br><span class="line">    print(type(list01))</span><br><span class="line">    list01.append(<span class="string">"转list后可修改数据"</span>)</span><br><span class="line">    <span class="comment"># 在转回tuple</span></span><br><span class="line">    tuple02 = tuple(list01)</span><br><span class="line">    print(type(tuple02))</span><br><span class="line">    print(*tuple02)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Python自动化" scheme="http://mypeng.site/categories/Python%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
    <category term="Python自动化" scheme="http://mypeng.site/tags/Python%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>〖接口测试〗postman做接口测试09-日志调试</title>
    <link href="http://mypeng.site/posts/344e3c5b/"/>
    <id>http://mypeng.site/posts/344e3c5b/</id>
    <published>2022-01-14T16:39:30.000Z</published>
    <updated>2022-01-14T16:39:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>在做接口测试时，经常会因为代码写的有问题导致报错，这时通过查看日志就显得非常重要了，postman也提供了这样的功能，它允许我们在脚本中编写打印语句，查看打印的结果 ; 同时也可以查看每个请求的日志信息 。</p></blockquote><h2 id="postman日志用的是什么编程语言？"><a href="#postman日志用的是什么编程语言？" class="headerlink" title="postman日志用的是什么编程语言？"></a>postman日志用的是什么编程语言？</h2><p>在postman中编写日志打印语句使用的是JavaScript，编写的位置可以是Pre-request Script 或Tests标签中。编写打印语句如：console.log(“hello,postman”)</p><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/09-001.png" alt="img"> </p><h2 id="那么打印的日如何看呢-？"><a href="#那么打印的日如何看呢-？" class="headerlink" title="那么打印的日如何看呢 ？"></a>那么打印的日如何看呢 ？</h2><p>在postman中有俩个入口，第一个入口就是：view-show postman console 。</p><p>第二个入口就是左下角第三个图标 。</p><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/09-002.png" alt="img"> </p><h3 id="打开的日志界面"><a href="#打开的日志界面" class="headerlink" title="打开的日志界面"></a>打开的日志界面</h3><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/09-003.png" alt="img"> </p><p>这里面有几个比较实用的功能：</p><p>搜索日志：输入URL或者打印的日志就能直接搜索出我们想要的请求和日志，这对我们在众多日志中查找某一条日志是非常方便的 。</p><ul><li>按级别搜索：可以查询log,info,warning,error级别的日志 ，有助于我们更快定位到错误 。</li></ul><ul><li>查看原始报文(Show raw log)：如果习惯看原始请求报文的话，这个功能可能更方便些 。</li></ul><ul><li>隐藏请求(Hide network)：把请求都隐藏掉，只查看输出日志 。</li></ul><p>总之，通过这个功能，我们在请求接口报错时，通过打印响应的日志，就能很轻松的找到问题原因了 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="postman" scheme="http://mypeng.site/categories/postman/"/>
    
    
    <category term="postman" scheme="http://mypeng.site/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>【公开api接口】字符串加密/解密API接口</title>
    <link href="http://mypeng.site/posts/689fc75c/"/>
    <id>http://mypeng.site/posts/689fc75c/</id>
    <published>2022-01-13T15:48:20.000Z</published>
    <updated>2022-01-13T15:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="接口地址"><a href="#接口地址" class="headerlink" title="接口地址"></a>接口地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.vvhan.com&#x2F;api&#x2F;jm</span><br></pre></td></tr></table></figure><h2 id="返回格式"><a href="#返回格式" class="headerlink" title="返回格式"></a>返回格式</h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><h2 id="请求方式："><a href="#请求方式：" class="headerlink" title="请求方式："></a>请求方式：</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><h2 id="请求示例-加密-："><a href="#请求示例-加密-：" class="headerlink" title="请求示例(加密)："></a>请求示例(加密)：</h2><blockquote><p><a href="https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要加密的内容&amp;type=en" target="_blank" rel="noopener">https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要加密的内容&amp;type=en</a></p></blockquote><h2 id="请求示例-解密-："><a href="#请求示例-解密-：" class="headerlink" title="请求示例(解密)："></a>请求示例(解密)：</h2><blockquote><p><a href="https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要解密的内容&amp;type=de" target="_blank" rel="noopener">https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要解密的内容&amp;type=de</a></p></blockquote><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><table><thead><tr><th align="left">名称</th><th align="left">必填</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">key</td><td align="left">否</td><td align="left">string</td><td align="left">自定义密匙</td></tr><tr><td align="left">string</td><td align="left">是</td><td align="left">string</td><td align="left">加/解密内容</td></tr><tr><td align="left">type</td><td align="left">否</td><td align="left">string</td><td align="left">en表示加密,de表示解密(默认)</td></tr></tbody></table><h2 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加密：&#123;&quot;enmissString&quot;:&quot;InFYZ0VPKzVzTkdxUWlxV1VXVnA5cmtCenRxYkNTY3JUeVwvVWtxTm16VHNjPSI&#x3D;&quot;&#125;</span><br><span class="line">解密：&#123;&quot;demissString&quot;:小韩网络&#125;</span><br></pre></td></tr></table></figure><h2 id="调用实例"><a href="#调用实例" class="headerlink" title="调用实例"></a>调用实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自行调用</span><br></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?phpheader(&#39;Content-type:text&#x2F;json;charset&#x3D;utf-8;&#39;);</span><br><span class="line">$key&#x3D;$_GET[&#39;key&#39;];</span><br><span class="line">$string&#x3D;$_GET[&#39;string&#39;];</span><br><span class="line">$type&#x3D;$_GET[&#39;type&#39;];</span><br><span class="line">$result &#x3D; file_get_contents(&#39;https:&#x2F;&#x2F;api.vvhan.com&#x2F;api&#x2F;jm?key&#x3D;&#39;.$key.&#39;&amp;string&#x3D;&#39;.$string.&#39;&amp;type&#x3D;&#39;.$type);</span><br><span class="line">echo $result;?&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="API" scheme="http://mypeng.site/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>〖接口测试〗postman做接口测试08-测试断言</title>
    <link href="http://mypeng.site/posts/2ab40ef8/"/>
    <id>http://mypeng.site/posts/2ab40ef8/</id>
    <published>2022-01-13T14:28:02.000Z</published>
    <updated>2022-01-13T14:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>如果没有断言这个功能，那我们的测试就只能是通过我们人工比较预期结果和实际结果是否一致。有了这个功能就为我们做自动化提供了条件，postman中的断言也是非常方便的 。</p></blockquote><h1 id="我们先来了解下postman断言的一些特点-，具体如下"><a href="#我们先来了解下postman断言的一些特点-，具体如下" class="headerlink" title="我们先来了解下postman断言的一些特点 ，具体如下"></a>我们先来了解下postman断言的一些特点 ，具体如下</h1><h3 id="断言编写位置：Tests标签"><a href="#断言编写位置：Tests标签" class="headerlink" title="断言编写位置：Tests标签"></a>断言编写位置：Tests标签</h3><h3 id="断言所用语言：JavaScript"><a href="#断言所用语言：JavaScript" class="headerlink" title="断言所用语言：JavaScript"></a>断言所用语言：JavaScript</h3><h3 id="断言执行顺序：在响应体数据返回后执行-。"><a href="#断言执行顺序：在响应体数据返回后执行-。" class="headerlink" title="断言执行顺序：在响应体数据返回后执行 。"></a>断言执行顺序：在响应体数据返回后执行 。</h3><h3 id="断言执行结果查看：Test-Results"><a href="#断言执行结果查看：Test-Results" class="headerlink" title="断言执行结果查看：Test Results"></a>断言执行结果查看：Test Results</h3><p>在上面我们介绍到，编写的断言代码是JavaScript，那如果不会写怎么办 ？ 不用担心，因为postman已经给我们内置了一些常用的断言 。用的时候，只需从右侧点击其中一个断言，就会在文本框中自动生成对应断言代码块 。</p><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/08-001.png" alt="img"> </p><h1 id="接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。"><a href="#接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。" class="headerlink" title="接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。"></a>接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。</h1><p>本次使用公开天气api接口演示「<a href="http://doc.tianqiapi.com/」" target="_blank" rel="noopener">http://doc.tianqiapi.com/」</a></p><p>状态行中又包括状态码，状态消息 。在postman也可以对这俩个进行断言</p><h2 id="状态行中的断言："><a href="#状态行中的断言：" class="headerlink" title="状态行中的断言："></a>状态行中的断言：</h2><h3 id="断言状态码：Status-code-code-is-200"><a href="#断言状态码：Status-code-code-is-200" class="headerlink" title="断言状态码：Status code: code is 200"></a>断言状态码：Status code: code is 200</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言相应状态码为200"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.status(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="断言状态消息：Status-code：code-name-has-string"><a href="#断言状态消息：Status-code：code-name-has-string" class="headerlink" title="断言状态消息：Status code：code name has string"></a>断言状态消息：Status code：code name has string</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言响应状态消息包含OK"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.status(<span class="string">"OK"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="响应头中的断言"><a href="#响应头中的断言" class="headerlink" title="响应头中的断言"></a>响应头中的断言</h2><h3 id="断言响应头中包含：Response-headers-Content-Type-header-check"><a href="#断言响应头中包含：Response-headers-Content-Type-header-check" class="headerlink" title="断言响应头中包含：Response headers:Content-Type header check"></a>断言响应头中包含：Response headers:Content-Type header check</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言响应头存在'Content-Type'"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.header(<span class="string">"Content-Type"</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="断言响应体-重点"><a href="#断言响应体-重点" class="headerlink" title="断言响应体(重点)"></a>断言响应体(重点)</h2><h3 id="断言响应体中包含XXX字符串：Response-body-Contains-string"><a href="#断言响应体中包含XXX字符串：Response-body-Contains-string" class="headerlink" title="断言响应体中包含XXX字符串：Response body:Contains string"></a>断言响应体中包含XXX字符串：Response body:Contains string</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言返回内容包含该文本"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="literal">undefined</span></span><br><span class="line">    pm.expect(pm.response.text()).to.include(<span class="string">"101010100"</span>);</span><br><span class="line">&#125;);   </span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line"><span class="comment">//pm.expect(pm.response.text()).to.include("string")      获取响应文本中包含string</span></span><br></pre></td></tr></table></figure><h3 id="断言响应体等于XXX字符串：Response-body-is-equal-to-a-string"><a href="#断言响应体等于XXX字符串：Response-body-is-equal-to-a-string" class="headerlink" title="断言响应体等于XXX字符串：Response body : is equal to a string"></a>断言响应体等于XXX字符串：Response body : is equal to a string</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"Body is correct"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.body(<span class="string">"response_body_string"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line"><span class="comment">//pm.response.to.have.body("response_body_string");   获取响应体等于response_body_string</span></span><br></pre></td></tr></table></figure><h3 id="断言响应体-json-中某个键名对应的值：Response-body-JSON-value-check"><a href="#断言响应体-json-中某个键名对应的值：Response-body-JSON-value-check" class="headerlink" title="断言响应体(json)中某个键名对应的值：Response body : JSON value check"></a>断言响应体(json)中某个键名对应的值：Response body : JSON value check</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言相应城市为北京"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jsonData = pm.response.json();</span><br><span class="line">    pm.expect(jsonData.city).to.eql(<span class="string">"北京"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line"><span class="comment">//var jsonData = pm.response.json()   获取响应体，以json显示，赋值给jsonData .注意：该响应体必须返会是的json，否则会报错</span></span><br><span class="line"><span class="comment">//pm.expect(jsonData.value).to.eql("北京")  获取jsonData中键名为value的值，然后和"北京"进行比较</span></span><br></pre></td></tr></table></figure><h3 id="响应时间-一般用于性能测试"><a href="#响应时间-一般用于性能测试" class="headerlink" title="响应时间(一般用于性能测试)"></a>响应时间(一般用于性能测试)</h3><p>断言响应时间：Response time is less than 200ms</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"Response time is less than 200ms"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.expect(pm.response.responseTime).to.be.below(<span class="number">200</span>);   <span class="comment">//断言响应时间&lt;200ms</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="案例说明："><a href="#案例说明：" class="headerlink" title="案例说明："></a>案例说明：</h3><p>针对以下接口返回的数据进行断言：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"cityid"</span>: <span class="string">"101010100"</span>,</span><br><span class="line">    <span class="attr">"city"</span>: <span class="string">"北京"</span>,</span><br><span class="line">    <span class="attr">"update_time"</span>: <span class="string">"22:34"</span>,</span><br><span class="line">    <span class="attr">"wea"</span>: <span class="string">"晴"</span>,</span><br><span class="line">    <span class="attr">"wea_img"</span>: <span class="string">"qing"</span>,</span><br><span class="line">    <span class="attr">"tem"</span>: <span class="string">"-2"</span>,</span><br><span class="line">    <span class="attr">"tem_day"</span>: <span class="string">"3"</span>,</span><br><span class="line">    <span class="attr">"tem_night"</span>: <span class="string">"-7"</span>,</span><br><span class="line">    <span class="attr">"win"</span>: <span class="string">"南风"</span>,</span><br><span class="line">    <span class="attr">"win_speed"</span>: <span class="string">"2级"</span>,</span><br><span class="line">    <span class="attr">"win_meter"</span>: <span class="string">"5km/h"</span>,</span><br><span class="line">    <span class="attr">"air"</span>: <span class="string">"43"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="断言响应状态码为200"><a href="#断言响应状态码为200" class="headerlink" title="断言响应状态码为200"></a>断言响应状态码为200</h4><h4 id="断言city等于北京"><a href="#断言city等于北京" class="headerlink" title="断言city等于北京"></a>断言city等于北京</h4><h4 id="断言cityid包含”101010100”"><a href="#断言cityid包含”101010100”" class="headerlink" title="断言cityid包含”101010100”"></a>断言cityid包含”101010100”</h4><p>  <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/08-002.png" alt="img"> </p><blockquote><p> 总结，整体来说，如果用postman做接口测试，这个断言功能必不可少，其中我们常断言的响应体包含和JSON这俩个断言又是重重之重。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="postman" scheme="http://mypeng.site/categories/postman/"/>
    
    
    <category term="postman" scheme="http://mypeng.site/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖接口测试〗postman做接口测试07-批量执行用例</title>
    <link href="http://mypeng.site/posts/c4b6dbb9/"/>
    <id>http://mypeng.site/posts/c4b6dbb9/</id>
    <published>2022-01-12T15:05:36.000Z</published>
    <updated>2022-01-12T15:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p> 当我们在一个Collection中编写了很多的接口测试用例，想一起执行这批用例，在postman中是如何操作呢 ？</p></blockquote><h1 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h1><h2 id="1-选中一个Collection，点击右三角，在弹出的界面点击RUN"><a href="#1-选中一个Collection，点击右三角，在弹出的界面点击RUN" class="headerlink" title="1. 选中一个Collection，点击右三角，在弹出的界面点击RUN"></a>1. 选中一个Collection，点击右三角，在弹出的界面点击RUN</h2><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/07-001.png" alt="img"> </p><h2 id="2-这是会弹出一个叫Collection-Runner的界面，默认会把Collection中的所有用例选上"><a href="#2-这是会弹出一个叫Collection-Runner的界面，默认会把Collection中的所有用例选上" class="headerlink" title="2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选上."></a>2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选上.</h2><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/07-002.png" alt="img"> </p><h2 id="3-点击界面下方的RUN-Collection，就会对Collection选中的所有测试用例运行-。"><a href="#3-点击界面下方的RUN-Collection，就会对Collection选中的所有测试用例运行-。" class="headerlink" title="3. 点击界面下方的RUN Collection，就会对Collection选中的所有测试用例运行 。"></a>3. 点击界面下方的RUN Collection，就会对Collection选中的所有测试用例运行 。</h2><p> <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/07-003.png" alt="img"> </p><h3 id="对上面的几个红框内的功能进行简单说明："><a href="#对上面的几个红框内的功能进行简单说明：" class="headerlink" title="对上面的几个红框内的功能进行简单说明："></a>对上面的几个红框内的功能进行简单说明：</h3><p>断言统计：左上角的俩个0是统计当前Collection中断言成功的执行数和失败的执行数，如果没有编写断言默认都为0 。</p><ul><li><p>Run Summary: 运行结果总览，点击它可以看到每个请求中具体的测试断言详细信息 。</p></li><li><p>Export Result：导出运行结果，默认导出的结果json文件 。</p></li><li><p>Retry: 重新运行，点击它会把该Collection重新运行一遍</p></li><li><p>New：返回到Runner，可以重新选择用例的组合 。</p></li></ul><p>总体来说，这个功能主要是用于对一个Collection中的所有用例或部分用例进行批量运行，已达到手工回归测试的目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="postman" scheme="http://mypeng.site/categories/postman/"/>
    
    
    <category term="postman" scheme="http://mypeng.site/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖接口测试〗postman做接口测试06-用例管理（Collection）</title>
    <link href="http://mypeng.site/posts/b8685e49/"/>
    <id>http://mypeng.site/posts/b8685e49/</id>
    <published>2022-01-11T15:39:50.000Z</published>
    <updated>2022-01-11T15:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="怎么解决用例满天飞的局面？"><a href="#怎么解决用例满天飞的局面？" class="headerlink" title="怎么解决用例满天飞的局面？"></a>怎么解决用例满天飞的局面？</h2><p>当我们对一个或多个系统中的很多用例进行维护时，首先想到的就是对用例进行分类管理，同时我们还要对这些做回归测试 。那么postman也提供了这样一个功能，就是Collection 。通过这个Collection就可以满足我们的上面说的需求。</p><h3 id="先对Collection功能的使用场景做个简单总结-。"><a href="#先对Collection功能的使用场景做个简单总结-。" class="headerlink" title="先对Collection功能的使用场景做个简单总结 。"></a>先对Collection功能的使用场景做个简单总结 。</h3><h4 id="用例分类管理，方便后期维护"><a href="#用例分类管理，方便后期维护" class="headerlink" title="用例分类管理，方便后期维护"></a>用例分类管理，方便后期维护</h4><h4 id="可以进行批量用例回归测试-。"><a href="#可以进行批量用例回归测试-。" class="headerlink" title="可以进行批量用例回归测试 。"></a>可以进行批量用例回归测试 。</h4><h2 id="那么Collection是如何去管理用例的呢-？"><a href="#那么Collection是如何去管理用例的呢-？" class="headerlink" title="那么Collection是如何去管理用例的呢 ？"></a>那么Collection是如何去管理用例的呢 ？</h2><p>先想象我们要测试一个系统，系统下有多个模块，每个模块下有很多的被测接口用例 。那么基于这个场景，我们来通过Collection来进行实现：</p><h4 id="1-点击Collection，点击-New-Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）"><a href="#1-点击Collection，点击-New-Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）" class="headerlink" title="1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）"></a>1. 点击Collection，点击+New Collection，在弹出的输入框中输入Collection名称（这个就可以理解为所测试的系统）</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/06-001.png" alt="create"></p><h4 id="2-选中新建的Collection右键，点击Add-Folder-，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）"><a href="#2-选中新建的Collection右键，点击Add-Folder-，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）" class="headerlink" title="2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）"></a>2. 选中新建的Collection右键，点击Add Folder ，在弹出对话框中输入文件夹名称（这个就可以理解为系统中的模块）</h4><p>   <img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/06-002.png" alt="create"></p><h4 id="3-选中新建的Folder，点击Add-Request-，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例-。"><a href="#3-选中新建的Folder，点击Add-Request-，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例-。" class="headerlink" title="3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。"></a>3. 选中新建的Folder，点击Add Request ，在弹出的对话框中输入请求名称，这个就是我们所测试的接口，也可以理解为测试用例 。</h4><p><img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/06-003.png" alt="create"></p><p>那么通过以上三个步骤，达到的效果就是如图所示：<br><img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/06-004.png" alt="create"></p><p>总结，通过上面的操作，我们实现了一个最简单的demo模型。但实际上，这个Collection的用处非常广，很多功能的使用都必须先创建Collection，比如用例的批量执行，Mock ，接口文档等功能 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="postman" scheme="http://mypeng.site/categories/postman/"/>
    
    
    <category term="postman" scheme="http://mypeng.site/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖接口测试〗postman做接口测试05-响应数据解析</title>
    <link href="http://mypeng.site/posts/9656df9f/"/>
    <id>http://mypeng.site/posts/9656df9f/</id>
    <published>2022-01-10T14:33:29.000Z</published>
    <updated>2022-01-10T14:33:29.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="什么是返回？"><a href="#什么是返回？" class="headerlink" title="什么是返回？"></a>什么是返回？</h2><p>响应数据是发送请求后经过服务器处理后返回的结果，响应是由三部分组成，分别是状态行、响应头、响应体。我们来看下<a href="https://so.csdn.net/so/search?q=postman" target="_blank" rel="noopener">postman</a>的响应数据展示 </p><p><img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/postman%E5%81%9A%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%9505-001.png" alt="百度搜索"></p><p>在postman中的响应数据展示：<br>状态行：Status：200 OK<br>响应头：Headers + Cookies，需要注意的是Cookies是包含在响应头中的，但是为了明显，工具会分开显示<br>响应体：Body</p><h2 id="返回测试什么？"><a href="#返回测试什么？" class="headerlink" title="返回测试什么？"></a>返回测试什么？</h2><p>那么这些数据对我们做接口测试有什么作用呢 ？<br>Body和Status是我们做接口测试的重点，一般来说我们都会验证响应体中的数据和响应状态码<br>Test Results 是我们编写断言后，可以查看断言的执行结果 ，所以这个对我们也很有用 。<br>Time 和Size 是我们做性能测试时，可以根据这俩个参数来对所测接口的性能做一个简单的判断。</p><h2 id="返回里有什么？"><a href="#返回里有什么？" class="headerlink" title="返回里有什么？"></a>返回里有什么？</h2><p>接下来我们再来关注下Body中的几个显示主题，分别是：Pretty，Raw，Preview .<br><img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/postman%E5%81%9A%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%9505-002.png" alt="百度搜索"></p><p>Pretty:翻译成中文就是漂亮 ， 也就是说返回的Body数据在这个标签中查看 ，都是经过格式化的，格式化后的数据看起来更加直观，所以postman默认展示的也是这个选项。比如返回html页面，它会经过格式化成HTML格式后展示，比如返回json，那么也会格式化成json格式展示 。</p><p>需要说明的是，我们所测的接口多会返回json,这时我们看json数据时，只需要点击HTML后的小三角，选择JSON即可。</p><p>Raw：翻译成中文未经过加工的，也就是原始数据 ，原始数据一般都是本文格式的，未经过格式化处理的，一般在抓包工具中都有这个选项 。</p><p>Preview：翻译成中文就是预览，这个选项一般对返回HTML的页面效果特别明显，如请求百度后返回结果，点击这个选项后就直接能查看到的页面 ，如下图 。同时这个选项和浏览器抓包中的Preview也是一样的 。<br><img src= "/img/loading1.gif" data-lazy-src="https://gitee.com/XuePengJu/PictureDependency/raw/main/blog/ArticlePictures/postman/postman%E5%81%9A%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%9505-003.png" alt="百度搜索"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="postman" scheme="http://mypeng.site/categories/postman/"/>
    
    
    <category term="postman" scheme="http://mypeng.site/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>【01】Shell特殊位置变量</title>
    <link href="http://mypeng.site/posts/3bd3916a/"/>
    <id>http://mypeng.site/posts/3bd3916a/</id>
    <published>2022-01-09T07:32:32.000Z</published>
    <updated>2022-01-09T07:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-0-获取脚本名称"><a href="#1-0-获取脚本名称" class="headerlink" title="1). $0 获取脚本名称"></a>1). $0 获取脚本名称</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun shell]# cat test.sh</span><br><span class="line">echo $0</span><br><span class="line"></span><br><span class="line">[root@aliyun shell]# sh test.sh</span><br><span class="line">test.sh</span><br><span class="line">[root@aliyun shell]#</span><br><span class="line">[root@aliyun shell]# sh /root/shell/test.sh</span><br><span class="line">/root/shell/test.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果只想获取脚本名称 basename</span></span><br><span class="line">[root@aliyun shell]# basename test.sh</span><br><span class="line">test.sh</span><br><span class="line">[root@aliyun shell]# basename /root/shell/test.sh</span><br><span class="line">test.sh</span><br><span class="line">[root@aliyun shell]#</span><br></pre></td></tr></table></figure><h2 id="2-n表示脚本的第n个参数"><a href="#2-n表示脚本的第n个参数" class="headerlink" title="2). $n表示脚本的第n个参数"></a>2). $n表示脚本的第n个参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实例1</span></span><br><span class="line">[root@aliyun shell]# cat test.sh</span><br><span class="line">echo "超过9个变量不加引号"</span><br><span class="line">echo $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11</span><br><span class="line"></span><br><span class="line">echo "超过9个变量需要加花括号"</span><br><span class="line">echo $1 $2 $3 $4 $5 $6 $7 $8 $9 $&#123;10&#125; $&#123;11&#125;</span><br><span class="line"></span><br><span class="line">[root@aliyun shell]#</span><br><span class="line">[root@aliyun shell]# sh test.sh &#123;a..z&#125;</span><br><span class="line">超过9个变量不加引号</span><br><span class="line">a b c d e f g h i a0 a1</span><br><span class="line">超过9个变量需要加花括号</span><br><span class="line">a b c d e f g h i j k</span><br><span class="line">[root@aliyun shell]#</span><br><span class="line">[root@aliyun shell]# sh test.sh &#123;1..20&#125;</span><br><span class="line">超过9个变量不加引号</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line">超过9个变量需要加花括号</span><br><span class="line">1 2 3 4 5 6 7 8 9 10 11</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 实例2</span></span><br><span class="line">[root@aliyun shell]# cat test.sh</span><br><span class="line">[ $# -ne 2 ] &amp;&amp; echo "请输入两个参数" &amp;&amp; exit 1002</span><br><span class="line">name=$1</span><br><span class="line">age=$2</span><br><span class="line">echo $name $age</span><br><span class="line"></span><br><span class="line">[root@aliyun shell]# sh test.sh xiajian 22 dd</span><br><span class="line">请输入两个参数</span><br><span class="line">[root@aliyun shell]# sh test.sh xiajian</span><br><span class="line">请输入两个参数</span><br><span class="line">[root@aliyun shell]# sh test.sh xiajian 22</span><br><span class="line">xiajian 22</span><br><span class="line">[root@aliyun shell]#</span><br></pre></td></tr></table></figure><h2 id="3-获取脚本传参的个数"><a href="#3-获取脚本传参的个数" class="headerlink" title="3). $# 获取脚本传参的个数"></a>3). $# 获取脚本传参的个数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun shell]# cat test.sh</span><br><span class="line">echo $#</span><br><span class="line">[root@aliyun shell]# sh test.sh n1 n2 n3 n4</span><br><span class="line">4</span><br><span class="line">[root@aliyun shell]#</span><br></pre></td></tr></table></figure><h2 id="4-获取上一条命令返回结果-0-为成功-非0失败"><a href="#4-获取上一条命令返回结果-0-为成功-非0失败" class="headerlink" title="4). $? 获取上一条命令返回结果 0 为成功 非0失败"></a>4). $? 获取上一条命令返回结果 0 为成功 非0失败</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun shell]# ll</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 root root 54 Jan  9 16:09 killshell.sh</span><br><span class="line">-rw-r--r-- 1 root root  8 Jan  9 16:46 test.sh</span><br><span class="line">[root@aliyun shell]# echo $?</span><br><span class="line">0</span><br><span class="line">[root@aliyun shell]# lsl</span><br><span class="line">bash: lsl: command not found...</span><br><span class="line">[root@aliyun shell]# echo $?</span><br><span class="line">127</span><br><span class="line">[root@aliyun shell]#</span><br></pre></td></tr></table></figure><h2 id="5-获取上一个在后台运行脚本的PID"><a href="#5-获取上一个在后台运行脚本的PID" class="headerlink" title="5). $! 获取上一个在后台运行脚本的PID"></a>5). $! 获取上一个在后台运行脚本的PID</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun shell]# tail -f killshell.sh &amp;</span><br><span class="line">[1] 5268</span><br><span class="line">[root@aliyun shell]# sh test.sh &amp;</span><br><span class="line">pid=$!</span><br><span class="line">echo $pid</span><br><span class="line">sleep 5</span><br><span class="line">kill -9 $pid</span><br><span class="line"></span><br><span class="line">[root@aliyun shell]# echo $!</span><br><span class="line">5268</span><br><span class="line">[root@aliyun shell]#</span><br></pre></td></tr></table></figure><h2 id="6-shell本身的pid"><a href="#6-shell本身的pid" class="headerlink" title="6). $$ shell本身的pid"></a>6). $$ shell本身的pid</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun shell]# echo $$</span><br><span class="line">14975</span><br><span class="line">[root@aliyun shell]#</span><br></pre></td></tr></table></figure><h2 id="7-获取所有参数列表"><a href="#7-获取所有参数列表" class="headerlink" title="7). $@ 获取所有参数列表"></a>7). $@ 获取所有参数列表</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun shell]# cat test.sh</span><br><span class="line">echo $@</span><br><span class="line">[root@aliyun shell]# sh test.sh &#123;a..z&#125;</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure><h2 id="8-获取所有参数列表"><a href="#8-获取所有参数列表" class="headerlink" title="8)$* 获取所有参数列表"></a>8)$* 获取所有参数列表</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@aliyun shell]# cat test.sh</span><br><span class="line">echo $*</span><br><span class="line">[root@aliyun shell]# sh test.sh &#123;a..z&#125;</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> $*不加引号和<span class="variable">$@</span>一样,在循环里加引号时，“<span class="variable">$@</span>”会把引起来的内容作为一个变量</span></span><br><span class="line">[root@aliyun shell]# set -- "I am" xiajian student</span><br><span class="line">[root@aliyun shell]# echo $*</span><br><span class="line">I am xiajian student</span><br><span class="line">[root@aliyun shell]# echo $@</span><br><span class="line">I am xiajian student</span><br><span class="line">[root@aliyun shell]# for i in $*;do echo $i;done</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">xiajian</span><br><span class="line">student</span><br><span class="line">[root@aliyun shell]# for i in $@;do echo $i;done</span><br><span class="line">I</span><br><span class="line">am</span><br><span class="line">xiajian</span><br><span class="line">student</span><br><span class="line">[root@aliyun shell]# for i in "$@";do echo $i;done</span><br><span class="line">I am</span><br><span class="line">xiajian</span><br><span class="line">student</span><br><span class="line">[root@aliyun shell]# for i in "$*";do echo $i;done</span><br><span class="line">I am xiajian student</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Shell脚本" scheme="http://mypeng.site/categories/Shell%E8%84%9A%E6%9C%AC/"/>
    
    
    <category term="Shell脚本" scheme="http://mypeng.site/tags/Shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>【测试工具】Charles破解</title>
    <link href="http://mypeng.site/posts/ea42950b/"/>
    <id>http://mypeng.site/posts/ea42950b/</id>
    <published>2022-01-01T14:50:55.000Z</published>
    <updated>2022-01-01T14:50:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Charles破解"><a href="#Charles破解" class="headerlink" title="Charles破解"></a>Charles破解</h2><p><a href="http://www.charles.ren" target="_blank" rel="noopener">http://www.charles.ren</a></p><h5 id="进入上面的网站，随意输入一个Registered-Name，点击「生成」"><a href="#进入上面的网站，随意输入一个Registered-Name，点击「生成」" class="headerlink" title="进入上面的网站，随意输入一个Registered Name，点击「生成」"></a>进入上面的网站，随意输入一个Registered Name，点击「生成」</h5><p>如：admin123则生成 772CD45F2C5839B6D3</p><p> <img src= "/img/loading1.gif" data-lazy-src="/img/charles_20220101225450.png" alt="img"> </p><h5 id="打开charles-help-register，输入刚刚生成的，然后就激活成功啦"><a href="#打开charles-help-register，输入刚刚生成的，然后就激活成功啦" class="headerlink" title="打开charles-help-register，输入刚刚生成的，然后就激活成功啦"></a>打开charles-help-register，输入刚刚生成的，然后就激活成功啦</h5><p> <img src= "/img/loading1.gif" data-lazy-src="/img/8B2FEFE6-9051-432B-BAED-7B76EFA85FE1.png" alt="img"> </p><p> <img src= "/img/loading1.gif" data-lazy-src="/img/1EE1E433-AB1C-436F-95B0-EFDA18C2BE82.png" alt="img"> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Charles" scheme="http://mypeng.site/categories/Charles/"/>
    
    
    <category term="Charles" scheme="http://mypeng.site/tags/Charles/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客备份—妈妈再也不用担心你使用hexo写博客</title>
    <link href="http://mypeng.site/posts/a3886b70/"/>
    <id>http://mypeng.site/posts/a3886b70/</id>
    <published>2022-01-01T09:09:02.000Z</published>
    <updated>2022-01-01T09:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>今天搜了下hexo博客备份，发现好多都是用git命令备份的，于是推荐款好用的hexo备份插件：</p><p><a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="noopener">hexo-git-backup</a></p><h2 id="git-backup使用说明-翻译至README-："><a href="#git-backup使用说明-翻译至README-：" class="headerlink" title="git-backup使用说明(翻译至README)："></a><strong>git-backup使用说明(翻译至README)：</strong></h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p>如果您的hexo版本是2.xx，则应安装如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ npm install hexo-git-backup@<span class="number">0</span>.<span class="number">0</span>.<span class="number">91</span> --save</span><br></pre></td></tr></table></figure><p>如果版本是3.xx，你应该安装如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a><strong>更新</strong></h3><p>(windows不需要$符)</p><p>如果使用–save进行安装，则在更新时必须先删除。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ npm remove hexo-git-backup</span><br><span class="line"></span><br><span class="line">$ npm install hexo-git-backup --save</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h3><p>你应该配置这个文件_config.yml如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">backup:</span><br><span class="line"></span><br><span class="line">    type: git</span><br><span class="line"></span><br><span class="line">    repository:</span><br><span class="line"></span><br><span class="line">      github: git@github.com:xxx&#x2F;xxx.git,branchName</span><br><span class="line"></span><br><span class="line">      gitcafe: git@github.com:xxx&#x2F;xxx.git,branchName</span><br></pre></td></tr></table></figure><p>比如博主就新建了个backup分支用于备份</p><p>博主的配置如下</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">backup:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">type</span>: <span class="title">git</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">message</span>: <span class="title">backup</span> <span class="title">my</span> <span class="title">blog</span> <span class="title">of</span> <span class="title">https</span>://<span class="title">honjun.github.io</span>/</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">repository</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">github</span>: <span class="title">https</span>://<span class="title">github.com</span>/<span class="title">honjun</span>/<span class="title">honjun.github.io.git</span>,<span class="title">backup</span></span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hexo backup</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">hexo b</span><br></pre></td></tr></table></figure><p>Options</p><p>如果你要备份你的主题，只需添加theme: your theme name,your theme name在_config.yml。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">backup:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">theme:</span> <span class="string">coney,landscape,xxx</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">repository:</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">github:</span> <span class="string">git@github.com:xxx/xxx.git,branchName</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">gitcafe:</span> <span class="string">git@github.com:xxx/xxx.git,branchName</span></span><br></pre></td></tr></table></figure><p><strong>注意：如果您按照上述方式操作，themes/coney/.git则会删除目录</strong></p><p>如果你想DIY提交消息，只需添加“消息：更新xxx”。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">backup:</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">message:</span> <span class="string">update</span> <span class="string">xxx</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">repository:</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">github:</span> <span class="string">git@github.com:xxx/xxx.git,branchName</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">gitcafe:</span> <span class="string">git@github.com:xxx/xxx.git,branchName</span></span><br></pre></td></tr></table></figure><p>现在你可以备份所有的博客！</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h3><p>您的计算机许可可能会造成一些麻烦。</p><p><strong>错误：EISDIR，打开是由权限引起的。只要做’sudo hexo b’</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo hexo b</span><br></pre></td></tr></table></figure><p>参考<a href="https://www.v2ex.com/t/143022" target="_blank" rel="noopener">hexo 的备份插件</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Hexo" scheme="http://mypeng.site/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://mypeng.site/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>App自动化测试（一）之环境搭建</title>
    <link href="http://mypeng.site/posts/baaef441/"/>
    <id>http://mypeng.site/posts/baaef441/</id>
    <published>2021-12-26T06:28:25.000Z</published>
    <updated>2021-12-26T06:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="App自动化测试环境搭建"><a href="#App自动化测试环境搭建" class="headerlink" title="App自动化测试环境搭建"></a>App自动化测试环境搭建</h2><h2 id="一、准备jdk环境"><a href="#一、准备jdk环境" class="headerlink" title="一、准备jdk环境"></a>一、准备jdk环境</h2><p><a href="http://mypeng.site/post/54eecc7d.html">jdk安装和配置环境变量</a></p><h2 id="二、准备SDK环境"><a href="#二、准备SDK环境" class="headerlink" title="二、准备SDK环境"></a>二、准备SDK环境</h2><h4 id="1、-ADT-Bundle下载"><a href="#1、-ADT-Bundle下载" class="headerlink" title="1、 ADT Bundle下载"></a>1、 <a href="https://www.androiddevtools.cn/" target="_blank" rel="noopener">ADT Bundle下载</a></h4><p>ADT Bundle包含了Eclipse、ADT插件和SDK Tools，是已经集成好的IDE，只需安装好Jdk即可开始开发，推荐初学者下载ADT Bundle，不用再折腾开发环境。</p><p>下载adt-bundle-windows-x64.zip</p><p>链接：<a href="https://pan.baidu.com/s/1ZHKmPcbV4NVvZwoDzdAKpg" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZHKmPcbV4NVvZwoDzdAKpg</a><br>提取码：2gf7</p><h4 id="2、ADT-Bundle安装"><a href="#2、ADT-Bundle安装" class="headerlink" title="2、ADT Bundle安装"></a>2、ADT Bundle安装</h4><p>把下载好的 adt-bundle-windows-x86_64-20140702.zip 解压即可。</p><p> <img src= "/img/loading1.gif" data-lazy-src="/img/environment/1895590-20200229210636360-1610818154.png" alt="img">  </p><h4 id="3、配置环境变量"><a href="#3、配置环境变量" class="headerlink" title="3、配置环境变量"></a>3、配置环境变量</h4><ol><li><h5 id="点击此电脑右击–-gt-gt-点击属性"><a href="#点击此电脑右击–-gt-gt-点击属性" class="headerlink" title="点击此电脑右击–&gt;&gt;点击属性"></a>点击此电脑右击–&gt;&gt;点击属性</h5></li></ol><p><img src= "/img/loading1.gif" data-lazy-src="/img/environment/1895590-20200229210702614-864284209.png" alt="img"></p><ol start="2"><li><h5 id="配置SDK环境变量"><a href="#配置SDK环境变量" class="headerlink" title="配置SDK环境变量"></a>配置SDK环境变量</h5></li></ol><p>变量名：ANDROID_HOME</p><p>变量值：D:\Program Files (x86)\adt-bundle-windows-x86_64-20140702\sdk（要填写你自己的地址）</p><p><img src= "/img/loading1.gif" data-lazy-src="/img/environment/1895590-20200229210742813-1698355068.png" alt="img"></p><ol start="3"><li><h5 id="在path中添加变量"><a href="#在path中添加变量" class="headerlink" title="在path中添加变量"></a>在path中添加变量</h5></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%ANDROID_HOME%\platform-tools</span><br><span class="line">%ANDROID_HOME%\tools</span><br><span class="line">%ANDROID_HOME%\build-tools\28.0.3</span><br></pre></td></tr></table></figure><h4 id="4、验证环境变量是否配置成功"><a href="#4、验证环境变量是否配置成功" class="headerlink" title="4、验证环境变量是否配置成功"></a>4、验证环境变量是否配置成功</h4><p>在cmd窗口输入，adb 和 aapt验证环境变量是否配置成功。（** <em>注意：如果环境变量配置确定无误，但是输入命令出不来，就重启下电脑</em>）</p><p><img src= "/img/loading1.gif" data-lazy-src="/img/environment/1895590-20200229210909009-805568491.png" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="/img/environment/1895590-20200229210835166-2050290710.png" alt="img"></p><h2 id="三、安装Appium"><a href="#三、安装Appium" class="headerlink" title="三、安装Appium"></a>三、安装Appium</h2><p>appium 是一个自动化测试开源工具，支持 iOS 平台和 Android 平台上的原生应用，web应用和混合应用。</p><h4 id="1、Appium下载"><a href="#1、Appium下载" class="headerlink" title="1、Appium下载"></a>1、<a href="https://github.com/appium/appium-desktop/releases/tag/v1.13.0" target="_blank" rel="noopener">Appium下载</a></h4><p>百度云下载：<br>链接：<a href="https://pan.baidu.com/s/1Di8Qh5NEYeSmQoVFqH6crQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1Di8Qh5NEYeSmQoVFqH6crQ</a><br>提取码：huiq</p><h4 id="2、Appium安装"><a href="#2、Appium安装" class="headerlink" title="2、Appium安装"></a>2、Appium安装</h4><p><img src= "/img/loading1.gif" data-lazy-src="/img/environment/1895590-20200229211000223-187798199.png" alt="img"></p><ol><li><p>点击Appium-windows-1.13.0.exe进行安装。<br><img src= "/img/loading1.gif" data-lazy-src="/img/environment/1895590-20200229211032271-1280305583.png" alt="img"></p></li><li><p>选择 仅为我安装，点击安装。</p></li></ol><p><img src= "/img/loading1.gif" data-lazy-src="/img/environment/1895590-20200229211014622-396878393.png" alt="img"></p><ol start="3"><li>安装完成后打开后，可能会提示更新，切记莫更新！！</li></ol><h2 id="四、安装模拟器，或者使用真机"><a href="#四、安装模拟器，或者使用真机" class="headerlink" title="四、安装模拟器，或者使用真机"></a>四、安装模拟器，或者使用真机</h2><h5 id="模拟器推荐："><a href="#模拟器推荐：" class="headerlink" title="模拟器推荐："></a>模拟器推荐：</h5><p> <a href="https://www.ldmnq.com/" target="_blank" rel="noopener">【雷电】</a></p><p> <a href="https://www.yeshen.com/" target="_blank" rel="noopener">【夜神】</a></p><h2 id="五、安装Appium-Python-Client库"><a href="#五、安装Appium-Python-Client库" class="headerlink" title="五、安装Appium-Python-Client库"></a>五、安装Appium-Python-Client库</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Copypip install appium-python-client</span><br><span class="line"><span class="comment"># 下载不成功可以加上国内镜像</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">镜像：</span></span><br><span class="line"><span class="string">（1）阿里云 http://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="string">（2）豆瓣http://pypi.douban.com/simple/</span></span><br><span class="line"><span class="string">（3）清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span></span><br><span class="line"><span class="string">（4）中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</span></span><br><span class="line"><span class="string">（5）华中科技大学http://pypi.hustunique.com/</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pip install appium-python-client -i <span class="string">"https://pypi.doubanio.com/simple/"</span></span><br></pre></td></tr></table></figure><h3 id="至此，环境搭建已完成。"><a href="#至此，环境搭建已完成。" class="headerlink" title="至此，环境搭建已完成。"></a>至此，环境搭建已完成。</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Appium" scheme="http://mypeng.site/categories/Appium/"/>
    
    
    <category term="Appium" scheme="http://mypeng.site/tags/Appium/"/>
    
  </entry>
  
  <entry>
    <title>【DDSNTO教程】-利用软路由插件DDNSTO实现内网穿透</title>
    <link href="http://mypeng.site/posts/96032b58/"/>
    <id>http://mypeng.site/posts/96032b58/</id>
    <published>2021-12-21T15:21:13.000Z</published>
    <updated>2021-12-21T15:21:13.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>这个插件是由小宝大神开发的, 感谢~</p></blockquote><blockquote><p><strong>傻 瓜 式 操 作 , 一 看 就 会 的 那 种 . . . 大 神 绕 道~</strong></p></blockquote><h2 id="一、准备条件"><a href="#一、准备条件" class="headerlink" title="一、准备条件"></a>一、准备条件</h2><p>一台Openwrt LEDE软路由系统<br>微信号<br>要映射的主机(网站&amp;管理后台)</p><h2 id="二、开始操作"><a href="#二、开始操作" class="headerlink" title="二、开始操作"></a>二、开始操作</h2><p>进入你的Openwrt LEDE后台Web页面, 点击酷软</p><p> <img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/c22919ee98f8f3de883ba34fd536bf22.png" alt="打开酷软中心"> </p><p>点击未安装, 找到DDNS插件, 点击安装<br>等待安装完毕后, 点击这里的链接</p><p> <img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/6287cb29e71dc08ea16143ec925f4ba1.png" alt=""> </p><p>再点击右上角的微信, 使用微信扫码登陆后, 你会发现右上角就出现了属于你的令牌, 把他输入到上图的token中即可<br>勾选开启ddnsto, 再点击保存, 这时候你的网络中的服务就开启了</p><h2 id="三、设置映射"><a href="#三、设置映射" class="headerlink" title="三、设置映射"></a>三、设置映射</h2><p>回到刚刚的微信登陆的网页, 点击添加域名映射</p><p> <img src= "/img/loading1.gif" data-lazy-src="https://img-blog.csdnimg.cn/img_convert/97d4a2e51b47a9d9aa7f392e98aab1b3.png" alt="添加映射"> </p><p>成功后你, 会看到下图,这时候你可以点击这个域名, 就可以进入到你的网站啦, 如果提示还未成功, 你就等个十几秒再次刷新网页即可.</p><h2 id="四、官方教程："><a href="#四、官方教程：" class="headerlink" title="四、官方教程："></a>四、官方教程：</h2><blockquote><p><a href="https://doc.linkease.com/zh/guide/ddnsto/" target="_blank" rel="noopener">https://doc.linkease.com/zh/guide/ddnsto/</a></p></blockquote><p> <img src= "/img/loading1.gif" data-lazy-src="/img/ddsnto_step.png" alt=""> </p><h2 id="五、声明"><a href="#五、声明" class="headerlink" title="五、声明"></a>五、声明</h2><p>这种内网穿透的方法, 偏向私人访问, 因为在一个浏览器中第一次访问的话, 是要先进行微信验证才可以访问你设置的网站的. 这是为了安全考虑, 暂时没有去除的方法~</p><h3 id="…Over…"><a href="#…Over…" class="headerlink" title="…Over…"></a>…Over…</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="博客" scheme="http://mypeng.site/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>【工具分享】DDNSTO 简单、快速的内网穿透工具</title>
    <link href="http://mypeng.site/posts/f6c5d65f/"/>
    <id>http://mypeng.site/posts/f6c5d65f/</id>
    <published>2021-12-20T16:07:00.000Z</published>
    <updated>2021-12-20T16:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="随时随地抵达你的-私人网络"><a href="#随时随地抵达你的-私人网络" class="headerlink" title="随时随地抵达你的 私人网络"></a>随时随地抵达你的 私人网络</h3><p>简单、快速的内网穿透工具，不受<br>网络限制，全局掌控您的私人设备</p><p>DDNSTO 由 <a href="https://koolshare.cn/space-uid-2380.html" target="_blank" rel="noopener">KoolShare (opens new window)</a>@小宝 开发，是一款稳定、快速、简单易用的内网穿透工具。 让用户在公司、旅行途中都能够使用浏览器方便的访问家庭内的网络设备。</p><p>目前市面上的穿透工具都有各种小缺点，有的需要电脑安装客户端并且要支付几百块钱的年费、frp需要自行购买云服务器并且配置过程对小白用户来说也比较复杂。</p><p><strong>DDNSTO 解决了常见穿透工具年费贵、配置复杂的问题，让小白用户几分钟就能搞定内网穿透。</strong></p><p>DDNSTO 的优秀之处：</p><ol><li>无需公网 IP，不被网络环境限制</li><li>无需购买域名或服务器，省去了服务器年费和带宽要求以及域名购买、备案等等繁琐操作</li><li>全部的安装、配置、使用都可在浏览器完成，不需要敲一行代码，对小白用户非常友好</li><li>支持http2，访问家庭内部网络速度更快</li><li>独家的远程应用中心，让远程电脑桌面、远程下载、远程文件管理等多种丰富的功能在浏览器上就可以实现</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【测试工具】Android Input命令</title>
    <link href="http://mypeng.site/posts/7de15477/"/>
    <id>http://mypeng.site/posts/7de15477/</id>
    <published>2021-12-15T14:52:48.000Z</published>
    <updated>2021-12-15T14:52:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p>input是Android系统中的一个特殊的命令，用于模拟遥控器、键盘、鼠标的各种按键操作。我们都知道Android是阉割版本的Linux系统，Linux中很多命令在Android系统中是没有的。但是他们之间并没有包含的关系，Android系统中有些特有的东西（命令、属性）在Linux中也是没有的。</p><h3 id="命令路径"><a href="#命令路径" class="headerlink" title="命令路径"></a>命令路径</h3><p>可以通过which 命令查看该命令的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">130|superli:&#x2F; # which -a input        </span><br><span class="line">&#x2F;system&#x2F;bin&#x2F;input</span><br><span class="line">superli:&#x2F; #</span><br></pre></td></tr></table></figure><h3 id="命令概要"><a href="#命令概要" class="headerlink" title="命令概要"></a>命令概要</h3><h4 id="Android-4-4以前"><a href="#Android-4-4以前" class="headerlink" title="Android 4.4以前"></a>Android 4.4以前</h4><p>使用help命令查看命令如何使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@hwH30-U10:&#x2F; # input --help</span><br><span class="line">Error: Unknown command: --help</span><br><span class="line">usage: input ...</span><br><span class="line">       input text &lt;string&gt;</span><br><span class="line">       input keyevent &lt;key code number or name&gt;</span><br><span class="line">       input [touchscreen|touchpad] tap &lt;x&gt; &lt;y&gt;</span><br><span class="line">       input [touchscreen|touchpad] swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt;</span><br><span class="line">       input trackball press</span><br><span class="line">       input trackball roll &lt;dx&gt; &lt;dy&gt;</span><br><span class="line">root@hwH30-U10:&#x2F; #</span><br></pre></td></tr></table></figure><h3 id="Android-4-4"><a href="#Android-4-4" class="headerlink" title="Android 4.4+"></a>Android 4.4+</h3><p>使用help命令查看命令如何使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">130|superli:&#x2F; # input --help</span><br><span class="line">Error: Unknown command: --help  ## 未知命令？为什么会出现这个？？？算了，不重要，可能系统抽风了。</span><br><span class="line">Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]</span><br><span class="line"></span><br><span class="line">The sources are: ##模拟的输入设备类型</span><br><span class="line">      keyboard</span><br><span class="line">      mouse</span><br><span class="line">      joystick</span><br><span class="line">      touchnavigation</span><br><span class="line">      touchpad</span><br><span class="line">      trackball</span><br><span class="line">      dpad</span><br><span class="line">      stylus</span><br><span class="line">      gamepad</span><br><span class="line">      touchscreen</span><br><span class="line"></span><br><span class="line">The commands and default sources are: ## 不指定source时，命令的默认输入设备类型为：</span><br><span class="line">      text &lt;string&gt; (Default: touchscreen)</span><br><span class="line">      keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard)</span><br><span class="line">      tap &lt;x&gt; &lt;y&gt; (Default: touchscreen)</span><br><span class="line">      swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</span><br><span class="line">      press (Default: trackball)</span><br><span class="line">      roll &lt;dx&gt; &lt;dy&gt; (Default: trackball)</span><br><span class="line">superli:&#x2F; #</span><br></pre></td></tr></table></figure><h3 id="命令解读和使用"><a href="#命令解读和使用" class="headerlink" title="命令解读和使用"></a>命令解读和使用</h3><p>后续内容主要分析Android 4.4+版本关于input命令的使用，当然4.4以前的版本也可以参考，毕竟差别并不是很大。</p><p>命令格式：input [<source>] <command> [<arg>…]</p><p>命令格式（中文版）：input [&lt;设备类型（可选）&gt;] &lt;命令&gt; [&lt;参数（可选）&gt;…]</p><p>命令格式中可以看到有两个可选的部分：</p><p>设备类型：设备类型不输入时，使用命令的默认设备类型。默认类型见下文。<br>参数：当命令没有参数时，可不输入（想了半天，想不出来什么命令不需要参数）</p><h4 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h4><p>sources    模拟的输入设备类型<br>keyboard    键盘<br>mouse    鼠标<br>joystick    操纵杆（玩过游戏手柄的同学应该懂吧）<br>touchnavigation    ？？触摸导航？？<br>touchpad    触摸板<br>trackball    轨迹球（啥意思？）<br>dpad    什么鬼<br>stylus    触控笔（styluses）<br>gamepad    游戏手柄<br>touchscreen    触摸屏<br>设备类型还挺丰富的，好多普通人根本接触不到，哎，我就是普通人。</p><h3 id="命令列表和默认设备类型"><a href="#命令列表和默认设备类型" class="headerlink" title="命令列表和默认设备类型"></a>命令列表和默认设备类型</h3><p>命令    默认设备类型    示例<br>text    touchscreen    input text “hello”<br>keyevent [–longpress]    keyboard    input keyevent 4<br>tap    touchscreen    input tap 500 500<br>swipe [duration(ms)]    touchscreen    input swipe 500 500 600 500 200<br>press    trackball    input press<br>roll    trackball    input roll 500 500<br>命令演练与解释<br>命令列表中，关于press和roll都是针对触控球的设备设计的，因为手中没有设备，而且这种设备现实中使用的比较少，所以就不做演示</p><p>text<br>该命令用于模拟触摸屏的虚拟键盘输入字符串。</p><p>比如，下面使用命令输入“hello”：</p><p>HWVKY:/ $ input text hello</p><p>text命令后面的字符都会以字符串的形式输入，如果恰好设备的焦点在一个可输入控件（通常为EditText）中，那么可输入控件中就会出现“hello”字样。</p><p>如果命令执行后，“hello”并没有显示，请检查一下控件是否有限定输入类型。</p><p>keyevent<br>该命令用以默认按键输入，对应的输入设备场景可能是遥控器、键盘等。</p><p>例如，下面使用命令模拟遥控器的返回键：</p><p>HWVKY:/ $ input keyevent 4</p><p>命令执行后，设备中能很明显的看到有回退动作。命令中的参数“4”，对应的是keyevent中的返回键。下面列出部分常用keyevent事件的键值列表。</p><p>Keyevent    value    备注<br>KEYCODE_BACK    4    返回键<br>KEYCODE_HOME    3    HOME键<br>KEYCODE_MENU    82    菜单键<br>KEYCODE_DPAD_UP    19    上<br>KEYCODE_DPAD_DOWN    20    下<br>KEYCODE_DPAD_LEFT    21    左<br>KEYCODE_DPAD_RIGHT    22    右<br>KEYCODE_DPAD_CENTER    23    OK键<br>KEYCODE_VOLUME_UP    24    音量+<br>KEYCODE_VOLUME_DOWN    25    音量-<br>如果列表中不满足你的需求，可以去android.view.KeyEvent.java中查看</p><p>tap<br>该命令用于模拟触摸操作，感觉就是点击一下指定位置，可以让指定的点变相的获取焦点。</p><p>例如，下面的命令，如果位于首页，500*500的坐标处恰好有一个应用图标，那么命令执行后，会打开该应用：</p><figure class="highlight plain"><figcaption><span>$ input tap 500 500```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">swipe</span><br><span class="line">该命令用于模拟手势滑动操作</span><br><span class="line"></span><br><span class="line">例如，下面的命令模拟，从500*500的坐标滑动到600*500的位置：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;HWVKY:&#x2F; $ input swipe 500 500 600 500</span><br></pre></td></tr></table></figure><p>上边的命令执行后，屏幕瞬间就会滑动，那么我要慢慢的滑动怎么办呢，看下面的命令:</p><figure class="highlight plain"><figcaption><span>$ input swipe 500 500 600 500 500```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">两个命令的区别在于第二个多了一个参数，该参数表示该滑动需要执行的时长为500ms。</span><br><span class="line"></span><br><span class="line">值得一提的是，当参数中的两个坐标点使用一个点时，秒变长按事件：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;HWVKY:&#x2F; $ input swipe 500 500 500 500 1000</span><br></pre></td></tr></table></figure><p>该命令表示：长按坐标为500*500的点1秒钟。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【测试工具】是时候扔掉 Postman 了，Apifox 真香！</title>
    <link href="http://mypeng.site/posts/de4de369/"/>
    <id>http://mypeng.site/posts/de4de369/</id>
    <published>2021-12-14T14:56:17.000Z</published>
    <updated>2021-12-14T14:56:17.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>作为开软件开发从业者，接口调试是必不可少的一项技能，我们经常使用 Postman 工具来进行接口调试，在接口调试方面 Postman 做的非常出色。但是在整个软件开发过程中，接口调试只是其中的一部分，还有很多事情 Postman 无法完成，或者无法高效完成，比如：接口文档定义、Mock 数据、接口自动化测试等等。</p></blockquote><p>需要 Apifox 功能介绍 PPT 版本的（可用于团队内部分享/推广 Apifox），可点击以下链接下载。<br><a href="https://cdn3.apifox.cn/www/assets/ppt/Apifox介绍.pptx" target="_blank" rel="noopener">Apifox 功能介绍 ppt 格式</a><br><a href="https://cdn3.apifox.cn/www/assets/ppt/Apifox介绍.pdf" target="_blank" rel="noopener">Apifox 功能介绍 pdf 格式</a></p><h2 id="接口管理现状"><a href="#接口管理现状" class="headerlink" title="接口管理现状"></a>接口管理现状</h2><h3 id="一、常用解决方案"><a href="#一、常用解决方案" class="headerlink" title="一、常用解决方案"></a>一、常用解决方案</h3><ol><li>使用 Swagger 作为<a href="https://www.apifox.cn/" target="_blank" rel="noopener">接口文档工具</a></li><li>使用 Postman 调试接口</li><li>使用 RAP 等工具 Mock 数据</li><li>使用 JMeter 做接口自动化测试</li></ol><h3 id="二、存在的问题"><a href="#二、存在的问题" class="headerlink" title="二、存在的问题"></a>二、存在的问题</h3><p>维护不同工具之间数据一致性非常困难、低效。并且这里不仅仅是工作量的问题，更大的问题是多个系统之间数据不一致，导致协作低效、频繁出问题，开发测试人员痛苦不堪。</p><ol><li>开发人员在 Swagger 定义好文档后，接口调试的时候还需要去 Postman 再定义一遍。</li><li>前端开发 Mock 数据的时候又要去 RAP 定义一遍，还需要手动设置 Mock 规则。</li><li>测试人员需要去 JMeter 再定义一遍。</li><li>前端根据 RAP Mock 出来的数据开发完，后端根据 Swagger 定义的接口文档开发完，各自都试测试通过了，本以为可以马上上线，结果一对接发现各种问题：</li></ol><ul><li>开发过程中接口变更了，只修改了 Swagger，但是没有及时同步修改 RAP。</li><li>后端开发的接口数据类型和文档不一致，肉眼难以发现问题。</li></ul><ol><li>同样，测试在 JMeter 写好的测试用例，真正运行的时候也会发现各种不一致。</li><li>时间久了，各种不一致会越来越严重。</li></ol><h2 id="Apifox-解决方案"><a href="#Apifox-解决方案" class="headerlink" title="Apifox 解决方案"></a>Apifox 解决方案</h2><h3 id="一、如何解决这些问题"><a href="#一、如何解决这些问题" class="headerlink" title="一、如何解决这些问题"></a>一、如何解决这些问题</h3><h3 id="1、Apifox-定位"><a href="#1、Apifox-定位" class="headerlink" title="1、Apifox 定位"></a>1、Apifox 定位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apifox &#x3D; Postman + Swagger + Mock + JMeter</span><br></pre></td></tr></table></figure><p>通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好接口文档，接口调试、数据 Mock、接口测试就可以直接使用，无需再次定义；接口文档和接口开发调试使用同一个工具，接口调试完成后即可保证和接口文档定义完全一致。高效、及时、准确！</p><h3 id="2、Apifox-宗旨"><a href="#2、Apifox-宗旨" class="headerlink" title="2、Apifox 宗旨"></a>2、Apifox 宗旨</h3><p>节省研发团队的每一分钟！</p><h3 id="3、Apifox-功能"><a href="#3、Apifox-功能" class="headerlink" title="3、Apifox 功能"></a>3、Apifox 功能</h3><ol><li><strong>接口设计</strong>：Apifox 接口文档遵循 <a href="https://openapi.apifox.cn/" target="_blank" rel="noopener">OpenApi</a> 3.0 (原 Swagger)、<a href="https://json-schema.org/" target="_blank" rel="noopener">JSON Schema</a> 规范的同时，提供了非常好用的<code>可视化</code>文档管理功能，零学习成本，非常高效。并且支持在线分享接口文档。</li><li><strong>数据模型</strong>：可复用的数据结构，定义接口<code>返回数据结构</code>及<code>请求参数数据结构</code>（仅 JSON 和 XML 模式）时可直接引用。支持模型直接嵌套引用，直接 JSON/XML 智能导入，支持 oneOf、allOf 等高级组合模式。</li><li><strong>接口调试</strong>：Postman 有的功能，比如环境变量、前置/后置脚本、Cookie/Session 全局共享 等功能，Apifox 都有，并且比 Postman 更高效好用。接口运行完之后点击<code>保存为用例</code>按钮，即可生成<code>接口用例</code>，后续可直接运行接口用例，无需再输入参数，非常方便。自定义脚本 100% 兼容 Postman 语法，并且支持运行javascript、java、python、php、js、BeanShell、go、shell、ruby、lua等各种语言代码。</li><li><strong>接口用例</strong>：通常一个接口会有多种情况用例，比如<code>参数正确</code>用例、<code>参数错误</code>用例、<code>数据为空</code>用例、<code>不同数据状态</code>用例等等。运行接口用例时会自动校验数据正确性，用接口用例来调试接口非常高效。</li><li><strong>接口数据 Mock</strong>：内置 <a href="http://mockjs.com/" target="_blank" rel="noopener">Mock.js</a> 规则引擎，非常方便 mock 出各种数据，并且可以在定义数据结构的同时写好 mock 规则。支持添加“期望”，根据请求参数返回不同 mock 数据。最重要的是 Apifox <code>零配置</code> 即可 Mock 出非常人性化的数据，具体在本文后面介绍。</li><li><strong>接口自动化测试</strong>：提供接口集合测试，可以通过选择接口（或接口用例）快速创建测试集。目前接口自动化测试更多功能还在开发中，敬请期待！目标是： JMeter 有的功能基本都会有，并且要更好用。</li><li><strong>数据库操作</strong>：支持读取数据库数据，作为接口请求参数使用。支持读取数据库数据，用来校验(断言)接口请求是否成功。</li><li><strong>快捷调试</strong>：类似 Postman 的接口调试方式，主要用途为临时调试一些<code>无需文档化</code>的接口，无需提前定义接口即可快速调试。</li><li><strong>代码生成</strong>：根据接口及数据数据模型定义，系统自动生成<code>接口请求代码</code>、<code>前端业务代码</code>及<code>后端业务代码</code>。</li><li><strong>团队协作</strong>：Apifox 天生就是为团队协作而生的，接口云端实时同步更新，成熟的<code>团队/项目/成员权限</code>管理，满足各类企业的需求。</li></ol><h3 id="二、Apifox-做的不仅仅是数据打通"><a href="#二、Apifox-做的不仅仅是数据打通" class="headerlink" title="二、Apifox 做的不仅仅是数据打通"></a>二、Apifox 做的不仅仅是数据打通</h3><p>如果你认为 Apifox 只做了数据打通，来提升研发团队的效率，那就错了。Apifox 还做了非常多的创新，来提升开发人员的效率。</p><h3 id="1、接口支持“用例管理”"><a href="#1、接口支持“用例管理”" class="headerlink" title="1、接口支持“用例管理”"></a>1、接口支持“用例管理”</h3><p>通常一个接口会有多种情况用例，比如 <code>正确用例</code> <code>参数错误用例</code> <code>数据为空用例</code> <code>不同数据状态用例</code>。定义接口的时候定义好这些不同状态的用例，接口调试的时候直接运行，非常高效。</p><h3 id="2、“数据模型”定义、引用"><a href="#2、“数据模型”定义、引用" class="headerlink" title="2、“数据模型”定义、引用"></a>2、“数据模型”定义、引用</h3><p>可以独立定义数据模型，接口定义时可以直接引用数据模型，数据模型之间也可以相互引用。同样的数据结构，只需要定义一次即可多处使用；修改的时候只需要修改一处，多处实时更新，避免不一致。</p><h3 id="3、调试时“自动校验”数据结构"><a href="#3、调试时“自动校验”数据结构" class="headerlink" title="3、调试时“自动校验”数据结构"></a>3、调试时“自动校验”数据结构</h3><p>使用 Apifox 调试接口的时候，系统会根据接口文档里的定义，自动校验返回的数据结构是否正确，无需通过肉识别，也无需手动写断言脚本检测，非常高效！</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic3.zhimg.com/v2-84b60639898cf51fd75bb557e615a5d2_r.jpg" alt="img"></p><h3 id="4、“可视化”设置断言"><a href="#4、“可视化”设置断言" class="headerlink" title="4、“可视化”设置断言"></a>4、“可视化”设置断言</h3><p>设置断言：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic4.zhimg.com/v2-09c5c04497eabbe8be8617ce8f12ea97_r.jpg" alt="img"></p><p>运行后，查看断言结果：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic1.zhimg.com/v2-93c6ad02f0fb83ced91aaddab5299204_r.jpg" alt="img"></p><h3 id="5、“可视化”设置提取变量"><a href="#5、“可视化”设置提取变量" class="headerlink" title="5、“可视化”设置提取变量"></a>5、“可视化”设置提取变量</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://pic2.zhimg.com/v2-e1bfaee9f4a6b935db7f354255dc9c5d_r.jpg" alt="img"></p><h3 id="6、支持数据库操作"><a href="#6、支持数据库操作" class="headerlink" title="6、支持数据库操作"></a>6、支持数据库操作</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://pic1.zhimg.com/v2-07fcb7adc6b2e157b26c244b5c930b6c_r.jpg" alt="img"></p><h3 id="7、“零配置”Mock-出非常人性化的数据"><a href="#7、“零配置”Mock-出非常人性化的数据" class="headerlink" title="7、“零配置”Mock 出非常人性化的数据"></a>7、“零配置”Mock 出非常人性化的数据</h3><p>先放一张图对比下 Apifox 和其他同类工具 <code>零配置</code> mock 出来的数据效果：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic1.zhimg.com/v2-cf3012a053f55cf2ecd84871c4db4394_r.jpg" alt="img"></p><p>可以看出 Apifox <code>零配置</code> Mock 出来的数据和真实情况是非常接近的，前端开发可以直接使用，而无需再手动写 mock 规则。</p><p><strong>Apifox 如何做到<code>高效率</code>、<code>零配置</code>生成非常人性化的 mock 数据</strong></p><ol><li>Apifox 根据接口定义里的数据结构、数据类型，自动生成 mock 规则。</li><li>Apifox 内置智能 mock 规则库，根据字段名、字段数据类型，智能优化自动生成的 mock 规则。如：名称包含字符串<code>image</code>的<code>string</code>类型字段，自动 mock 出一个图片地址 URL；包含字符串<code>time</code>的<code>string</code>类型字段，自动 mock 出一个时间字符串；包含字符串<code>city</code>的<code>string</code>类型字段，自动 mock 出一个城市名。</li><li>Apifox 根据内置规则，可自动识别出图片、头像、用户名、手机号、网址、日期、时间、时间戳、邮箱、省份、城市、地址、IP 等字段，从而 Mock 出非常人性化的数据。</li><li>除了内置 mock 规则，用户还可以自定义规则库，满足各种个性化需求。支持使用 <code>正则表达式</code>、<code>通配符</code> 来匹配字段名自定义 mock 规则。</li></ol><h3 id="8、代码自动生成"><a href="#8、代码自动生成" class="headerlink" title="8、代码自动生成"></a>8、代码自动生成</h3><p>根据接口模型定义，自动生成各种语言/框架（如 TypeScript、Java、Go、Swift、ObjectiveC、Kotlin、Dart、C++、C#、Rust 等）的业务代码（如 Model、Controller、单元测试代码等）和接口请求代码。目前 Apifox 支持 130 种语言及框架的代码自动生成。</p><p>更重要的是：你可以通过<code>自定义代码模板</code>来生成符合自己团队的架构规范的代码，满足各种个性化的需求。</p><h3 id="9、导入、导出"><a href="#9、导入、导出" class="headerlink" title="9、导入、导出"></a>9、导入、导出</h3><ol><li>支持导出 <code>OpenApi (Swagger)</code>、<code>Markdown</code>、<code>Html</code> 等数据格式，因为可以导出<code>OpenApi</code>格式数据，所以你可以利用 OpenApi (Swagger) 丰富的生态工具完成各种接口相关的事情。</li><li>支持导入 <code>OpenApi (Swagger)</code>、<code>Postman</code>、<code>HAR</code>、<code>RAML</code>、<code>RAP2</code>、<code>YApi</code>、<code>Eolinker</code>、<code>NEI</code>、<code>DOClever</code>、<code>ApiPost</code> 、<code>Apizza</code> 、<code>ShowDoc</code>、<code>API Blueprint</code>、<code>I/O Docs</code>、<code>WADL</code>、<code>Google Discovery</code>等数据格式，方便旧项目迁移。</li></ol><h3 id="三、后续功能规划"><a href="#三、后续功能规划" class="headerlink" title="三、后续功能规划"></a>三、后续功能规划</h3><ol><li>接口文档公开对外发布。</li><li>接口性能测试支持（类似 JMeter）。</li><li>支持插件市场，可以自己开发插件。</li><li>支持更多接口协议，如<code>GraphQL</code>、<code>websocket</code>等。</li><li>支持离线使用，项目可选择在线同步（团队协作）还是仅本地存储（单机离线使用）。</li></ol><h3 id="四、更多-Apifox-功能截图"><a href="#四、更多-Apifox-功能截图" class="headerlink" title="四、更多 Apifox 功能截图"></a>四、更多 Apifox 功能截图</h3><p><img src= "/img/loading1.gif" data-lazy-src="https://pic3.zhimg.com/v2-cb29c171a62fec7792e09d4dea5601e2_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic4.zhimg.com/v2-b8a6e673775dead99fb7bf55fa3675e3_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic4.zhimg.com/v2-c0d31e348ca6fb205222ad5dbf95d9ab_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic3.zhimg.com/v2-a5f3fe99fd6deae3d00a107b8444d506_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic3.zhimg.com/v2-ea0e973c7134c19edbf2b80ef2fcf05a_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic4.zhimg.com/v2-b8c20d0818b3c7bef56137cb2e2cb2fb_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic2.zhimg.com/v2-5ac1da128a350111cfcbf47ab2f60b59_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic3.zhimg.com/v2-6ef28c655835d5c8c98723c1c9d41f1a_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic1.zhimg.com/v2-fb6a6c2696b5e07015a071f480673854_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic1.zhimg.com/v2-eb8c27f09926a8dbe448c63d8d57ef74_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic1.zhimg.com/v2-149c5990e064bd371d3ea283a2d420d0_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic2.zhimg.com/v2-53926e1ca0884baed2c9ab20bed12bed_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic4.zhimg.com/v2-1dc4db7aa4ffcee95888c84da74812cf_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic3.zhimg.com/v2-ae3f1d1e3eba65908c843b238dbf728a_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic3.zhimg.com/v2-199dc8a814c5cbd2b6c603fb96589db6_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic1.zhimg.com/v2-c95173613dd345831e9fc8a9e96b3624_r.jpg" alt="img"></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pic2.zhimg.com/v2-f5d96e21a55bf995f3d003bf09b2947d_r.jpg" alt="img"></p><h3 id="五、-Apifox-下载地址"><a href="#五、-Apifox-下载地址" class="headerlink" title="五、 Apifox 下载地址"></a>五、 Apifox 下载地址</h3><p>请访问 Apifox 官网下载：<a href="https://www.apifox.cn/?utm_source=zhihu&utm_medium=article_10001&utm_content=377387530" target="_blank" rel="noopener">https://www.apifox.cn/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【测试工具】浅度测评：requests、aiohttp、httpx 我应该用哪一个？</title>
    <link href="http://mypeng.site/posts/2173e2a4/"/>
    <id>http://mypeng.site/posts/2173e2a4/</id>
    <published>2021-12-12T14:12:58.000Z</published>
    <updated>2021-12-12T14:12:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在武汉，房子里待着，不出去影响世界了，转载点文章。</p><p>在 Python 众多的 HTTP 客户端中，最有名的莫过于requests、aiohttp和httpx。在不借助其他第三方库的情况下，requests只能发送同步请求；aiohttp只能发送异步请求；httpx既能发送同步请求，又能发送异步请求。</p><p>所谓的同步请求，是指在单进程单线程的代码中，发起一次请求后，在收到返回结果之前，不能发起下一次请求。所谓异步请求，是指在单进程单线程的代码中，发起一次请求后，在等待网站返回结果的时间里，可以继续发送更多请求。</p><p>今天我们来一个浅度测评，仅仅以多次发送 POST 请求这个角度来对比这三个库的性能。</p><p>测试使用的 HTTP 服务地址为<a href="http://122.51.39.219:8000/query，向它发送" target="_blank" rel="noopener">http://122.51.39.219:8000/query，向它发送</a> POST 请求的格式如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics6.baidu.com/feed/0b46f21fbe096b6301e3838247be9b42e9f8acfa.jpeg?token=70d39787cf58d67bf77a9106c04807a4&s=C096E73B1CA8440D18E1A5DB0000E0B3" alt="img"></p><p>请求发送的 ts 字段日期距离今天大于10天，那么返回{“success”: false}，如果小于等于10天，那么返回{“success”: true}。</p><p>首先我们通过各个客户端使用相同的参数只发送一次请求，看看效果。</p><p>发送一次请求</p><p><strong>requests</strong></p><p>import requestsresp = requests.post(‘<a href="http://122.51.39.219:8000/query&#39;" target="_blank" rel="noopener">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}).json()print(resp)运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics2.baidu.com/feed/63d9f2d3572c11df47d7597328aa7ed6f603c2f4.png?token=a37daa3c6812a2d7d1f92ffa76fd4e77&s=718A7D3B110E554D1674B0DA030050B0" alt="img"></p><p><strong>httpx</strong></p><p>使用 httpx 发送同步请求：</p><p>import httpxresp = httpx.post(‘<a href="http://122.51.39.219:8000/query&#39;" target="_blank" rel="noopener">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}).json()print(resp)httpx 的同步模式与 requests 代码重合度99%，只需要把requests改成httpx即可正常运行。如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics4.baidu.com/feed/faedab64034f78f02435131e32bc1653b2191cb0.png?token=e3e2e21a11fa3f55e0d73094d6b578cd&s=718A7D3B110E554D1674B0DA030050B0" alt="img"></p><p>使用 httpx 发送异步请求：</p><p>import httpximport asyncioasyncdefmain():asyncwith httpx.AsyncClient() as client: resp = await client.post(‘<a href="http://122.51.39.219:8000/query&#39;" target="_blank" rel="noopener">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}) result = resp.json() print(result)asyncio.run(main())运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics2.baidu.com/feed/0823dd54564e9258a5a27545d20fcd5ecdbf4e1e.png?token=53fcebbef383dda74aa8d3adea337a1d&s=7108753B111E55CC4AC19DDA0300D0B1" alt="img"></p><p><strong>aiohttp</strong></p><p>import aiohttpimport asyncioasyncdefmain():asyncwith aiohttp.ClientSession() as client: resp = await client.post(‘<a href="http://122.51.39.219:8000/query&#39;" target="_blank" rel="noopener">http://122.51.39.219:8000/query&#39;</a>, json={‘ts’: ‘2020-01-20 13:14:15’}) result = await resp.json() print(result)asyncio.run(main())运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics1.baidu.com/feed/0824ab18972bd407aed406f4310482570fb3093f.png?token=38acd3253e87bd2f0628fbf3c4781a70&s=7B08752B111E55CC42C11DDA0300D0B1" alt="img"></p><p>aiohttp 的代码与 httpx 异步模式的代码重合度90%，只不过把AsyncClient换成了ClientSession，另外，在使用 httpx 时，当你await client.post时就已经发送了请求。但是当使用aiohttp时，只有在awiat resp.json() 时才会真正发送请求。</p><p>发送100次请求</p><p>我们现在随机生成一个距离今天在5-15天的日期，发送到 HTTP接口中。如果日期距离今天超过10天，那么返回的数据的 False，如果小于等于10天，那么返回的数据是 True。</p><p>我们发送100次请求，计算总共耗时。</p><p><strong>requests</strong></p><p>在前几天的文章中，我们提到，使用requests.post每次都会创建新的连接，速度较慢。而如果首先初始化一个 Session，那么 requests 会保持连接，从而大大提高请求速度。所以在这次测评中，我们分别对两种情况进行测试。</p><p>不保持连接</p><p>import randomimport timeimport datetimeimport requestsdefmake_request(body): resp = requests.post(‘<a href="http://122.51.39.219:8000/query&#39;" target="_blank" rel="noopener">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)defmain(): start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) make_request({‘ts’: ts}) end = time.time() print(f’发送100次请求，耗时：{end - start}’)if <strong>name</strong> == ‘<strong>main</strong>‘: main()运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics2.baidu.com/feed/0ff41bd5ad6eddc4b5380c217356aafb506633a4.jpeg?token=8f345eb6f471f83547307a2770098fa4&s=E11A643B011ED5CE46D405DA0000C0B1" alt="img"></p><p><strong>发送100次请求，requests 不保持连接时耗时2.7秒</strong></p><p>保持连接</p><p>对代码稍作修改，使用同一个 Session 发送请求：</p><p>import randomimport timeimport datetimeimport requestsdefmake_request(session, body): resp = session.post(‘<a href="http://122.51.39.219:8000/query&#39;" target="_blank" rel="noopener">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)defmain(): session = requests.Session() start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) make_request(session, {‘ts’: ts}) end = time.time() print(f’发送100次请求，耗时：{end - start}’)if <strong>name</strong> == ‘<strong>main</strong>‘: main()运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics2.baidu.com/feed/1e30e924b899a901c2b847365718167d0308f5b0.jpeg?token=389373396414cd3fd0c8e558d2fcf9ac&s=F008743B811ED5CE004500DA0000C0B1" alt="img"></p><p><strong>发送100次请求，requests 保持连接耗时1.4秒</strong></p><p><strong>httpx</strong></p><p>同步模式</p><p>代码如下：</p><p>import randomimport timeimport datetimeimport httpxdefmake_request(client, body): resp = client.post(‘<a href="http://122.51.39.219:8000/query&#39;" target="_blank" rel="noopener">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)defmain(): session = httpx.Client() start = time.time()for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) make_request(session, {‘ts’: ts}) end = time.time() print(f’发送100次请求，耗时：{end - start}’)if <strong>name</strong> == ‘<strong>main</strong>‘: main()运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics1.baidu.com/feed/f636afc379310a55c4caf697fdc85faf8326107d.jpeg?token=32ab623d88054400cb2bd2ba44f6a743&s=50087C3BC11ED5CC18D508DA0000C0B1" alt="img"></p><p><strong>发送100次请求，httpx 同步模式耗时1.5秒左右。</strong></p><p>异步模式</p><p>代码如下：</p><p>import httpximport randomimport datetimeimport asyncioimport timeasyncdefrequest(client, body): resp = await client.post(‘<a href="http://122.51.39.219:8000/query&#39;" target="_blank" rel="noopener">http://122.51.39.219:8000/query&#39;</a>, json=body) result = resp.json() print(result)asyncdefmain():asyncwith httpx.AsyncClient() as client: start = time.time() task_list = []for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) req = request(client, {‘ts’: ts}) task = asyncio.create_task(req) task_list.append(task)await asyncio.gather(*task_list) end = time.time() print(f’发送100次请求，耗时：{end - start}’)asyncio.run(main())运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics3.baidu.com/feed/1f178a82b9014a90bef4207ee4fa2514b11beeba.jpeg?token=01173500e927b2967d8da8b7e470f17a&s=4418743BC15EC5CC404128DA000010B0" alt="img"></p><p><strong>发送100次请求，httpx 异步模式耗时0.6秒左右。</strong></p><p><strong>aiohttp</strong></p><p>测试代码如下：</p><p>import aiohttpimport randomimport datetimeimport asyncioimport timeasyncdefrequest(client, body): resp = await client.post(‘<a href="http://122.51.39.219:8000/query&#39;" target="_blank" rel="noopener">http://122.51.39.219:8000/query&#39;</a>, json=body) result = await resp.json() print(result)asyncdefmain():asyncwith aiohttp.ClientSession() as client: start = time.time() task_list = []for _ in range(100): now = datetime.datetime.now() delta = random.randint(5, 15) ts = (now - datetime.timedelta(days=delta)).strftime(‘%Y-%m-%d %H:%M:%S’) req = request(client, {‘ts’: ts}) task = asyncio.create_task(req) task_list.append(task)await asyncio.gather(*task_list) end = time.time() print(f’发送100次请求，耗时：{end - start}’)asyncio.run(main())运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics3.baidu.com/feed/2e2eb9389b504fc2313ebc72a950fb1791ef6df3.jpeg?token=a595216712e08dec3f155133f27e38a4&s=E4986C3AC95EE5CC4CC544DE0000C0B1" alt="img"></p><p><strong>发送100次请求，使用 aiohttp 耗时0.3秒左右</strong></p><p>发送1000次请求</p><p>由于 request 保持连接的速度比不保持连接快，所以我们这里只用保持连接的方式来测试。并且不打印返回的结果。</p><p><strong>requests</strong></p><p>运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics4.baidu.com/feed/359b033b5bb5c9ea40e4afa798b4aa063bf3b3f6.jpeg?token=514171994f18a98a6e7bb65e4ecff4ce&s=54087C3BD15FF5CC024548DA000080B1" alt="img"></p><p><strong>发送1000次请求，requests 耗时16秒左右</strong></p><p><strong>httpx</strong></p><p>同步模式</p><p>运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics6.baidu.com/feed/a1ec08fa513d26976689b5e21a76aefd4216d84e.jpeg?token=9306ad5ffa386a1d9a2227e36a4adbcf&s=D508743B915FD5CC045500DA0000C0B1" alt="img"></p><p><strong>发送1000次请求，httpx 同步模式耗时18秒左右</strong></p><p>异步模式</p><p>运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics0.baidu.com/feed/7aec54e736d12f2e0585c540034fc964843568a5.jpeg?token=1f6bd37b4fc444498a0e7cb32ff03378&s=4018543BD15FC1CC584520DA000080B1" alt="img"></p><p><strong>发送1000次请求，httpx 异步模式耗时5秒左右</strong></p><p><strong>aiohttp</strong></p><p>运行效果如下图所示：</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pics7.baidu.com/feed/5366d0160924ab182be2692f7f77facb7a890b41.jpeg?token=1394197262765a9fda0b13fde6b4fbb9&s=4418643BD15FC1CC545564DA000080B2" alt="img"></p><p><strong>发送1000次请求，aiohttp 耗时4秒左右</strong></p><p>总结</p><p>如果你只发几条请求。那么使用 requests 或者 httpx 的同步模式，代码最简单。</p><p>如果你要发送很多请求，但是有些地方要发送同步请求，有些地方要发送异步请求，那么使用 httpx 最省事。</p><p>如果你要发送很多请求，并且越快越好，那么使用 aiohttp 最快。</p><p>这篇测评文章只是一个非常浅度的评测，只考虑了请求速度这一个角度。如果你要在生产环境使用，那么你可以做更多实验来看是不是符合你的实际使用情况。</p><p>原文链接：<a href="https://baijiahao.baidu.com/s?id=1656736744425905392&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1656736744425905392&amp;wfr=spider&amp;for=pc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【自动化库】异步http接口调用库：httpx</title>
    <link href="http://mypeng.site/posts/b4b3bf4e/"/>
    <id>http://mypeng.site/posts/b4b3bf4e/</id>
    <published>2021-12-10T15:02:26.000Z</published>
    <updated>2021-12-10T15:02:26.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>谈到http接口调用，Requests大家并不陌生，例如，robotframework-requests、HttpRunner等HTTP接口测试库/框架都是基于它开发。这里将介绍另一款http接口测试框架:httpx。</p><p>它的API和Requests高度一致。</p><p>github: <a href="https://github.com/encode/httpx" target="_blank" rel="noopener">https://github.com/encode/httpx</a></p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> pip install httpx</span></span><br></pre></td></tr></table></figure><h2 id="httpx-简单使用"><a href="#httpx-简单使用" class="headerlink" title="httpx 简单使用"></a>httpx 简单使用</h2><p>当然，它是不支持python2.x的。</p><ul><li>简单的get调用</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line">r = httpx.get(<span class="string">"http://httpbin.org/get"</span>)</span><br><span class="line">print(r.status_code)</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span></span><br><span class="line">&#123;'args': &#123;&#125;, 'headers': &#123;'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Host': 'httpbin.org', 'User-Agent': 'python-httpx/0.12.1', 'X-Amzn-Trace-Id': 'Root=1-5ea5b58c-e446c44392ea090809e8a4bc'&#125;, 'origin': '113.97.33.224', 'url': 'http://httpbin.org/get'&#125;</span><br></pre></td></tr></table></figure><ul><li>带参数的post调用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span><br><span class="line">r = httpx.post(<span class="string">"http://httpbin.org/post"</span>, data=payload)</span><br><span class="line">print(r.json())</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;'args': &#123;&#125;, 'data': '', 'files': &#123;&#125;, 'form': &#123;'key1': 'value1', 'key2': 'value2'&#125;, 'headers': &#123;'Accept': '*/*', 'Accept-Encoding': 'gzip, deflate', 'Content-Length': '23', 'Content-Type': 'application/x-www-form-urlencoded', 'Host': 'httpbin.org', 'User-Agent': 'python-httpx/0.12.1', 'X-Amzn-Trace-Id': 'Root=1-5ea5b61d-1871d10e80b8324e48ea475e'&#125;, 'json': None, 'origin': '113.97.33.224', 'url': 'http://httpbin.org/post'&#125;</span><br></pre></td></tr></table></figure><p>你会发现这几乎和requests一模一样，只不过把requests 换成了httpx。</p><h2 id="httpx-异步调用"><a href="#httpx-异步调用" class="headerlink" title="httpx 异步调用"></a>httpx 异步调用</h2><p>接下来认识httpx的异步调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient() <span class="keyword">as</span> client:</span><br><span class="line">        resp = <span class="keyword">await</span> client.get(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line">        result = resp.json()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>这里用到了async 、await， asyncio等，等参考我关于python异步I/O的基础介绍：<a href="https://www.cnblogs.com/fnng/p/12757395.html" target="_blank" rel="noopener">https://www.cnblogs.com/fnng/p/12757395.html</a></p><h2 id="异步的调用的优势"><a href="#异步的调用的优势" class="headerlink" title="异步的调用的优势"></a>异步的调用的优势</h2><p>我们发现，采用异步会让接口的调用更加复杂，那为什么还要使用异步呢？当你要调用1000次接口时，那么异步调用可以让你的调用更快。接下来我们通过简单让例子进行对比。</p><p>以我flask开发的简单接口为例子：</p><p><a href="https://github.com/defnngj/learning-API-test" target="_blank" rel="noopener">https://github.com/defnngj/learning-API-test</a></p><blockquote><p>为了测试的更加准确性，我将flask服务部署在了另一台电脑，测试机与被测服务分离。</p></blockquote><ul><li>httpx 同步调用</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同步调用</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_request</span><span class="params">(client)</span>:</span></span><br><span class="line">    resp = client.get(<span class="string">'http://192.168.0.7:5000'</span>)</span><br><span class="line">    result = resp.json()</span><br><span class="line">    <span class="comment"># print(result)</span></span><br><span class="line">    <span class="keyword">assert</span> result[<span class="string">"code"</span>] == <span class="number">10200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    session = httpx.Client()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1000 次调用</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        make_request(session)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 开始</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    main()</span><br><span class="line">    <span class="comment"># 结束</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f'同步：发送1000次请求，耗时：<span class="subst">&#123;end - start&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">同步：发送1000次请求，耗时：52.948561906814575</span><br></pre></td></tr></table></figure><ul><li>httpx 异步调用</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异步调用</span></span><br><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">request</span><span class="params">(client)</span>:</span></span><br><span class="line">    resp = <span class="keyword">await</span> client.get(<span class="string">'http://192.168.0.7:5000'</span>)</span><br><span class="line">    result = resp.json()</span><br><span class="line">    <span class="comment"># print(result)</span></span><br><span class="line">    <span class="keyword">assert</span> result[<span class="string">"code"</span>] == <span class="number">10200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> httpx.AsyncClient() <span class="keyword">as</span> client:</span><br><span class="line">        <span class="comment"># # 开始</span></span><br><span class="line">        <span class="comment"># start = time.time()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1000 次调用</span></span><br><span class="line">        task_list = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">            req = request(client)</span><br><span class="line">            task = asyncio.create_task(req)</span><br><span class="line">            task_list.append(task)</span><br><span class="line">        <span class="keyword">await</span> asyncio.gather(*task_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    asyncio.run(main())</span><br><span class="line">    <span class="comment"># 结束</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(<span class="string">f'异步：发送1000次请求，耗时：<span class="subst">&#123;end - start&#125;</span>'</span>)</span><br></pre></td></tr></table></figure><p>结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">异步：发送1000次请求，耗时：3.903275728225708</span><br></pre></td></tr></table></figure><p>将httpx用于请求端，同步与异步请求差距非常明显。</p><p>以上的例子已经放到 learning-API-test github项目</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>*　这里只是拿 flask 非异步框架做为接口服务端进行对比，如果如果将接口服务同样换作前面介绍的 snaic 异步框架，上面的两组测试对比并不明显（snaic的异步接口服务处理同步请求更快），在安装 snaic的时候会发现，他同样也集成了 httpx 库。</p><p>*　为什么要学习异步，因为我们公司有很多接口是异步调用的，所以，我想真正搞懂这个概念，就这么简单！保持在工作中对技术的好奇心。</p><ul><li>异步与多线程的区别？这是我在学习 异步时候的一个疑问，我找到了一个比较形象的例子。</li></ul><blockquote><p>以火车站购票场景为例：一个火车站为一个进程，一个窗口和售票员的组合为一个线程：</p></blockquote><blockquote><ul><li>多线程：火车站开了N个窗口售票员，我们去买票，会有工作人员（CPU）指定我们去某个窗口买票，你被安排到某个窗口后，告诉售票员你的请求（咨询或买票），售票员执行操作，如果这个过程中发送的阻塞，也是窗口售票员的阻塞（比如查票的过程），但是因为你开了很多个窗口，其他买票的人可以被安排去另外的空闲窗口，如果所有窗口都满了，工作人员就不会给你安排了，直到有空的窗口出来；</li><li>多进程（并行）：建多个火车站售票，火车站与火车站间互不影响，看买票的自己想去哪里（这里不讨论负载均衡）；</li><li>异步：火车站只有一个窗口售票员，但是窗口前有一个登记台（事件循环），你把你想买的票告诉给登记台，并留下你的手机（回调函数），然后你就可以走了，由于登记台只是登记了你的请求，并没有做任何其他操作，所以这个耗时基本忽略不计的。之后售票员处理完了上一个任务了，就会自己去登记台取剩下的未完成的任务，直到取到你的任务，操作完后，有票没票都会通过手机通知你，如果有票还会往你的手机发车票的二维码；</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【自动化测试】WEB自动化测试环境搭建</title>
    <link href="http://mypeng.site/posts/a42e3f6d/"/>
    <id>http://mypeng.site/posts/a42e3f6d/</id>
    <published>2021-12-08T15:54:16.000Z</published>
    <updated>2021-12-08T15:54:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>一、selenium安装</p><p>Python3.x安装后就默认就会有pip（pip.exe默认在python的Scripts路径下），使用pip安装selenium：</p><p>在CMD命令行输入：pip install selenium </p><p>二、Webdriver、geckodriver下载配置：</p><p>Webdriver下载路径：<a href="http://chromedriver.storage.googleapis.com/index.html，用于驱动打开Chrome；" target="_blank" rel="noopener">http://chromedriver.storage.googleapis.com/index.html，用于驱动打开Chrome；</a></p><p>geckodriver下载路径：<a href="https://github.com/mozilla/geckodriver/releases，用于驱动打开Firefox；" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases，用于驱动打开Firefox；</a></p><p>下载后放在python.exe相同目录下:</p><p><img src= "/img/loading1.gif" data-lazy-src="https:////upload-images.jianshu.io/upload_images/17223368-b0594b2a52a4034b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/755/format/webp" alt="img"></p><p>测试下：打开python自带编辑器IDLE</p><p><img src= "/img/loading1.gif" data-lazy-src="https:////upload-images.jianshu.io/upload_images/17223368-d4dc876f1a52d488.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/472/format/webp" alt="img"></p><p>如果能正常运行就证明驱动安装成功</p><p>三、pyCharm设置</p><p>打开pyCharm,点开File-Settings加入selenium，如下图，点+搜索selenium，点Install Package</p><p><img src= "/img/loading1.gif" data-lazy-src="https:////upload-images.jianshu.io/upload_images/17223368-e1a2c5f78a16bf5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1194/format/webp" alt="img"></p><p>二、mac环境搭建</p><p>1.前提</p><p>(1)mac系统自带python2.7，如果你要的是python3版本，需要自己下载安装。</p><p>(2)安装好IDE:pycharm</p><p>(3)安装好chrome浏览器</p><p>(4)下载chromedriver : <a href="http://npm.taobao.org/mirrors/chromedriver/2.36/（放到user/local/bin，打开访达-前往-前往文件夹：输入/usr/local/bin）" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/2.36/（放到user/local/bin，打开访达-前往-前往文件夹：输入/usr/local/bin）</a></p><p>————————————————</p><p>2.安装selenium操作：</p><p>打开终端，输入：sudo pip3 install selenium（python2版本输入sudo pip install selenium） </p><p>打开“终端”方法：</p><p>在 Mac 上，请执行以下一项操作：</p><p>点按程序坞中的“启动台”图标 ，在搜索栏中键入“终端”，然后点按“终端”。</p><p>在“访达”中，打开“/应用程序/实用工具”文件夹，然后连按“终端”，打开。</p><p>导入第三方的包，别人都有file→setting，我这怎么就是没有。也是心累。</p><p>在这里记录一下，免得跟多人入坑</p><p>1、PyCharm→Preferences→Project：项目名→Project Interpreter</p><p><img src= "/img/loading1.gif" data-lazy-src="https:////upload-images.jianshu.io/upload_images/17223368-ea23f8ce76a0c6fc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1003/format/webp" alt="img"></p><p>2、点击这个加号可以导入新的库,点击install，这里以requests库为例</p><p><img src= "/img/loading1.gif" data-lazy-src="https:////upload-images.jianshu.io/upload_images/17223368-2407675f4ef9d068?imageMogr2/auto-orient/strip%7CimageView2/2/w/924/format/webp" alt="img"></p><p>3、查看是否已经存在</p><p><img src= "/img/loading1.gif" data-lazy-src="https:////upload-images.jianshu.io/upload_images/17223368-58d95cbcea9a5638?imageMogr2/auto-orient/strip%7CimageView2/2/w/1003/format/webp" alt="img"></p><p>库已经导入了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
