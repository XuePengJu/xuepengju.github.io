<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏见°の博客</title>
  
  <subtitle>欢迎加入</subtitle>
  <link href="https://xuepengju.github.io/atom.xml" rel="self"/>
  
  <link href="https://xuepengju.github.io/"/>
  <updated>2022-05-05T07:11:34.000Z</updated>
  <id>https://xuepengju.github.io/</id>
  
  <author>
    <name>夏见°</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>02 requests初体验，学习get、post怎么发送请求-使用Python+request做接口测试</title>
    <link href="https://xuepengju.github.io/posts/69423a58/"/>
    <id>https://xuepengju.github.io/posts/69423a58/</id>
    <published>2022-05-05T07:11:34.000Z</published>
    <updated>2022-05-05T07:11:34.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="requests库基本使用"><a href="#requests库基本使用" class="headerlink" title="requests库基本使用"></a>requests库基本使用</h1><p><strong>发送一个请求分3步：</strong></p><ol><li>拼接请求： 请求包含url，params(url参数) [data(请求数据)]  [headers(请求头)] [cookies]等</li><li>发送请求，获取响应：支持get，post等各种方法发送，返回的是一个响应对象</li><li>解析响应: 打印响应内容<a id="more"></a> </li></ol><h3 id="一、一个最简单的GET请求"><a href="#一、一个最简单的GET请求" class="headerlink" title="一、一个最简单的GET请求"></a>一、一个最简单的GET请求</h3><p>打开Pycharm，新建一个demo项目，项目下新建一个Python文件，输入以下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入requests包</span></span><br><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 拼接请求</span></span><br><span class="line">url = <span class="string">"http://httpbin.org/get"</span>  <span class="comment"># 这里只有url，字符串格式</span></span><br><span class="line"><span class="comment"># 2. 发送请求，获取响应</span></span><br><span class="line">res = requests.get(url) <span class="comment"># res即返回的响应对象</span></span><br><span class="line"><span class="comment"># 3. 解析响应，打印相应内容</span></span><br><span class="line">print(res.text)  <span class="comment"># 输出响应的文本</span></span><br></pre></td></tr></table></figure><h3 id="二、带参数的GET请求"><a href="#二、带参数的GET请求" class="headerlink" title="二、带参数的GET请求"></a>二、带参数的GET请求</h3><p>1、请求参数拼接到URL后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://httpbin.org/get?key=ec961279f453&amp;find=helloword"</span>  <span class="comment"># 参数可以写到url里</span></span><br><span class="line">res = requests.get(url=url) <span class="comment"># 第一个url指get方法的参数，第二个url指上一行我们定义的接口地址</span></span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/bb2ea127b4bc43ab8fa90e00acee3641.png" alt="在这里插入图片描述"></p><p>2、请求参数写到params里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://httpbin.org/get"</span></span><br><span class="line">params = &#123;<span class="string">"key"</span>:<span class="string">"ec961279f453"</span>,<span class="string">"find"</span>:<span class="string">"hello word"</span>&#125; <span class="comment"># 字典格式，单独提出来，方便参数的添加修改等操作</span></span><br><span class="line">res = requests.get(url=url, params=params) </span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/6b1e0f23f6de41d39ef20e7e05b9b3df.png" alt="在这里插入图片描述"></p><h3 id="三、传统表单类POST请求（x-www-form-urlencoded）"><a href="#三、传统表单类POST请求（x-www-form-urlencoded）" class="headerlink" title="三、传统表单类POST请求（x-www-form-urlencoded）"></a>三、传统表单类POST请求（x-www-form-urlencoded）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">data = &#123;<span class="string">"name"</span>: <span class="string">"xiajian"</span>, <span class="string">"age"</span>: <span class="number">22</span>&#125;  <span class="comment"># Post请求发送的数据，字典格式</span></span><br><span class="line">res = requests.post(url=url, data=data)  <span class="comment"># 这里使用post方法，参数和get方法一样</span></span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c705000a8b4d40fdaffc0c38902fbaca.png" alt="在这里插入图片描述"></p><h3 id="四、JSON类型的POST请求（application-json）"><a href="#四、JSON类型的POST请求（application-json）" class="headerlink" title="四、JSON类型的POST请求（application/json）"></a>四、JSON类型的POST请求（application/json）</h3><p>1、使用字符串入参去请求post请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://httpbin.org/post"</span></span><br><span class="line"><span class="comment"># 字符串入参</span></span><br><span class="line">data = <span class="string">'''&#123;</span></span><br><span class="line"><span class="string">    "name": "xiajian",</span></span><br><span class="line"><span class="string">    "age": 22</span></span><br><span class="line"><span class="string">            &#125;'''</span>  <span class="comment"># 多行文本, 字符串格式，也可以单行（注意外层有引号，为字符串） data = '&#123;"name": "xiajian", "age": 22&#125;'</span></span><br><span class="line">print(type(data))  <span class="comment"># 打印data数据类型</span></span><br><span class="line">res = requests.post(url=url, data=data)  <span class="comment"># data支持字典或字符串</span></span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/48d84e40caf24c52b6fb6a0fe90c1ffa.png" alt="在这里插入图片描述"></p><blockquote><p>data请求参数支持字典也支持字符串，如果是字典格式，requests方法会将其按照默认表单urlencoded格式转换为字符串，如果是字符串则不转化</p></blockquote><p>如果data以字符串格式传输需要遵循以下几点：</p><ul><li>必须是严格的JSON格式字符串，里面必须用双引号，k-v之间必须有逗号，布尔值必须是小写的true/false等等</li><li>不能有中文，直接传字符串不会自动编码</li></ul><hr><p>2、使用json去请求post请求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://httpbin.org/post"</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"xiajian"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">22</span></span><br><span class="line">&#125;  <span class="comment"># 字典格式，方便添加</span></span><br><span class="line">res = requests.post(url=url, json=data)  <span class="comment"># JSON参数会自动将字典格式转为合法的JSON文本并添加headers</span></span><br><span class="line">print(res.text)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d084c4abbf4d4352847b256b12db63d5.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;requests库基本使用&quot;&gt;&lt;a href=&quot;#requests库基本使用&quot; class=&quot;headerlink&quot; title=&quot;requests库基本使用&quot;&gt;&lt;/a&gt;requests库基本使用&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;发送一个请求分3步：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拼接请求： 请求包含url，params(url参数) [data(请求数据)]  [headers(请求头)] [cookies]等&lt;/li&gt;
&lt;li&gt;发送请求，获取响应：支持get，post等各种方法发送，返回的是一个响应对象&lt;/li&gt;
&lt;li&gt;解析响应: 打印响应内容</summary>
    
    
    
    <category term="Python接口自动化测试" scheme="https://xuepengju.github.io/categories/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Python接口自动化测试" scheme="https://xuepengju.github.io/tags/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>01环境搭建-使用Python+requests做接口测试</title>
    <link href="https://xuepengju.github.io/posts/9d1414ba/"/>
    <id>https://xuepengju.github.io/posts/9d1414ba/</id>
    <published>2022-05-03T15:55:01.000Z</published>
    <updated>2022-05-03T15:55:01.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、为什么使用Python-requests做接口测试"><a href="#一、为什么使用Python-requests做接口测试" class="headerlink" title="一、为什么使用Python+requests做接口测试"></a>一、为什么使用Python+requests做接口测试</h2><p><strong>选用合适的库做接口测试 为什么要重点学习requests模块，而不是urllib</strong></p><ul><li>requests的底层实现就是urllib</li><li>requests在python2 和python3中通用，方法完全一样</li><li>requests简单易用</li><li>Requests能够自动帮助我们解压(gzip压缩的等)响应内容</li><li>Requests：让HTTP服务人类！</li></ul><p>OK，开始愉快的学习requests库吧，在python的标准库中，虽然提供了urllib,utllib2,httplib，但是做接口测试，requests真心好，正如官方说的，“让HTTP服务人类”，一言以蔽之，说明一切，关于它的方法论，这里不是讨论的重点，重点是我们要开始学习它。<a id="more"></a> </p><h2 id="二、安装request库"><a href="#二、安装request库" class="headerlink" title="二、安装request库"></a>二、安装request库</h2><p>安装request库的方式非常简单，安装命令为：</p><pre><code>pip  install requests</code></pre><p><img src="/img/blog/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1651595044388.png" alt="1651595044388"></p><p>看到显示Successfully installed…表示安装成功。</p><p>可以试验下，输入import requests然后回车，没有报错就确认时安装成功了。</p><p><img src="/img/blog/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1651595166002.png" alt="1651595166002"></p><h2 id="三、在Pycharm里面做个小demo体验下"><a href="#三、在Pycharm里面做个小demo体验下" class="headerlink" title="三、在Pycharm里面做个小demo体验下"></a>三、在Pycharm里面做个小demo体验下</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time : 2022/5/5 14:24</span></span><br><span class="line"><span class="comment"># @Author : 夏见。</span></span><br><span class="line"><span class="comment"># @File : test01.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">res = requests.get(<span class="string">'http://httpbin.org/get'</span>)</span><br><span class="line"></span><br><span class="line">print(res.json())</span><br></pre></td></tr></table></figure><p><img src="/img/blog/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/1651732273876.png" alt="1651732273876"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、为什么使用Python-requests做接口测试&quot;&gt;&lt;a href=&quot;#一、为什么使用Python-requests做接口测试&quot; class=&quot;headerlink&quot; title=&quot;一、为什么使用Python+requests做接口测试&quot;&gt;&lt;/a&gt;一、为什么使用Python+requests做接口测试&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;选用合适的库做接口测试 为什么要重点学习requests模块，而不是urllib&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;requests的底层实现就是urllib&lt;/li&gt;
&lt;li&gt;requests在python2 和python3中通用，方法完全一样&lt;/li&gt;
&lt;li&gt;requests简单易用&lt;/li&gt;
&lt;li&gt;Requests能够自动帮助我们解压(gzip压缩的等)响应内容&lt;/li&gt;
&lt;li&gt;Requests：让HTTP服务人类！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OK，开始愉快的学习requests库吧，在python的标准库中，虽然提供了urllib,utllib2,httplib，但是做接口测试，requests真心好，正如官方说的，“让HTTP服务人类”，一言以蔽之，说明一切，关于它的方法论，这里不是讨论的重点，重点是我们要开始学习它。</summary>
    
    
    
    <category term="Python接口自动化测试" scheme="https://xuepengju.github.io/categories/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="Python接口自动化测试" scheme="https://xuepengju.github.io/tags/Python%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试21-读取外部文件进行数据参数化</title>
    <link href="https://xuepengju.github.io/posts/f46b70d8/"/>
    <id>https://xuepengju.github.io/posts/f46b70d8/</id>
    <published>2022-02-27T13:11:53.000Z</published>
    <updated>2022-02-27T13:11:53.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>测试过程中，常会遇到一个接口要验证很多的测试<a href="/posts/f46b70d8/">数据</a>，而所输入的参数和验证的参数又几乎是一样的。这样我们就会首先想到数据参数化，在postman中也提供了数据参数化功能。 <a id="more"></a> 它需要把数据单独的存放在一个文件中管理，然后通过读取这个文件实现所有的数据的验证，具体如下：</p><h3 id="实现步骤-。"><a href="#实现步骤-。" class="headerlink" title="实现步骤 。"></a>实现步骤 。</h3><ol><li>创建数据文件，支持数据格式文件分别为<a href="/posts/f46b70d8/">csv</a>和接送</li><li>请求中替换<a href="/posts/f46b70d8/">参数</a>变量，定义到文件中的参数名需要在请求中替换<ul><li>请求参数中替换通过:{undefined{参数名}}</li><li>代码中替换通过:data.参数名</li></ul></li><li>通过Runner-Data读取数据文件来运行。</li></ol><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><ul><li>请求天气接口，输入不同的城市id，会返回不同的城市和天气情况 ，需对返回城市和天气进行验证 。</li></ul><h5 id="1-创建city-json-或-city-json-格式如下"><a href="#1-创建city-json-或-city-json-格式如下" class="headerlink" title="1.创建city.json 或 city.json ,格式如下"></a>1.创建city.json 或 city.json ,格式如下</h5><p>   <img src="/img/blog/postman/21/021-01.png" alt="img"></p><p>   <img src="/img/blog/postman/21/021-02.png" alt="img"></p><p>​    </p><h5 id="2-在请求中替换参数：city-id-city-weather"><a href="#2-在请求中替换参数：city-id-city-weather" class="headerlink" title="2.在请求中替换参数：city_id,city,weather ."></a>2.在请求中替换参数：city_id,city,weather .</h5><blockquote><p>其中city_id在<a href="/posts/f46b70d8/">URL</a>中替换，故通过{undefined{}}替换 。</p><p>city和weather在Tests中替换，需要通过data.city , data.weather</p></blockquote><p>   <img src="/img/blog/postman/21/021-03.png" alt="img"></p><p>​    </p><h5 id="3-选择数据文件导入"><a href="#3-选择数据文件导入" class="headerlink" title="3.选择数据文件导入"></a>3.选择数据文件导入</h5><p><img src="/img/blog/postman/21/021-04.png" alt="img"></p><h5 id="4-查询运行结果"><a href="#4-查询运行结果" class="headerlink" title="4.查询运行结果"></a>4.查询运行结果</h5><p><img src="/img/blog/postman/21/021-05.png" alt="img"></p><p>需要说明的是，通过数据参数化的脚本，就不能通过点击Send按钮正常去发送请求验证了，如果点击Send按钮，脚本读取不到参数会报错 。 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;测试过程中，常会遇到一个接口要验证很多的测试&lt;a href=&quot;/posts/f46b70d8/&quot;&gt;数据&lt;/a&gt;，而所输入的参数和验证的参数又几乎是一样的。这样我们就会首先想到数据参数化，在postman中也提供了数据参数化功能。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试20-建立工作流</title>
    <link href="https://xuepengju.github.io/posts/ab3b7c7/"/>
    <id>https://xuepengju.github.io/posts/ab3b7c7/</id>
    <published>2022-02-27T11:00:43.000Z</published>
    <updated>2022-02-27T11:00:43.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在前面讲的Runner，如果运行集合中的请求，则是按照顺序运行所有请求 。 <a id="more"></a> 如下图，有4个请求，通过runner运行的话，会顺序这4个请求 。</p><p><img src="/img/blog/postman/20/020-01.png" alt="img"></p><p>接下来要学习的这个功能，在脚本中就可以控制脚本的执行顺序，我们来看下这个函数：postman.setNextRequest()，它需要带一个参数 。该参数是要运行的请求名称或ID 。这个函数的功能可以控制请求的执行顺序。</p><hr><p><strong>案例</strong>：在登录用例中添加setNextRequest() ，判断登录接口返回值当code=0，就直接请求充值接口。<br>再次运行该集合，运行完登录接口，</p><ul><li><p>当code=0，就会直接请求充值接口 ，只会运行3个接口，会跳过注册接口<br><img src="/img/blog/postman/20/020-02.png" alt="img"></p></li><li><p>当code!=0，就会请求注册接口然后依次执行<br><img src="/img/blog/postman/20/020-03.png" alt="img"></p></li></ul><p>同样的4个请求，在接口中添加了postman.setNextRequest(“xxx”)功能后，执行完这个接口就会执行指定的接口，会跳过中间的接口 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面讲的Runner，如果运行集合中的请求，则是按照顺序运行所有请求 。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试19-Collection-Runner</title>
    <link href="https://xuepengju.github.io/posts/6556c33b/"/>
    <id>https://xuepengju.github.io/posts/6556c33b/</id>
    <published>2022-02-27T10:44:07.000Z</published>
    <updated>2022-02-27T10:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>经常我们要把编写好的用例进行回归测试，这时我们就可以通过Runner来选择我们要运行的测试集进行回归。</p></blockquote> <a id="more"></a> <p>进入Runner有俩个入口，第一个就是选择一个<font color="#CD7F32">集合</font> ，点击右三角进入（批量执行用例），第二个就是在postman的导航栏左侧 （如图），打开的界面如下。</p><p><img src="/img/blog/postman/19/019-01.png" alt="img"></p><p><img src="/img/blog/postman/19/019-02.png" alt="img"></p><p>功能说明：</p><ul><li>All Collections : 列出所有集合，可以选择一个集合运行</li><li>Environment : 环境列表 ，当选择的集合使用到了环境，这里就必须选择 ,反之，可不选。</li><li>Iterations :迭代次数，这里面更多的使用场景读取外部文件进行参数化 。当然一个集合也可以重复运行。</li><li>Delay ：请求间的间隔时间，默认为0也就是没有间隔 。</li><li>Data ： 读取数据文件进行参数化的选项 。</li><li>Save Seponses : 保存响应数据，默认情况不开启 ，但是当集合中有请求报错时，我们打开此选项 。就可以在Run Result查看每个请求的响应结果 。</li><li>keep variable values : 持久变量，默认为开启状态，开启后，前面请求的变量设置的值，后面有请求修改此值，会覆盖此值 。</li><li>run collection without using stord cookies : 不使用cookies保存的值运行</li><li>Save cookies after collection run : 集合中的请求在执行期间创建/更新cookie 。打开此选项，可以将cookie保存到cookie管理器，从而覆盖任何现有的cookie。</li><li>Recent RUN ：右侧是保存了最近运行的结果，可以点击打开查看 。也可以下载 和删除 。</li><li>Import/Export :可以将运行结果导出后再导入结果进行查看 。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;经常我们要把编写好的用例进行回归测试，这时我们就可以通过Runner来选择我们要运行的测试集进行回归。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试18-动态变量</title>
    <link href="https://xuepengju.github.io/posts/69ae7450/"/>
    <id>https://xuepengju.github.io/posts/69ae7450/</id>
    <published>2022-02-26T15:31:48.000Z</published>
    <updated>2022-02-26T15:31:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p> 动态变量列表，其动态值在请求运行期间随机生成 。随机生成的值可用于请求的参数值 。</p></blockquote> <a id="more"></a> 要想使用动态变量，必须使用：pm.variables.replaceIn(),<h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><pre><code>pm.variables.replaceIn(‘{undefined{$randomFirstName}}’), </code></pre><p>需要注意的是，只能在前置脚本或断言中使用动态变量 。</p><h3 id="postman内置了非常多的动态变量，下面就列出一些常用的变量。"><a href="#postman内置了非常多的动态变量，下面就列出一些常用的变量。" class="headerlink" title="postman内置了非常多的动态变量，下面就列出一些常用的变量。"></a>postman内置了非常多的动态变量，下面就列出一些常用的变量。</h3><table><thead><tr><th align="left">变量名</th><th align="left"><code>描述....................</code></th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">$guid</td><td align="left">一个uuid-v4风格GUID</td><td align="left">“611c2e81-2ccb-42d8-9ddc-2d0bfa65c1b4”</td></tr><tr><td align="left">$timestamp</td><td align="left">当前UNIX时间戳(以秒为单元)</td><td align="left">1562757107</td></tr><tr><td align="left">$randomUUID</td><td align="left">随机的36个字符的UUID</td><td align="left">“6929bb52-3ab2-448a-9796-d6480ecad36b”</td></tr><tr><td align="left">$randomAlphaNumeric</td><td align="left">随机字母数字字符</td><td align="left">6<code>，</code>“y”<code>，</code>“z”</td></tr><tr><td align="left">$randomBoolean</td><td align="left">随机布尔值（真/假）</td><td align="left">true,false</td></tr><tr><td align="left">$randomInt</td><td align="left">1到1000之间的随机整数</td><td align="left">302,454,921</td></tr><tr><td align="left">$randomIP</td><td align="left">随机的IPV4地址</td><td align="left">241.102.234.100<code>，</code>216.7.27.38</td></tr><tr><td align="left">$randomPassword</td><td align="left">随机的15个字符的字母数字密码</td><td align="left">t9iXe7COoDKv8k3<code>，</code>QAzNFQtvR9cg2rq</td></tr><tr><td align="left">$randomUserAgent</td><td align="left">随机用户代理</td><td align="left">Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.9.8; rv:15.6) Gecko/20100101 Firefox/15.6.6</td></tr><tr><td align="left">$randomFirstName</td><td align="left">随机名字</td><td align="left">Ethan<code>，</code>Chandler<code>，</code>Megane</td></tr><tr><td align="left"><strong><code>$randomLastName</code></strong></td><td align="left">随机姓氏</td><td align="left"><code>Schaden</code>，<code>Schneider</code>，<code>Willms</code></td></tr><tr><td align="left"><strong><code>$randomFullName</code></strong></td><td align="left">随机的名字和姓氏</td><td align="left"><code>Connie Runolfsdottir</code>，<code>Sylvan Fay</code>，<code>Jonathon Kunze</code></td></tr><tr><td align="left"><strong><code>$randomNamePrefix</code></strong></td><td align="left">随机名称前缀</td><td align="left"><code>Dr.</code>，<code>Ms.</code>，<code>Mr.</code></td></tr><tr><td align="left"><strong><code>$randomNameSuffix</code></strong></td><td align="left">随机名称后缀</td><td align="left"><code>I</code>，<code>MD</code>，<code>DDS</code></td></tr><tr><td align="left"><strong><code>$randomAvatarImage</code></strong></td><td align="left">随机头像</td><td align="left"><code>https://s3.amazonaws.com/uifaces/faces/twitter/johnsmithagency/128.jpg</code></td></tr><tr><td align="left"><strong><code>$randomWeekday</code></strong></td><td align="left">随机工作日</td><td align="left"><code>Thursday</code>，<code>Friday</code>，<code>Monday</code></td></tr><tr><td align="left"><strong><code>$randomMonth</code></strong></td><td align="left">随机月份</td><td align="left"><code>February</code>，<code>May</code>，<code>January</code></td></tr><tr><td align="left"><strong><code>$randomDomainName</code></strong></td><td align="left">随机域名</td><td align="left"><code>gracie.biz</code>，<code>armando.biz</code>，<code>trevor.info</code></td></tr><tr><td align="left"><strong><code>$randomEmail</code></strong></td><td align="left">随机电子邮件地址</td><td align="left"><code>Pablo62@gmail.com</code>，<code>Ruthe42@hotmail.com</code>，<code>Iva.Kovacek61@hotmail.com</code></td></tr><tr><td align="left"><strong><code>$randomUserName</code></strong></td><td align="left">随机用户名</td><td align="left"><code>Jarrell.Gutkowski</code>，<code>Lottie.Smitham24</code>，<code>Alia99</code></td></tr><tr><td align="left"><strong><code>$randomUrl</code></strong></td><td align="left">随机网址</td><td align="left"><code>https://anais.net</code>，<code>https://tristin.net</code>，<code>http://jakob.name</code></td></tr></tbody></table><p>接下来通过一张图来展示生成的随机数 。</p><p> <img src="/img/blog/postman/18/018-01.png" alt="img"> </p><p> 很多请求输入的参数值，填写的是固定的，如果想每次请求生成随机数，就可以用这个动态变量 。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 动态变量列表，其动态值在请求运行期间随机生成 。随机生成的值可用于请求的参数值 。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试17-pm对象解析</title>
    <link href="https://xuepengju.github.io/posts/22131793/"/>
    <id>https://xuepengju.github.io/posts/22131793/</id>
    <published>2022-02-26T05:16:11.000Z</published>
    <updated>2022-02-26T05:16:11.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>pm对象包含了正在执行的脚本有关的所有信息，并允许一个对象访问正在发送的请求或已收到的响应数据。它还允许设置环境和全局变量 。 <a id="more"></a> </p></blockquote><h2 id="1-pm-sendRequest"><a href="#1-pm-sendRequest" class="headerlink" title="1.pm.sendRequest:"></a>1.pm.sendRequest:</h2><p>该功能允许发送HTTP/HTTPS请求。并且要求在Pre-request Script或Tests标签中使用。</p><p>发送一个get请求</p><p>//发送一个get请求，请求成功后设置一个环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pm.sendRequest(&#39;http:&#x2F;&#x2F;cx.shouji.360.cn&#x2F;phonearea.php?number&#x3D;13012345678&#39;, function (err, res) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        pm.environment.set(&quot;xab&quot;, &quot;123&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>发送一个post请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const PostRequest &#x3D; &#123;</span><br><span class="line">  url: &#39;http:&#x2F;&#x2F;ihrm-test.itheima.net&#x2F;api&#x2F;sys&#x2F;login&#39;,</span><br><span class="line">  method: &#39;POST&#39;,</span><br><span class="line">  header: &#39;Content-Type:application&#x2F;json&#39;,</span><br><span class="line">  body: &#123;</span><br><span class="line">    mode: &#39;raw&#39;,</span><br><span class="line">    raw: JSON.stringify(&#123; &quot;mobile&quot;: &#39;13800000002&#39;,&quot;password&quot;:&quot;123456&quot; &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">pm.sendRequest(PostRequest, function (err, res) &#123;</span><br><span class="line">  console.log(err ? err : res.json());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>发送的请求中添加断言</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pm.sendRequest(&#39;https:&#x2F;&#x2F;www.baidu.com&#39;, function (err, res) &#123;</span><br><span class="line">  if (err) &#123; console.log(err); &#125;</span><br><span class="line">  pm.test(&#39;断言响应数据&#39;, function () &#123;</span><br><span class="line">    pm.expect(err).to.equal(null);</span><br><span class="line">    pm.expect(res).to.have.property(&#39;code&#39;, 200);</span><br><span class="line">    pm.expect(res).to.have.property(&#39;status&#39;, &#39;OK&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个功能也非常的有用，具体使用场景我们在后面的章节后详细介绍 。</p><h2 id="2-pm-variables"><a href="#2-pm-variables" class="headerlink" title="2.pm.variables"></a>2.pm.variables</h2><p>局部变量，作用范围更小，定义的变量想要在一个请求中使用，就可以使用这个变量 。</p><ul><li><p>pm.variables.has(“var_name”) ：检查当前作用域内是否存在变量var_name，返回boolean类型</p></li><li><p>pm.variables.get(“var_name”) ：获取局部变量var_name的值</p></li><li><p>pm.variables.set(“var_name”, “value”) : 设置局部变量var_name的值为value</p></li><li><p>pm.variables.toObject() ：返回包含本地范围内所有变量的对象</p></li></ul><h2 id="3-pm-environment"><a href="#3-pm-environment" class="headerlink" title="3.pm.environment"></a>3.pm.environment</h2><p>环境变量，如果某个集合导入环境后，该集合下的请求都可以使用环境变量 。</p><ul><li><p>pm.environment.name : 获取当前环境的名字</p></li><li><p>pm.environment.has(“var_name”):检查环境变量中是否存在变量var_name，返回boolean类型。</p></li><li><p>pm.environment.get(“var_name”) :获取环境变量var_name的值</p></li><li><p>pm.environment.set(“var_name”,”value”) :设置环境变量var_name的值为value</p></li><li><p>pm.environment.replaceIn(“var_name”) :将动态变量语法替换为其实际的解析值</p></li><li><p>pm.environment.toObject() :以单个对象的形式返回所有环境变量</p></li><li><p>pm.environment.unset(“var_name”) 在当前选定的环境中删除具有给定名称的变量。</p></li><li><p>pm.environment.clear() : 清除当前所选环境中的所有变量。</p></li></ul><h2 id="4-pm-collectionVariables"><a href="#4-pm-collectionVariables" class="headerlink" title="4.pm.collectionVariables"></a>4.pm.collectionVariables</h2><p>集合变量，只是针对集合有效的变量 。</p><ul><li><p>pm.collectionVariables.has(“var_name”) :检查集合变量中是否存在变量var_name，返回boolean类型</p></li><li><p>pm.collectionVariables.get(“var_name”) : 获取集合变量var_name的值</p></li><li><p>pm.collectionVariables.set(“var_name”, “value”) :设置集合变量var_name的值为value</p></li><li><p>pm.collectionVariables.replaceIn(“var_name”) :将动态变量语法替换为其实际的解析值</p></li><li><p>pm.collectionVariables.toObject():以对象的形式返回变量及其值的列表。</p></li><li><p>pm.collectionVariables.unset(“var_name”) : 清除指定的集合变量</p></li><li><p>pm.collectionVariables.clear() : 清除所有集合变量。</p></li></ul><h2 id="5-pm-globals"><a href="#5-pm-globals" class="headerlink" title="5.pm.globals"></a>5.pm.globals</h2><p>全局变量，只要申明了全局变量，对postman工具内的任何请求和集合都有效 。</p><ul><li><p>pm.globals.has(“var_name”) : 检查全局变量中是否存在变量var_name，返回boolean类型</p></li><li><p>pm.globals.get(“var_name”) ： 获取全局变量var_name的值</p></li><li><p>pm.globals.set(“var_name”, “value”) : 设置全局变量var_name的值为value</p></li><li><p>pm.globals.replaceIn(“var_name”) : 将动态变量语法替换为其实际的解析值</p></li><li><p>pm.globals.toObject() : 以对象的形式返回变量及其值的列表。</p></li><li><p>pm.globals.unset(“var_name”) : 清除指定的全局变量。</p></li><li><p>pm.globals.clear() :清除所有全局变量。</p></li></ul><h2 id="6-pm-request"><a href="#6-pm-request" class="headerlink" title="6.pm.request"></a>6.pm.request</h2><p>request为脚本执行请求。对于前置脚本，这是将要发送的请求，在测试脚本中，这是已发送的请求 。</p><p>request包含以下结构信息：</p><ul><li><p>pm.requests.url: 包含发出请求的URL，返回json数据，主要包括了url中的protocol,host,path,query,variable部分 。可以通过.解析出每一部分 。</p></li><li><p>pm.request.headers ：包含发送请求的headers ，返回列表数据 。</p></li><li><p>pm.request.method ： 发送的请求方法</p></li><li><p>pm.request.body ：包含与请求正文相关的所有数据</p></li><li><p>pm.request.headers.add(headerName）：为当前请求添加请求头headerName</p></li><li><p>pm.request.headers.remove (headerName)：删除请求头中的headerName</p></li><li><p>pm.request.headers.upsert({ key: headerName:String, value: headerValue:String}) : 插入给定当前请求的键值对 。（如果该键不存在，否则将已存在的键值更新为新值）</p></li></ul><h2 id="7-pm-response"><a href="#7-pm-response" class="headerlink" title="7.pm.response"></a>7.pm.response</h2><p>pm.response对象包含与收到的响应有关的所有信息 。响应信息格式如下：</p><ul><li><p>pm.response.code : 返回响应状态码</p></li><li><p>pm.response.status : 返回响应状态消息</p></li><li><p>pm.response.headers：返回响应头</p></li><li><p>pm.response.responseTime ： 返回响应时间</p></li><li><p>pm.response.responseSize： 返回响应大小</p></li><li><p>pm.response.text()：返回响应体的文本数据</p></li><li><p>pm.response.json() ：返回响应体的json数据</p></li></ul><h2 id="8-pm-test"><a href="#8-pm-test" class="headerlink" title="8.pm.test"></a>8.pm.test</h2><p>格式：pm.test(testName:String, specFunction:Function)</p><p>我们可以使用此方法在Pre-request Script 或Tests标签中，即使该方法内部存在错误，也可以确保脚本的其余部分不会被阻塞。</p><p>示例：</p><p>测试异步：done可以将可选的回调添加到pm.test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> pm.test(&#39;async test&#39;, function (done) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        pm.expect(pm.response.code).to.equal(200);</span><br><span class="line">        done();</span><br><span class="line">    &#125;, 1500);</span><br><span class="line">  &#125;);</span><br><span class="line">pm.test.index() ：从特定位置获取总数测试</span><br></pre></td></tr></table></figure><h2 id="9-pm-expect"><a href="#9-pm-expect" class="headerlink" title="9.pm.expect"></a>9.pm.expect</h2><p>格式：pm.expect(assertion:*)</p><p>pm.expect是一个通用的断言函数。这是ChaiJS期望的BDD库的基础。使用该库，可以很容易地编写语法易读的测试。</p><p>此功能对于处理来自response或的数据断言很有用variables。有关使用的断言测试示例pm.expect。</p><p>测试脚本中提供了Response Assertion API</p><ul><li><p>pm.response.to.have.status(code:Number)</p></li><li><p>pm.response.to.have.status(reason:String)</p></li><li><p>pm.response.to.have.header(key:String)</p></li><li><p>pm.response.to.have.header(key:String, optionalValue:String)</p></li><li><p>pm.response.to.have.body()</p></li><li><p>pm.response.to.have.body(optionalValue:String)</p></li><li><p>pm.response.to.have.body(optionalValue:RegExp)</p></li><li><p>pm.response.to.have.jsonBody()</p></li><li><p>pm.response.to.have.jsonBody(optionalExpectEqual:Object)</p></li><li><p>pm.response.to.have.jsonBody(optionalExpectPath:String)</p></li><li><p>pm.response.to.have.jsonBody(optionalExpectPath:String, optionalValue:*)</p></li><li><p>pm.response.to.have.jsonSchema(schema:Object)</p></li><li><p>pm.response.to.have.jsonSchema(schema:Object, ajvOptions:Object)</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;pm对象包含了正在执行的脚本有关的所有信息，并允许一个对象访问正在发送的请求或已收到的响应数据。它还允许设置环境和全局变量 。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试16-生成测试报告</title>
    <link href="https://xuepengju.github.io/posts/43b8c324/"/>
    <id>https://xuepengju.github.io/posts/43b8c324/</id>
    <published>2022-02-20T08:54:38.000Z</published>
    <updated>2022-02-20T08:54:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="生成测试报告"><a href="#生成测试报告" class="headerlink" title="生成测试报告"></a>生成测试报告</h1><p>postman生成测试报告需要一个插件：newman ，并且这个插件需要先安装 。 <a id="more"></a> </p><h2 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h2><ol><li><p>安装nodejs: newman是由nodejs开发，所以要先安装它的运行环境，下载地址：<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">http://nodejs.cn/download/</a> 。安装成功后需要验证：在cmd窗口中输入node -v,如果输出node的版本信息，则证明安装成功。</p></li><li><p>安装newman：安装成功nodejs后，会自动安装一个包管理工具npm(类似于python中的pip)。通过它就可以直接安装newman。 打开cmd窗口输入：npm install -g newman .安装成功后进行验证：newman -v 。如果输出newman的版本信息，则证明安装成功 。</p></li><li><p>安装newman-reporter-html:通过这个插件可以指定报告的生成路径和名称。同样打开cmd窗口输入：npm install -g newman-reporter-html.安装成功后进行验证：npm list -g –depth 0.如果能出现newman-reporter-html包及版本及证明安装成功 。</p></li></ol><p>通过newman生成测试报告必须在cmd执行，命令执行：newman run <collection> [options] ，其中options中有很多参数，接下来我们来解析这些参数。</p><h3 id="命令解析："><a href="#命令解析：" class="headerlink" title="命令解析："></a>命令解析：</h3><ul><li><p>-e : 可选，指定一个URL或者postman的环境变量脚本文件。如果集合中指定了环境变量，则需要添加这个参数。</p></li><li><p>-g：可选，指定一个URL或者postman的全局变量脚本文件，如果集合中指定了全局变量，则需要加这个参数 。</p></li><li><p>-r：可选，指定测试报告的类型，如果想生成对应的报告类型，需要添加这个参数，典型的有html,json,cli，若不添加，默认为cli。</p></li><li><p>-d：可选，指定一个数据参数化文件 ，如果有参数化文件，需要添加这个选项。</p></li><li><p>–reporter-html-export：可选，指定生成报告的路径和文件名，如果不添加该参数，默认会生成一个newman的文件夹，里面存放着生成的测试报告</p></li></ul><p>输入的命令就可以是下面这样的 。</p><blockquote><p>newman run collect_a.json [-e environment_b.json] [-r html] [–reporter-html-export report.html]  其中[]内的参数是可选的。</p></blockquote><h3 id="案例说明："><a href="#案例说明：" class="headerlink" title="案例说明："></a>案例说明：</h3><h4 id="案例1：通过newman生成测试报告，集合为一个URL。"><a href="#案例1：通过newman生成测试报告，集合为一个URL。" class="headerlink" title="案例1：通过newman生成测试报告，集合为一个URL。"></a>案例1：通过newman生成测试报告，集合为一个URL。</h4><h5 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newman run https:&#x2F;&#x2F;www.getpostman.com&#x2F;collections&#x2F;6e95413b91fe582ec78d</span><br></pre></td></tr></table></figure><p>说明：run后面跟的链接可以通过分享得到</p><h4 id="案例2：通过newman生成测试报告，报告格式为默认-cli"><a href="#案例2：通过newman生成测试报告，报告格式为默认-cli" class="headerlink" title="案例2：通过newman生成测试报告，报告格式为默认:cli"></a>案例2：通过newman生成测试报告，报告格式为默认:cli</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newman run A.postman_collection.json  -r cli &#x2F;&#x2F;默认的展示结果如下图所示。</span><br></pre></td></tr></table></figure><p><img src="/img/blog/postman/16/016-01.png" alt="img"></p><h4 id="案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告-。"><a href="#案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告-。" class="headerlink" title="案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告 。"></a>案例3：通过newman生成测试报告，需要添加环境变量文件，并且生成HTML报告 。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newman run B.postman_collection.json -e test.postman_environment.json -r html</span><br></pre></td></tr></table></figure><h4 id="案例4：通过newman生成测试报告，需要制定报告路径和文件名称。"><a href="#案例4：通过newman生成测试报告，需要制定报告路径和文件名称。" class="headerlink" title="案例4：通过newman生成测试报告，需要制定报告路径和文件名称。"></a>案例4：通过newman生成测试报告，需要制定报告路径和文件名称。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newman run B.postman_collection.json -e test.postman_environment.json -r html --reporter-html-export report.html</span><br></pre></td></tr></table></figure><p>//生成的测试报告会存放在当前路径下，报告名为：report.html</p><blockquote><p>虽然newman提供了强大的生成测试报告功能，但是目前为止，生成的测试报告都是在我们本地，那如果想要把报告展示给团队成员查看呢 ？ 我们就可以通过jenkins进行持续集成，把生成的报告展示在Jenkins上，甚至可以将报告通过邮件发送给团队成员 。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;生成测试报告&quot;&gt;&lt;a href=&quot;#生成测试报告&quot; class=&quot;headerlink&quot; title=&quot;生成测试报告&quot;&gt;&lt;/a&gt;生成测试报告&lt;/h1&gt;&lt;p&gt;postman生成测试报告需要一个插件：newman ，并且这个插件需要先安装 。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试15-快速查询与替换</title>
    <link href="https://xuepengju.github.io/posts/f5e730b6/"/>
    <id>https://xuepengju.github.io/posts/f5e730b6/</id>
    <published>2022-02-16T14:47:59.000Z</published>
    <updated>2022-02-16T14:47:59.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>有时候我们常会遇到这样一种问题，系统中有太多的用例，环境变量和系统变量的值也太多，查找其中的某个值太不方便；或者有的值想要修改，但苦于修改的地方太多，修改起来太费劲。那么，针对这样的困扰，是否有办法解决呢 ？ 答案是有的 ，那就是快速查询与批量替换。 <a id="more"></a> </p><p>接下来我们先来了解这个功能的入口和简单介绍。</p><p> <img src="/img/blog/postman/15/015-01.png" alt="img"></p><h3 id="功能介绍："><a href="#功能介绍：" class="headerlink" title="功能介绍："></a>功能介绍：</h3><p>FIND:搜索输入框，在搜索框中输入你想要搜索的值，postman会自动到已打开的请求，集合，环境变量，全局变量中去搜索，如果搜索到，就会在右侧展示出搜素的结果 。其下方有俩个复选框，分别是Regex(正则匹配)和Ignore Case(忽略大小写)。</p><p>WHERE:带条件查询，默认会选择everything（查询所有），如果想要选择某一个tab搜索，从下面选择即可，可以支持从集合、环境变量、全局变量以及以打开的请求中搜索 。</p><p>REPLACE WITH: 替换文本框，在此文本框中输入替换的值，点击Replace in … 按钮，会将搜索出的值全部替换 。</p><p>右侧的搜索结果：搜索出对应的结果后，右侧每个tab中都会显示具体的数字，代表当前tab中匹配值的数量。你可以选择一个值点击Open，就会直接进入到对应的功能选项卡中 。</p><h3 id="案例说明："><a href="#案例说明：" class="headerlink" title="案例说明："></a>案例说明：</h3><h5 id="案例1：按照正则表达式搜索11位数字。"><a href="#案例1：按照正则表达式搜索11位数字。" class="headerlink" title="案例1：按照正则表达式搜索11位数字。"></a>案例1：按照正则表达式搜索11位数字。</h5><p>操作步骤：在搜索框中输入\d{11}，勾选Regex,点击Find，右侧就会展示出还有11位数字的所有信息。</p><p><img src="/img/blog/postman/15/015-02.png" alt="img"></p><h5 id="案例2：从集合中搜索"><a href="#案例2：从集合中搜索" class="headerlink" title="案例2：从集合中搜索"></a>案例2：从集合中搜索</h5><p>在搜索框中输入搜索关键字，</p><p>在WHERE中选择Choose entities to find in，选中Collections 。</p><p>找到你想要的结果，点击Open in builder。就会直接打开对应请求tab.</p><p><img src="/img/blog/postman/15/015-03.png" alt="img"></p><h5 id="案例3：替换某个字符串"><a href="#案例3：替换某个字符串" class="headerlink" title="案例3：替换某个字符串"></a>案例3：替换某个字符串</h5><p>在查找搜索框中输入关键字，</p><p>在REPLACE WITH框中输入想要替换的值，可以选择select All ,点击后面的按钮。</p><p>再次搜索替换后的结果，发现所有值都已被替换 。</p><p><img src="/img/blog/postman/15/015-04.png" alt="img"></p><blockquote><p> 总之，通过这个功能，我们可以快速找到我们想要的集合，环境变量，全局变量，请求或者代码块。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时候我们常会遇到这样一种问题，系统中有太多的用例，环境变量和系统变量的值也太多，查找其中的某个值太不方便；或者有的值想要修改，但苦于修改的地方太多，修改起来太费劲。那么，针对这样的困扰，是否有办法解决呢 ？ 答案是有的 ，那就是快速查询与批量替换。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试14-导入导出</title>
    <link href="https://xuepengju.github.io/posts/6172e27e/"/>
    <id>https://xuepengju.github.io/posts/6172e27e/</id>
    <published>2022-02-15T14:59:55.000Z</published>
    <updated>2022-02-15T14:59:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这又是一个非常实用的功能。可以将postman中的集合脚本，环境变量、全局变量导出，然后分享到团队成员，也可以通过导出后的脚本通过newman生成测试报告。更牛的是可以把浏览器，抓包工具，接口文档(swagger)中的数据包导入到postman中，并且会自动生成一个请求 。非常非常的方便 。 <a id="more"></a> </p><h2 id="1-导出"><a href="#1-导出" class="headerlink" title="1.导出"></a>1.导出</h2><h3 id="导出集合脚本"><a href="#导出集合脚本" class="headerlink" title="导出集合脚本"></a>导出集合脚本</h3><p>选择其中一个集合，点击右边的三个点（…）,选择‘export’.</p><p>在弹出的对话框Collection v2.1(recommended),点击‘Export’ .</p><p>选择本地路径保存即可，默认导入的文件格式是json且文件名中含有Collection,这样能区分出是集合文件 。</p><h3 id="导出环境-全局变量"><a href="#导出环境-全局变量" class="headerlink" title="导出环境/全局变量"></a>导出环境/全局变量</h3><p>选择右上角的小齿轮(MANAGE ENVIRONMENT)，</p><p>如果是选择环境变量导出，只需要在点击对应环境的下载图标</p><p>如果是选择全局变量导出，点击Globals,再点击Download as JSON .</p><p>选择本地路径保存即可，默认导出的文件格式是json文件名找那个含有environemnt或globals，可以区分出这是环境变量文件或全局变量文件</p><p> <img src="/img/blog/postman/14/014-01.png" alt="img"> </p><p>简单来说，导出后的文件主要就是以下几个目的：</p><p>​    分享给团队成员</p><p>​    生成测试报告</p><p>​    数据备份</p><h2 id="2-导入"><a href="#2-导入" class="headerlink" title="2.导入"></a>2.导入</h2><p>导入有四个选项，支持从文件导入，文件夹导入，从链接导入，粘贴文本导入。导入的入口：</p><p> <img src="/img/blog/postman/14/014-02.png" alt="img"> </p><h3 id="Import-File：从文件导入"><a href="#Import-File：从文件导入" class="headerlink" title="Import File：从文件导入"></a>Import File：从文件导入</h3><p>可以支持集合文件导入，环境/全局变量文件导入(json)，通过抓包工具保存的请求文件导入 。</p><p>无论是导入集合文件还是变量文件，都需要提前把对应的文件导出 。 当然此功能的使用场景就是团队成员相互分享脚本 。</p><p>  <img src="/img/blog/postman/14/014-03.png" alt="img"> </p><h3 id="导入fiddler数据："><a href="#导入fiddler数据：" class="headerlink" title="导入fiddler数据："></a>导入fiddler数据：</h3><p>可以将fiddler的抓取到的数据包导出，然后在postman中导入，就会在postman自动生成请求，无需任何修改 。具体实现步骤如下：</p><p>从fiddler中选择一个请求，然后导出脚本文件 。</p><p>在postman中的import File 中导入即可</p><p>会自动将请求转变成postman脚本。</p><p> <img src="/img/blog/postman/14/014-04.png" alt="img"> </p><p> <img src="/img/blog/postman/14/014-05.png" alt="img"> </p><p> <img src="/img/blog/postman/14/014-06.png" alt="img"> </p><h3 id="Import-Folder：选择从文件夹导入。"><a href="#Import-Folder：选择从文件夹导入。" class="headerlink" title="Import Folder：选择从文件夹导入。"></a>Import Folder：选择从文件夹导入。</h3><p>有时候我们导出的集合需要用到环境变量，所以，需要把集合文件和环境变量文件都要导出，把它们放在一个文件夹下，如团队成员需要时，可以选择Import Folder直接一次性都导入即可。</p><h3 id="Import-From-Link：通过链接导入也可以将集合分享给团队成员。"><a href="#Import-From-Link：通过链接导入也可以将集合分享给团队成员。" class="headerlink" title="Import From Link：通过链接导入也可以将集合分享给团队成员。"></a>Import From Link：通过链接导入也可以将集合分享给团队成员。</h3><p>但 使用这个功能需要先注册账号且登录才可以 。具体实现步骤如下 ：</p><p>选择一个集合，点击分享</p><p> <img src="/img/blog/postman/14/014-07.png" alt="img"> </p><p>在弹出的界面点击Get public link</p><p> <img src="/img/blog/postman/14/014-08.png" alt="img"></p><p> <img src="/img/blog/postman/14/014-09.png" alt="img">  </p><p> 选择Import-Import From Link 进行导入</p><p> <img src="/img/blog/postman/14/014-10.png" alt="img"> </p><p>Paste Raw Text：这个功能可以将浏览器的数据包或接口文档（swagger）的数据粘贴进来自动生成请求 ，无需任何修改，就可以直接发送请求 。非常的赞 。</p><p>实现步骤：</p><p>在浏览器中抓取到想要的包，然后右键copy出Curl的数据包</p><p>在postman的import中将数据粘贴进来，就会自动生成了对应的请求 。</p><p>  <img src="/img/blog/postman/14/014-11.png" alt="img"> </p><p> <img src="/img/blog/postman/14/014-12.png" alt="img"> </p><p> <img src="/img/blog/postman/14/014-13.png" alt="img"> </p><p>下面的这个截图是从接口文档swagger，将这个数据包拷贝粘贴到上面的文本中(Paste Raw Text) 也可以自动生成请求 。</p><p> <img src="/img/blog/postman/14/014-14.png" alt="img"> </p><blockquote><p> 总之，这个功能非常实用，尤其是可以把浏览器或抓包工具中的数据包导入进来直接使用，大大的减少了我们的接口实现时间 。</p></blockquote><p>  &lt;！–more–&gt; </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这又是一个非常实用的功能。可以将postman中的集合脚本，环境变量、全局变量导出，然后分享到团队成员，也可以通过导出后的脚本通过newman生成测试报告。更牛的是可以把浏览器，抓包工具，接口文档(swagger)中的数据包导入到postman中，并且会自动生成一个请求 。非常非常的方便 。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试13-认证-Authorization</title>
    <link href="https://xuepengju.github.io/posts/dcc42dc3/"/>
    <id>https://xuepengju.github.io/posts/dcc42dc3/</id>
    <published>2022-02-11T14:13:55.000Z</published>
    <updated>2022-02-11T14:13:55.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Authorization是什么？"><a href="#Authorization是什么？" class="headerlink" title="Authorization是什么？"></a>Authorization是什么？</h1><p>这又是一个非常实用的功能，对我们做接口测试来说，经常要处理登录认证的情况 。 <a id="more"></a> 如果不用这个Authorization其实也能解决认证的问题，无非就是把要认证的数据按照要求在指定位置传入参数即可。比如我们之前测试的系统，登录后返回的token要在每个请求接口的headers中传入 。这时就需要在每个headers中都填写一个认证参数传入 ，但是这样做的话太过繁琐，如果使用认证(Authorization)功能的话，就会大大简化了我们的认证过程。</p><p>我们先来看下这个功能的具体位置及主要作用 。<br> <img src="/img/blog/postman/13/013-01.png" alt="img"></p><p>Inherit auto from parent:从父级继承身份验证，是每个请求的默认选择 。这是一个很有用的功能，当我们对一个集合(collection)进行测试的时候，集合中的每个请求都需要获取token，那么如果我们在集合中把token处理好的话，那么该集合下的所有请求都会自动获取到这个token，也就省略了我们对每个token进行处理了。</p><h3 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h3><p><img src="/img/blog/postman/13/013-02.png" alt="img"></p><p> <img src="/img/blog/postman/13/013-03.png" alt="img"><br> <img src="/img/blog/postman/13/013-04.png" alt="img"></p><h3 id="No-Auth-无需身份认证的可以选择这个-。"><a href="#No-Auth-无需身份认证的可以选择这个-。" class="headerlink" title="No Auth: 无需身份认证的可以选择这个 。"></a>No Auth: 无需身份认证的可以选择这个 。</h3><p>选中一个集合进行编辑，切换到Pre-Request Script.在这里请求登录接口 ，将返回的token值拿到，然后保存成全局变量 。</p><p>切换到Authorization选项卡，在这里直接获取token 。这里的获取token需要根据具体的项目 。比如我们所测试的项目正好是Bearer token这种形式 。直接在列表中使用这种方式输入{undefined{token}}即可。</p><p>向集合添加请求，无需进行token处理，所有接口都能请求成功 。</p><h3 id="API-Key-也有很多系统是通过这种认证方式，比如在请求头添加-model-data-xxx-xxx-xxx-xxxx"><a href="#API-Key-也有很多系统是通过这种认证方式，比如在请求头添加-model-data-xxx-xxx-xxx-xxxx" class="headerlink" title="API Key: 也有很多系统是通过这种认证方式，比如在请求头添加 model: data xxx-xxx-xxx-xxxx"></a>API Key: 也有很多系统是通过这种认证方式，比如在请求头添加 model: data xxx-xxx-xxx-xxxx</h3><p><img src="/img/blog/postman/13/013-05.png" alt="img"></p><h3 id="Bearer-Token-很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer-Token-。那么使用这种认证就非常方便-。"><a href="#Bearer-Token-很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer-Token-。那么使用这种认证就非常方便-。" class="headerlink" title="Bearer Token:很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer Token 。那么使用这种认证就非常方便 。"></a>Bearer Token:很多系统都是以这种认证方式，就是在请求头中添加Authorization：Bearer Token 。那么使用这种认证就非常方便 。</h3><p><img src="/img/blog/postman/13/013-06.png" alt="img"></p><blockquote><p>总之，需要认证方式要根据所测试的系统而定，通过Authorization来处理认证后，能大大节省我们的工作量。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Authorization是什么？&quot;&gt;&lt;a href=&quot;#Authorization是什么？&quot; class=&quot;headerlink&quot; title=&quot;Authorization是什么？&quot;&gt;&lt;/a&gt;Authorization是什么？&lt;/h1&gt;&lt;p&gt;这又是一个非常实用的功能，对我们做接口测试来说，经常要处理登录认证的情况 。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试12-请求前置脚本</title>
    <link href="https://xuepengju.github.io/posts/99817e93/"/>
    <id>https://xuepengju.github.io/posts/99817e93/</id>
    <published>2022-02-08T14:24:22.000Z</published>
    <updated>2022-02-08T14:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="什么是前置脚本"><a href="#什么是前置脚本" class="headerlink" title="什么是前置脚本"></a>什么是前置脚本</h1><p>前置脚本其实就是在Pre-requests Script中编写的JavaScript脚本，想要了解这个功能，需要先了解它的执行顺序。那么下面就来看下它的执行顺序 。 <a id="more"></a> </p><p> <img src="/img/blog/postman/12/012-01.png" alt="img"> </p><p>可以看出，一个请求在发送之前，会先去执行Pre Request Script（前置脚本）中的代码 。那么这个功能在实际工作中有什么作用呢 ？</p><p>主要场景：一般情况下，在发送请求前需要对接口的数据做进一步处理，就都可以使用这个功能，比如说，登录接口的密码，在发送前需要做加密处理，那么就可以在前置脚本中做加密处理，再比如说，有的接口的输入参数有一些随机数，每请求一次接口参数值都会发送变化，就可以在前置脚本中编写生成随机数的代码 。</p><p>总结来说，就是在请求接口之前对我们的请求数据进行进一步加工处理的都可以使用前置脚本这个功能。</p><h1 id="接下来通过一个案例来看下该功能是如何使用-？"><a href="#接下来通过一个案例来看下该功能是如何使用-？" class="headerlink" title="接下来通过一个案例来看下该功能是如何使用 ？"></a>接下来通过一个案例来看下该功能是如何使用 ？</h1><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p>请求的充值接口，要做个抽奖的活动，随机到谁，就充值给谁，那么这个ID就是一个随机数</p><p> <img src="/img/blog/postman/12/012-02.png" alt="img"> </p><h3 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h3><p>​    1、在前置脚本中编写生成随机数</p><p>​    2、将这个值保存成环境变量</p><p>​    3、将ID的值替换成环境变量的值 。</p><blockquote><p>总之，这个前置脚本对我们做接口测试也非常有用，对一些复杂的场景，都可以使用前置脚本进行处理后再请求接口 。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是前置脚本&quot;&gt;&lt;a href=&quot;#什么是前置脚本&quot; class=&quot;headerlink&quot; title=&quot;什么是前置脚本&quot;&gt;&lt;/a&gt;什么是前置脚本&lt;/h1&gt;&lt;p&gt;前置脚本其实就是在Pre-requests Script中编写的JavaScript脚本，想要了解这个功能，需要先了解它的执行顺序。那么下面就来看下它的执行顺序 。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试11-接口关联</title>
    <link href="https://xuepengju.github.io/posts/adb093cd/"/>
    <id>https://xuepengju.github.io/posts/adb093cd/</id>
    <published>2022-02-07T16:13:08.000Z</published>
    <updated>2022-02-07T16:13:08.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="什么是关联接口"><a href="#什么是关联接口" class="headerlink" title="什么是关联接口"></a>什么是关联接口</h1><p>在我们测试的接口中，经常出现这种情况 。 上一个接口的返回数据是下一个接口的输入参数 ，那么这俩个接口就产生了关联关系 。 这种关联在做接口测试时非常常见，那么在postman中，如何实现这种关联关系呢 ？我们通过一个案例来实现。 <a id="more"></a> </p><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><p>用户充值，需要用户先登录，然后在进行充值操作：</p><p>调用登录接口成功后会返回如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  &quot;code&quot;: 0,</span><br><span class="line"></span><br><span class="line">  &quot;msg&quot;: &quot;OK&quot;,</span><br><span class="line"></span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    &quot;id&quot;: 4,</span><br><span class="line"></span><br><span class="line">    &quot;leave_amount&quot;: 6300.0,</span><br><span class="line"></span><br><span class="line">    &quot;mobile_phone&quot;: &quot;15943873886&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;reg_name&quot;: &quot;Auto_Test&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;reg_time&quot;: &quot;2022-02-03 07:38:06.0&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;type&quot;: 0,</span><br><span class="line"></span><br><span class="line">    &quot;token_info&quot;: &#123;</span><br><span class="line"></span><br><span class="line">      &quot;token_type&quot;: &quot;Bearer&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;expires_in&quot;: &quot;2022-02-07 16:24:08&quot;,</span><br><span class="line"></span><br><span class="line">      &quot;token&quot;: &quot;eyJhbGciOiJIUzUxMiJ9.eyJtZW1iZXJfaWQiOjQsImV4cCI6MTY0NDI1MTA0OH0.yXw4-_vnTJs3c1wPTwd8saMae8OP1jQ7Vlizvv0wygoD0ZCwX9Ahe6AHUEKsPJeOKkxfcXDXBcW4JNJ8mDkuvw&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而充值接口需要传入token，登录接口正好返回了token。那么这俩个接口就产生了关联 。那么在postman 可以通过以下三步完成这俩个接口的关联实现 。</p><h3 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h3><ol><li><p>登录获取后获取token</p></li><li><p>将token保存到环境变量</p></li><li><p>充值接口调用环境变量中的token就可以实现业务操作</p><p><img src="/img/blog/postman/11/011-01.png" alt="登录"><br><img src="/img/blog/postman/11/011-02.png" alt="充值"> </p></li></ol><blockquote><p> 可以看出，接口的关联的解决方案都是用的是变量中的知识，也就是说只要你明确了要提取的值，后面就是保存该值，然后在其他接口使用该值就可以了。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是关联接口&quot;&gt;&lt;a href=&quot;#什么是关联接口&quot; class=&quot;headerlink&quot; title=&quot;什么是关联接口&quot;&gt;&lt;/a&gt;什么是关联接口&lt;/h1&gt;&lt;p&gt;在我们测试的接口中，经常出现这种情况 。 上一个接口的返回数据是下一个接口的输入参数 ，那么这俩个接口就产生了关联关系 。 这种关联在做接口测试时非常常见，那么在postman中，如何实现这种关联关系呢 ？我们通过一个案例来实现。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试10-全局变量-集合变量-环境变量</title>
    <link href="https://xuepengju.github.io/posts/c98d9940/"/>
    <id>https://xuepengju.github.io/posts/c98d9940/</id>
    <published>2022-01-23T13:13:56.000Z</published>
    <updated>2022-01-23T13:13:56.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。</p></blockquote> <a id="more"></a> 对我们做接口测试来说，又是一个非常重要的功能 。<h2 id="在postman常用的三种变量分别是全局变量，环境变量，集合变量-。"><a href="#在postman常用的三种变量分别是全局变量，环境变量，集合变量-。" class="headerlink" title="在postman常用的三种变量分别是全局变量，环境变量，集合变量 。"></a>在postman常用的三种变量分别是全局变量，环境变量，集合变量 。</h2><blockquote><p>全局变量：一旦申明了全局变量，全局有效，也就是说postman中的任何集合，任何请求中都可以使用这个变量。它的作用域是最大的 。</p></blockquote><blockquote><p>环境变量：要申明环境变量，首先的创建环境，然后在环境中才能创建变量 。如果要想使用环境变量，必须先选择(导入)这个环境，这样就可以使用这个环境下的变量了 。需要说明的是环境也可以创建多个 。每个环境下又可以有多个变量 。</p></blockquote><blockquote><p>集合变量：集合变量是针对集合的，也就是说申明的变量必须基于某个集合，它的使用范围也只是针对这个集合有效 。</p></blockquote><p>其中，他们的作用域范围依次从大到小：全局变量&gt;集合变量&gt;环境变量 。 当在几个不同的范围内都申明了相同的变量时，则会优先使用范围最小的变量使。</p><h2 id="想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量-。"><a href="#想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量-。" class="headerlink" title="想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。"></a>想要使用变量中的值只需俩个步骤，分别是定义变量和获取变量 。</h2><pre><code>1.定义变量（设置变量）2.获取变量（访问变量）</code></pre><h3 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="1. 定义变量"></a>1. 定义变量</h3><p>定义全局变量和环境变量，点击右上角的小齿轮，弹出如下界面，就可以根据需求定义全局变量或者环境变量了。</p><p> <img src="/img/blog/postman/10/010-01.png" alt="img"> </p><p>已经定义的全局变量和环境变量，可以进行快速查看</p><p> <img src="/img/blog/postman/10/010-02.png" alt="img"> </p><h3 id="2-定义集合变量"><a href="#2-定义集合变量" class="headerlink" title="2.定义集合变量"></a>2.定义集合变量</h3><h4 id="2-1-选择一个集合，打开查看更多动作-…-菜单，然后点击编辑-。选择“变量”选项卡以编辑或添加到集合变量。"><a href="#2-1-选择一个集合，打开查看更多动作-…-菜单，然后点击编辑-。选择“变量”选项卡以编辑或添加到集合变量。" class="headerlink" title="2.1 选择一个集合，打开查看更多动作(…)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。"></a>2.1 选择一个集合，打开查看更多动作(…)菜单，然后点击编辑 。选择“变量”选项卡以编辑或添加到集合变量。</h4><p> <img src="/img/blog/postman/10/010-03.png" alt="img"> </p><p> <img src="/img/blog/postman/10/010-04.png" alt="img"> </p><h4 id="2-2-定义变量除了以上方式，还有另外一种方式-。但是这种方式在不同的位置定义，编写不一样。"><a href="#2-2-定义变量除了以上方式，还有另外一种方式-。但是这种方式在不同的位置定义，编写不一样。" class="headerlink" title="2.2 定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。"></a>2.2 定义变量除了以上方式，还有另外一种方式 。但是这种方式在不同的位置定义，编写不一样。</h4><p>在URL，Params , Authorization , Headers , Body中定义：</p><p>手工方式创建一个空的变量名</p><p>在以上的位置把想要的值选中右击，选中Set：环境|全局 ，选中一个变量名，点击后就会保存到这个变量中</p><p> <img src="/img/blog/postman/10/010-05.png" alt="img"> </p><p>在Tests，Pre-requests Script：</p><p>定义全局变量：pm.collectionVariables.set(“变量名”,变量值)</p><p>定义环境变量：pm.environment.set(“变量名”，变量值)</p><p>定义集合变量：pm.variables.set(“变量名”,变量值)</p><h3 id="3-获取变量"><a href="#3-获取变量" class="headerlink" title="3.获取变量"></a>3.获取变量</h3><p>定义好变量，接下来就可以使用变量了 。需要注意的是，在不同的位置获取变量，编写的规则也是不一样的 。</p><p>如果在请求参数中获取变量，无论是获取全局变量，还是环境变量，还是集合变量，获取的方式都是一样的编写规则：{undefined{变量名}} 。</p><p>请求参数指的是：URL，Params , Authorization , Headers , Body</p><p>如果是在编写代码的位置(Tests,Pre-requests Script)获取变量，获取不同类型的变量，编写的代码都不相同，具体如下：</p><p>获取环境变量：pm.environment.get(‘变量名’)</p><p>获取全局变量：pm.globals.get(‘变量名’)</p><p>获取集合变量：pm.pm.collectionVariables.get.get(‘变量名’)</p><p> <img src="/img/blog/postman/10/010-06.png" alt="img"> </p><p>变量的使用场景非常广泛，比如我们后面要提到的接口关联，请求前置脚本都会使用到变量 。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;变量可以使我们在请求或脚本中存储和重复使用其值，通过将值保存在变量中，可以在集合，环境或请求中引用。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记-Python之生成器和列表推导式的区别</title>
    <link href="https://xuepengju.github.io/posts/30fa304c/"/>
    <id>https://xuepengju.github.io/posts/30fa304c/</id>
    <published>2022-01-17T15:32:48.000Z</published>
    <updated>2022-01-17T15:32:48.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>生成器表达式和列表推导式的区别记录<a id="more"></a></p><h2 id="生成器表达式和列表推导式的区别"><a href="#生成器表达式和列表推导式的区别" class="headerlink" title="生成器表达式和列表推导式的区别:"></a>生成器表达式和列表推导式的区别:</h2><ul><li>列表推导式比较耗内存. 一次性加载. 生成器表达式几乎不占用内存. 使用的时候才分<br>配和使用内存</li><li>得到的值不一样. 列表推导式得到的是一个列表. 生成器表达式获取的是一个生成器.<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2></li><li>同样一篮子鸡蛋. 列表推导式: 直接拿到一篮子鸡蛋. 生成器表达式: 拿到⼀个老母鸡. 需要<br>鸡蛋就给你下鸡蛋.</li><li>生成器的惰性机制: 生成器只有在访问的时候才取值. 说白了了. 你找他要他才给你值. 不找他<br>要. 他是不会执行的.</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;生成器表达式和列表推导式的区别记录</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Python基础篇02-list和tuple常用操作</title>
    <link href="https://xuepengju.github.io/posts/d2331223/"/>
    <id>https://xuepengju.github.io/posts/d2331223/</id>
    <published>2022-01-16T07:48:20.000Z</published>
    <updated>2022-01-16T07:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>list和tuple常用操作<a id="more"></a></p><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><ul><li>列表用[]定义</li><li>如果列表有多个元素,元素和元素用逗号隔开</li><li>用[下标]方式访问列表中具体的元素</li><li>下标从0开始<ul><li>列表中第一个元素下标为0</li></ul></li><li>如果下标超过列表中元素的范围,程序出错</li></ul><h2 id="list常用方法"><a href="#list常用方法" class="headerlink" title="list常用方法"></a>list常用方法</h2><ul><li><p>insert(索引, 值)</p><ul><li>往列表指定的索引位置插入指定的值</li></ul></li><li><p>append(值)</p><ul><li>在列表的最后追加指定的值</li></ul></li><li><p>extend(列表)</p><ul><li>把指定列表追加到后面,相当于两个列表合并</li></ul></li><li><p>列表名[索引] = 值</p><ul><li>修改列表元素的值</li></ul></li></ul><h3 id="代码举例："><a href="#代码举例：" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_add_method</span><span class="params">()</span>:</span></span><br><span class="line">    list_date = []</span><br><span class="line">    <span class="keyword">return</span> list_date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历输出列表所以内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> data:</span><br><span class="line">        print(<span class="string">"list_data第"</span>, data.index(n), end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">"个数据为："</span>, n)</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = list_add_method()</span><br><span class="line">    data.append(<span class="string">"append在末尾添加数据"</span>)</span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    data.insert(<span class="number">0</span>, <span class="string">"insert在指定索引位置增加数据"</span>)</span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    list_extend_date = [<span class="string">"飞花"</span>, <span class="string">"血月"</span>]</span><br><span class="line">    <span class="comment"># extend方法 追加另一个列表的值到这个列表</span></span><br><span class="line">    data.extend(list_extend_date)</span><br><span class="line">    get_all_data(data)</span><br><span class="line">    </span><br><span class="line">    data[<span class="number">1</span>] = <span class="string">"修改index为1的数据为NONE"</span></span><br><span class="line">    get_all_data(data)</span><br></pre></td></tr></table></figure><h2 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h2><ul><li>del(列表名[索引])<ul><li>删除列表指定索引位置的元素</li></ul></li><li>列表名.remove(值)<ul><li>删除列表中指定值</li></ul></li><li>列表名.pop()<ul><li>删除最后一个元素</li></ul></li><li>列表名.pop(索引)<ul><li>删除指定索引位置元素</li><li>类似于del</li></ul></li><li>列表名.clear()<ul><li>删除列表所有元素</li></ul></li></ul><h3 id="代码举例：-1"><a href="#代码举例：-1" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_del_method</span><span class="params">()</span>:</span></span><br><span class="line">    list_date = [<span class="string">"采薇采薇，薇亦作止"</span>, <span class="string">"曰归曰归，岁亦莫止"</span>, <span class="string">"靡室靡家，猃狁之故"</span>, <span class="string">"不遑启居，猃狁之故"</span>]</span><br><span class="line">    <span class="keyword">return</span> list_date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历输出列表所以内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> data:</span><br><span class="line">        print(<span class="string">"list_data第"</span>, data.index(n), end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">"个数据为："</span>, n)</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = list_del_method()</span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">del</span> (data[<span class="number">0</span>])  <span class="comment"># 删除指定索引的数据</span></span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    data.pop(<span class="number">1</span>)  <span class="comment"># 删除指定索引数据</span></span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    data.pop()  <span class="comment"># 删除末尾数据</span></span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    data.clear()  <span class="comment"># 清空列表</span></span><br><span class="line">    get_all_data(data)</span><br></pre></td></tr></table></figure><h2 id="统计列表元素"><a href="#统计列表元素" class="headerlink" title="统计列表元素"></a>统计列表元素</h2><ul><li><p>列表名.count(值)</p><ul><li>统计指定值在列表中出现的次数</li></ul></li><li><p>列表名.index(值)</p><ul><li>计算指定值的下标</li><li>如果有多个相同的值,返回第一个值的下标</li><li>如果值不存在,程序出错</li></ul></li></ul><h3 id="代码举例：-2"><a href="#代码举例：-2" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_del_method</span><span class="params">()</span>:</span></span><br><span class="line">    list_date = [<span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="keyword">return</span> list_date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历输出列表所以内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># 列表index函数，获取当前下标的值</span></span><br><span class="line">        print(<span class="string">"list_data第"</span>, data.index(n), end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">"个数据为："</span>, n)</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = list_del_method()</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印6在列表中出现了几次</span></span><br><span class="line">    print(<span class="string">"6在列表中出现了"</span>, data.count(<span class="number">6</span>), <span class="string">"次"</span>)</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br></pre></td></tr></table></figure><h2 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h2><ul><li>列表名.sort()<ul><li>升序排序</li></ul></li><li>列表名.sort(reverse=True)<ul><li>降序排序</li></ul></li><li>列表名.reverse()<ul><li>逆置,把列表中所有的元素颠倒过来</li></ul></li></ul><h3 id="代码举例：-3"><a href="#代码举例：-3" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_del_method</span><span class="params">()</span>:</span></span><br><span class="line">    list_date = [<span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br><span class="line">    <span class="keyword">return</span> list_date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历输出列表所以内容</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> data:</span><br><span class="line">        <span class="comment"># 列表index函数，获取当前下标的值</span></span><br><span class="line">        print(<span class="string">"list_data第"</span>, data.index(n), end=<span class="string">""</span>)</span><br><span class="line">        print(<span class="string">"个数据为："</span>, n)</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    data = list_del_method()</span><br><span class="line">    print(<span class="string">"_"</span> * <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"升序排序"</span>)</span><br><span class="line">    data.sort()  <span class="comment"># 升序排序</span></span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"降序排序"</span>)</span><br><span class="line">    data.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 降序排序</span></span><br><span class="line">    get_all_data(data)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"逆置，反转"</span>)</span><br><span class="line">    data.reverse()</span><br><span class="line">    get_all_data(data)</span><br></pre></td></tr></table></figure><h1 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h1><ul><li>拆包就是把列表或者元组或者集合以及字典中的每个元素拆分出来</li><li>变量1, 变量2, 变量n = 列表名<ul><li>等号左边变量的数量要和等号右边列表中元素的数量一致</li></ul></li></ul><h1 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h1><ul><li>可以快速的生成一个比较大的列表</li><li>[x for x in range(10)]<ul><li>从1到9,9个数字</li></ul></li><li>[x for x in range(3, 100)]<ul><li>从3到99</li></ul></li><li>带条件的推导式</li><li>[x for x in range(1, 100) if x % 3 == 0]<ul><li>从1到99所有能被3整除的数字</li></ul></li></ul><h3 id="代码举例：-4"><a href="#代码举例：-4" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 列表推导式 定义一个长列表</span></span><br><span class="line">    <span class="comment"># 从1到99步长为2的所以数字</span></span><br><span class="line">    data = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>)]</span><br><span class="line">    <span class="comment"># 从1到99所以能被3整除的数字</span></span><br><span class="line">    data1 = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100</span>, <span class="number">2</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 解包list</span></span><br><span class="line">    print(*data)</span><br><span class="line">    print(*data1)</span><br></pre></td></tr></table></figure><h1 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h1><ul><li>dir查看对象所有的方法<ul><li>dir(变量名)</li></ul></li><li>len返回非数字类型的元素数量<ul><li>包括列表,字符串,元组等</li></ul></li><li>len(变量名)</li><li>max(列表)<ul><li>返回列表中最大的元素</li></ul></li><li>min(列表)<ul><li>返回列表中最小的元素</li></ul></li><li>值 in 列表<ul><li>判断指定的值是否在列表里面,如果在返回True,否则返回False</li><li>可以是列表,也可以是字符串和其他非数字类型</li></ul></li><li>值 not in 列表<ul><li>判断指定的值是否不在列表里面,如果不在,返回True,在返回False</li></ul></li></ul><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><ul><li>元组和列表类似,区别是元组的元素不能修改</li><li>通过()定义元组</li><li>a = ()<ul><li>定义一个空元组</li></ul></li><li>a = (1, )<ul><li>定义一个只有一个元素的元组</li></ul></li><li>a = (1, 2, 3)<ul><li>定义有三个元素的元组</li></ul></li><li>定义元组的时候可以省略()</li><li>a = 1, 2, 3</li></ul><h3 id="代码举例：-5"><a href="#代码举例：-5" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 元祖和列表区别式，元祖定义后不可修改</span></span><br><span class="line">    <span class="comment"># 定义一个空元祖</span></span><br><span class="line">    tuple01 = ()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义1个值得元祖，需要在值后面加，</span></span><br><span class="line">    str = (<span class="string">"Test"</span>)</span><br><span class="line">    tuple02 = (<span class="string">"Test"</span>,)</span><br><span class="line">    print(<span class="string">"str的类型为："</span>, type(str))</span><br><span class="line">    print(<span class="string">"tuple02的类型为："</span>, type(tuple02))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义元祖可省略括号</span></span><br><span class="line">    tuple03 = <span class="string">"Test"</span>, <span class="string">"我是元祖"</span>, <span class="string">"Test"</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"tuple03的类型为："</span>, type(tuple03))</span><br><span class="line">    print(*tuple03)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> tuple03:</span><br><span class="line">        print(tuple03.index(n))</span><br><span class="line">        print(tuple03.count(n))</span><br></pre></td></tr></table></figure><h2 id="元组和列表的区别"><a href="#元组和列表的区别" class="headerlink" title="元组和列表的区别"></a>元组和列表的区别</h2><ul><li>元组可以理解为一个只读的列表,除了修改元素方法不同,其他方法和列表相同</li></ul><h2 id="元组和列表的转换"><a href="#元组和列表的转换" class="headerlink" title="元组和列表的转换"></a>元组和列表的转换</h2><ul><li>列表变量 = list(元组变量)<ul><li>把元组转换为列表</li></ul></li><li>元组变量 = tuple(列表变量)<ul><li>把列表转换为元组</li></ul></li><li>在python中转化数据类型就是用, 数据类型的关键字(要转化的内容)<ul><li>要转化内容一定是可转化的</li></ul></li></ul><h3 id="代码举例：-6"><a href="#代码举例：-6" class="headerlink" title="代码举例："></a>代码举例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 元祖和列表区别式，元祖定义后不可修改</span></span><br><span class="line">    <span class="comment"># 定义一个空元祖</span></span><br><span class="line">    tuple01 = (<span class="string">"Test"</span>, <span class="string">"我是元祖"</span>, <span class="string">"Test"</span>)</span><br><span class="line"></span><br><span class="line">    print(type(tuple01))</span><br><span class="line">    list01 = list(tuple01)</span><br><span class="line">    print(type(list01))</span><br><span class="line">    list01.append(<span class="string">"转list后可修改数据"</span>)</span><br><span class="line">    <span class="comment"># 在转回tuple</span></span><br><span class="line">    tuple02 = tuple(list01)</span><br><span class="line">    print(type(tuple02))</span><br><span class="line">    print(*tuple02)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;list和tuple常用操作</summary>
    
    
    
    <category term="Python自动化" scheme="https://xuepengju.github.io/categories/Python%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    
    <category term="Python自动化" scheme="https://xuepengju.github.io/tags/Python%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试09-日志调试</title>
    <link href="https://xuepengju.github.io/posts/344e3c5b/"/>
    <id>https://xuepengju.github.io/posts/344e3c5b/</id>
    <published>2022-01-14T16:39:30.000Z</published>
    <updated>2022-01-14T16:39:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>在做接口测试时，经常会因为代码写的有问题导致报错，这时通过查看日志就显得非常重要了，postman也提供了这样的功能，它允许我们在脚本中编写打印语句，查看打印的结果 ; 同时也可以查看每个请求的日志信息 。 <a id="more"></a> </p></blockquote><h2 id="postman日志用的是什么编程语言？"><a href="#postman日志用的是什么编程语言？" class="headerlink" title="postman日志用的是什么编程语言？"></a>postman日志用的是什么编程语言？</h2><p>在postman中编写日志打印语句使用的是JavaScript，编写的位置可以是Pre-request Script 或Tests标签中。编写打印语句如：console.log(“hello,postman”)</p><p> <img src="/img/blog/postman/09/09-01.png" alt="img"> </p><h2 id="那么打印的日如何看呢-？"><a href="#那么打印的日如何看呢-？" class="headerlink" title="那么打印的日如何看呢 ？"></a>那么打印的日如何看呢 ？</h2><p>在postman中有俩个入口，第一个入口就是：view-show postman console 。</p><p>第二个入口就是左下角第三个图标 。</p><p> <img src="/img/blog/postman/09/09-02.png" alt="img"> </p><h3 id="打开的日志界面"><a href="#打开的日志界面" class="headerlink" title="打开的日志界面"></a>打开的日志界面</h3><p> <img src="/img/blog/postman/09/09-03.png" alt="img"> </p><p>这里面有几个比较实用的功能：</p><p>搜索日志：输入URL或者打印的日志就能直接搜索出我们想要的请求和日志，这对我们在众多日志中查找某一条日志是非常方便的 。</p><ul><li>按级别搜索：可以查询log,info,warning,error级别的日志 ，有助于我们更快定位到错误 。</li></ul><ul><li>查看原始报文(Show raw log)：如果习惯看原始请求报文的话，这个功能可能更方便些 。</li></ul><ul><li>隐藏请求(Hide network)：把请求都隐藏掉，只查看输出日志 。</li></ul><p>总之，通过这个功能，我们在请求接口报错时，通过打印响应的日志，就能很轻松的找到问题原因了 。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在做接口测试时，经常会因为代码写的有问题导致报错，这时通过查看日志就显得非常重要了，postman也提供了这样的功能，它允许我们在脚本中编写打印语句，查看打印的结果 ; 同时也可以查看每个请求的日志信息 。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>【公开api接口】字符串加密/解密API接口</title>
    <link href="https://xuepengju.github.io/posts/689fc75c/"/>
    <id>https://xuepengju.github.io/posts/689fc75c/</id>
    <published>2022-01-13T15:48:20.000Z</published>
    <updated>2022-01-13T15:48:20.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>一个公开的加解密接口记录学习<a id="more"></a></p></blockquote><ul><li>接口地址：<a href="https://api.vvhan.com/api/jm" target="_blank" rel="noopener">https://api.vvhan.com/api/jm</a></li><li>返回格式： JSON</li><li>请求方式：GET</li></ul><h4 id="请求示例-加密-："><a href="#请求示例-加密-：" class="headerlink" title="请求示例(加密)："></a>请求示例(加密)：</h4><blockquote><p><a href="https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要加密的内容&amp;type=en" target="_blank" rel="noopener">https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要加密的内容&amp;type=en</a></p></blockquote><h4 id="请求示例-解密-："><a href="#请求示例-解密-：" class="headerlink" title="请求示例(解密)："></a>请求示例(解密)：</h4><blockquote><p><a href="https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要解密的内容&amp;type=de" target="_blank" rel="noopener">https://api.vvhan.com/api/jm?key=自定义密码&amp;string=需要解密的内容&amp;type=de</a></p></blockquote><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><table><thead><tr><th align="left">名称</th><th align="left">必填</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">key</td><td align="left">否</td><td align="left">string</td><td align="left">自定义密匙</td></tr><tr><td align="left">string</td><td align="left">是</td><td align="left">string</td><td align="left">加/解密内容</td></tr><tr><td align="left">type</td><td align="left">否</td><td align="left">string</td><td align="left">en表示加密,de表示解密(默认)</td></tr></tbody></table><h4 id="返回数据"><a href="#返回数据" class="headerlink" title="返回数据"></a>返回数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加密：&#123;&quot;enmissString&quot;:&quot;InFYZ0VPKzVzTkdxUWlxV1VXVnA5cmtCenRxYkNTY3JUeVwvVWtxTm16VHNjPSI&#x3D;&quot;&#125;</span><br><span class="line">解密：&#123;&quot;demissString&quot;:小韩网络&#125;</span><br></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?phpheader(&#39;Content-type:text&#x2F;json;charset&#x3D;utf-8;&#39;);</span><br><span class="line">$key&#x3D;$_GET[&#39;key&#39;];</span><br><span class="line">$string&#x3D;$_GET[&#39;string&#39;];</span><br><span class="line">$type&#x3D;$_GET[&#39;type&#39;];</span><br><span class="line">$result &#x3D; file_get_contents(&#39;https:&#x2F;&#x2F;api.vvhan.com&#x2F;api&#x2F;jm?key&#x3D;&#39;.$key.&#39;&amp;string&#x3D;&#39;.$string.&#39;&amp;type&#x3D;&#39;.$type);</span><br><span class="line">echo $result;?&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个公开的加解密接口记录学习</summary>
    
    
    
    <category term="技术积累" scheme="https://xuepengju.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="API" scheme="https://xuepengju.github.io/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试08-测试断言</title>
    <link href="https://xuepengju.github.io/posts/2ab40ef8/"/>
    <id>https://xuepengju.github.io/posts/2ab40ef8/</id>
    <published>2022-01-13T14:28:02.000Z</published>
    <updated>2022-01-13T14:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>如果没有断言这个功能，那我们的测试就只能是通过我们人工比较预期结果和实际结果是否一致。有了这个功能就为我们做自动化提供了条件，postman中的断言也是非常方便的 。 <a id="more"></a> </p></blockquote><h1 id="我们先来了解下postman断言的一些特点-，具体如下"><a href="#我们先来了解下postman断言的一些特点-，具体如下" class="headerlink" title="我们先来了解下postman断言的一些特点 ，具体如下"></a>我们先来了解下postman断言的一些特点 ，具体如下</h1><ul><li>断言编写位置：Tests标签</li></ul><ul><li>断言所用语言：JavaScript</li></ul><ul><li>断言执行顺序：在响应体数据返回后执行 。</li></ul><ul><li>断言执行结果查看：Test Results</li></ul><p>在上面我们介绍到，编写的断言代码是JavaScript，那如果不会写怎么办 ？ 不用担心，因为postman已经给我们内置了一些常用的断言 。用的时候，只需从右侧点击其中一个断言，就会在文本框中自动生成对应断言代码块 。</p><p> <img src="/img/blog/postman/08/08-01.png" alt="img"> </p><h1 id="接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。"><a href="#接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。" class="headerlink" title="接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。"></a>接下来就让我们了解一些常用断言，还是按响应的组成来划分，分别是状态行，响应头，响应体。</h1><p>本次使用公开天气api接口演示「<a href="http://doc.tianqiapi.com/」" target="_blank" rel="noopener">http://doc.tianqiapi.com/」</a></p><p>状态行中又包括状态码，状态消息 。在postman也可以对这俩个进行断言</p><h2 id="状态行中的断言："><a href="#状态行中的断言：" class="headerlink" title="状态行中的断言："></a>状态行中的断言：</h2><h3 id="断言状态码：Status-code-code-is-200"><a href="#断言状态码：Status-code-code-is-200" class="headerlink" title="断言状态码：Status code: code is 200"></a>断言状态码：Status code: code is 200</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言相应状态码为200"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.status(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="断言状态消息：Status-code：code-name-has-string"><a href="#断言状态消息：Status-code：code-name-has-string" class="headerlink" title="断言状态消息：Status code：code name has string"></a>断言状态消息：Status code：code name has string</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言响应状态消息包含OK"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.status(<span class="string">"OK"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="响应头中的断言"><a href="#响应头中的断言" class="headerlink" title="响应头中的断言"></a>响应头中的断言</h2><h3 id="断言响应头中包含：Response-headers-Content-Type-header-check"><a href="#断言响应头中包含：Response-headers-Content-Type-header-check" class="headerlink" title="断言响应头中包含：Response headers:Content-Type header check"></a>断言响应头中包含：Response headers:Content-Type header check</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言响应头存在'Content-Type'"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.header(<span class="string">"Content-Type"</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="断言响应体-重点"><a href="#断言响应体-重点" class="headerlink" title="断言响应体(重点)"></a>断言响应体(重点)</h2><h3 id="断言响应体中包含XXX字符串：Response-body-Contains-string"><a href="#断言响应体中包含XXX字符串：Response-body-Contains-string" class="headerlink" title="断言响应体中包含XXX字符串：Response body:Contains string"></a>断言响应体中包含XXX字符串：Response body:Contains string</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言返回内容包含该文本"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="literal">undefined</span></span><br><span class="line">    pm.expect(pm.response.text()).to.include(<span class="string">"101010100"</span>);</span><br><span class="line">&#125;);   </span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line"><span class="comment">//pm.expect(pm.response.text()).to.include("string")      获取响应文本中包含string</span></span><br></pre></td></tr></table></figure><h3 id="断言响应体等于XXX字符串：Response-body-is-equal-to-a-string"><a href="#断言响应体等于XXX字符串：Response-body-is-equal-to-a-string" class="headerlink" title="断言响应体等于XXX字符串：Response body : is equal to a string"></a>断言响应体等于XXX字符串：Response body : is equal to a string</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"Body is correct"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.body(<span class="string">"response_body_string"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line"><span class="comment">//pm.response.to.have.body("response_body_string");   获取响应体等于response_body_string</span></span><br></pre></td></tr></table></figure><h3 id="断言响应体-json-中某个键名对应的值：Response-body-JSON-value-check"><a href="#断言响应体-json-中某个键名对应的值：Response-body-JSON-value-check" class="headerlink" title="断言响应体(json)中某个键名对应的值：Response body : JSON value check"></a>断言响应体(json)中某个键名对应的值：Response body : JSON value check</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"断言相应城市为北京"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jsonData = pm.response.json();</span><br><span class="line">    pm.expect(jsonData.city).to.eql(<span class="string">"北京"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//注解</span></span><br><span class="line"><span class="comment">//var jsonData = pm.response.json()   获取响应体，以json显示，赋值给jsonData .注意：该响应体必须返会是的json，否则会报错</span></span><br><span class="line"><span class="comment">//pm.expect(jsonData.value).to.eql("北京")  获取jsonData中键名为value的值，然后和"北京"进行比较</span></span><br></pre></td></tr></table></figure><h3 id="响应时间-一般用于性能测试"><a href="#响应时间-一般用于性能测试" class="headerlink" title="响应时间(一般用于性能测试)"></a>响应时间(一般用于性能测试)</h3><p>断言响应时间：Response time is less than 200ms</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pm.test(<span class="string">"Response time is less than 200ms"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.expect(pm.response.responseTime).to.be.below(<span class="number">200</span>);   <span class="comment">//断言响应时间&lt;200ms</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="案例说明："><a href="#案例说明：" class="headerlink" title="案例说明："></a>案例说明：</h3><p>针对以下接口返回的数据进行断言：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"cityid"</span>: <span class="string">"101010100"</span>,</span><br><span class="line">    <span class="attr">"city"</span>: <span class="string">"北京"</span>,</span><br><span class="line">    <span class="attr">"update_time"</span>: <span class="string">"22:34"</span>,</span><br><span class="line">    <span class="attr">"wea"</span>: <span class="string">"晴"</span>,</span><br><span class="line">    <span class="attr">"wea_img"</span>: <span class="string">"qing"</span>,</span><br><span class="line">    <span class="attr">"tem"</span>: <span class="string">"-2"</span>,</span><br><span class="line">    <span class="attr">"tem_day"</span>: <span class="string">"3"</span>,</span><br><span class="line">    <span class="attr">"tem_night"</span>: <span class="string">"-7"</span>,</span><br><span class="line">    <span class="attr">"win"</span>: <span class="string">"南风"</span>,</span><br><span class="line">    <span class="attr">"win_speed"</span>: <span class="string">"2级"</span>,</span><br><span class="line">    <span class="attr">"win_meter"</span>: <span class="string">"5km/h"</span>,</span><br><span class="line">    <span class="attr">"air"</span>: <span class="string">"43"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>断言响应状态码为200</p></li><li><p>断言city等于济南</p></li><li><p>断言update_time包含2020-04-17</p><p><img src="/img/blog/postman/08/08-02.png" alt="img"> </p></li></ul><blockquote><p> 总结，整体来说，如果用postman做接口测试，这个断言功能必不可少，其中我们常断言的响应体包含和JSON这俩个断言又是重重之重。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果没有断言这个功能，那我们的测试就只能是通过我们人工比较预期结果和实际结果是否一致。有了这个功能就为我们做自动化提供了条件，postman中的断言也是非常方便的 。</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
  <entry>
    <title>〖postman〗接口测试07-批量执行用例</title>
    <link href="https://xuepengju.github.io/posts/c4b6dbb9/"/>
    <id>https://xuepengju.github.io/posts/c4b6dbb9/</id>
    <published>2022-01-12T15:05:36.000Z</published>
    <updated>2022-01-12T15:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p> 当我们在一个Collection中编写了很多的接口测试用例，想一起执行这批用例，在postman中是如何操作呢 ？ <a id="more"></a> </p></blockquote><h1 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h1><h2 id="1-选中一个Collection，点击右三角，在弹出的界面点击RUN"><a href="#1-选中一个Collection，点击右三角，在弹出的界面点击RUN" class="headerlink" title="1. 选中一个Collection，点击右三角，在弹出的界面点击RUN"></a>1. 选中一个Collection，点击右三角，在弹出的界面点击RUN</h2><p> <img src="/img/blog/postman/07/07-01.png" alt="img"> </p><h2 id="2-这是会弹出一个叫Collection-Runner的界面，默认会把Collection中的所有用例选上"><a href="#2-这是会弹出一个叫Collection-Runner的界面，默认会把Collection中的所有用例选上" class="headerlink" title="2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选上."></a>2. 这是会弹出一个叫Collection Runner的界面，默认会把Collection中的所有用例选上.</h2><p> <img src="/img/blog/postman/07/07-02.png" alt="img"> </p><h2 id="3-点击界面下方的RUN-Collection，就会对Collection选中的所有测试用例运行-。"><a href="#3-点击界面下方的RUN-Collection，就会对Collection选中的所有测试用例运行-。" class="headerlink" title="3. 点击界面下方的RUN Collection，就会对Collection选中的所有测试用例运行 。"></a>3. 点击界面下方的RUN Collection，就会对Collection选中的所有测试用例运行 。</h2><p> <img src="/img/blog/postman/07/07-03.png" alt="img"> </p><h3 id="对上面的几个红框内的功能进行简单说明："><a href="#对上面的几个红框内的功能进行简单说明：" class="headerlink" title="对上面的几个红框内的功能进行简单说明："></a>对上面的几个红框内的功能进行简单说明：</h3><p>断言统计：左上角的俩个0是统计当前Collection中断言成功的执行数和失败的执行数，如果没有编写断言默认都为0 。</p><ul><li><p>Run Summary: 运行结果总览，点击它可以看到每个请求中具体的测试断言详细信息 。</p></li><li><p>Export Result：导出运行结果，默认导出的结果json文件 。</p></li><li><p>Retry: 重新运行，点击它会把该Collection重新运行一遍</p></li><li><p>New：返回到Runner，可以重新选择用例的组合 。</p></li></ul><p>总体来说，这个功能主要是用于对一个Collection中的所有用例或部分用例进行批量运行，已达到手工回归测试的目的。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt; 当我们在一个Collection中编写了很多的接口测试用例，想一起执行这批用例，在postman中是如何操作呢 ？</summary>
    
    
    
    <category term="postman" scheme="https://xuepengju.github.io/categories/postman/"/>
    
    
    <category term="postman" scheme="https://xuepengju.github.io/tags/postman/"/>
    
  </entry>
  
</feed>
